<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <script src="//cdn.optimizely.com/js/3144930209.js"></script>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on iPhones and stuff-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="icon" type="image/png" href="http://blog.hannal.com/favicon.ico" />
  <link rel="alternate" type="application/rss+xml" title="Kay on the rails RSS Feed" href="http://blog.hannal.com/feed.xml" />
  <title>
    
      Kay on the rails &middot; 
    
  </title>
  <meta property="og:title" content="Kay on the rails &middot; " />
  <meta property="og:site_name" content="Kay on the rails"/>
  <meta property="og:url" content="http://blog.hannal.com" />
  <meta property="fb:app_id" content="308847979152210" />
  <meta property="og:type" content="article" />

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  <!-- Icons -->
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <style>
  .posts h2.post-title {
    font-size: 1.6em !important;
  }

  .post-parting-line {
    border-top: 7px solid #eee !important;
    border-bottom: 7px solid #fff !important;
  }
  </style>
</head>


  <body>
    <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ko_KR/sdk.js#xfbml=1&appId=308847979152210&version=v2.0";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Kay as known as Hannal walks on the rails
</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    <a class="sidebar-nav-item" href="/category/essay/">한날의 낙서</a>
    <a class="sidebar-nav-item" href="/category/kay-on-the-team/">팀과 함께하는 한날</a>
    <a class="sidebar-nav-item" href="/category/start-with-django-lectures/">Django 입문자용 강좌</a>
    <a class="sidebar-nav-item" href="/category/start-with-django-webframework/">Django 중급자용 강좌</a>
    <a class="sidebar-nav-item" href="/category/flaskon-startup-diary/">플라스콘 창업 일지</a>
    <a class="sidebar-nav-item" href="/category/devlife/">개발 생활</a>
    <a class="sidebar-nav-item" href="/category/game/">게임 생활</a>
  </nav>

  <nav class="sidebar-nav" style="margin-top: 1.2em;">
    <a class="sidebar-nav-item" href="/profile/">소개합니다</a>
    <a class="sidebar-nav-item" href="/copyright/">저작권</a>

    
    <span class="sidebar-nav-item">Alpha v</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2021. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Kay on the rails</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h2 class="post-title">
      <a href="/2015/06/start_with_django_webframework_08/">
        8. 로그인, 로그아웃 하기
      </a>
    </h2>

    <span class="post-date">07 Jun 2015</span>

    <ul>
  <li><a href="http://blog.hannal.com/category/start-with-django-webframework/">날로 먹는 Django 웹프레임워크 강좌 목차</a></li>
  <li>마지막 갱신일시 : 2017년 1월 30일 0시 20분</li>
</ul>

<p>이번 편에서는 Django 이용자 인증 체계을 알아보고, 이 인증 체계에서 로그인을 어떻게 처리하는지 살펴 보겠습니다.</p>

<h3 id="1-django-이용자-인증-체계">1. Django 이용자 인증 체계</h3>

<p>Django 이용자 인증 체계는 크게 두 가지 요소로 구분합니다.</p>

<ul>
  <li>인증 (Authentication)</li>
  <li>권한 (Authorization)</li>
</ul>

<p>인증은 “나 누구인데 확인 좀…”이라면 권한은 “나 이거 해도 돼요?”라 보면 됩니다. 누구인지 신원이 확인되지 않은 존재에게 권한을 세밀하게 부여하진 못합니다. 신원이 확인된, 즉, 인증된 이용자인지 아닌지로 구분하는 정도로 권한을 부여합니다. 그래서, 권한 체계를 비롯하여 이용자 인증 체계 자체는 인증(Authetication)을 바탕으로 합니다.</p>

<h4 id="1-django-내장-인증-기능">(1) Django 내장 인증 기능</h4>

<p>Django는 이용자 인증 체계를 내장하고 있으며, 우리는 이미 이 기능을 사용해봤습니다. <a href="http://blog.hannal.com/2014/10/start_with_django_webframework_04/">4. Photo 모델로 Admin 영역에서 데이터 다루기</a> 편에서 최고 권한 이용자로 Admin 영역에 로그인하여 사진 게시물을 입력 했었거든요.</p>

<p>Django에 내장된 인증 체계는 <code class="highlighter-rouge">django.contrib.auth</code>라는 경로(name space)인 Python 패키지에 모여 있으며, Django 개념으로는 Django App입니다. <code class="highlighter-rouge">settings.py</code> 파일에 있는 <code class="highlighter-rouge">INSTALLED_APPS</code> 설정 항목을 보면 <code class="highlighter-rouge">'django.contrib.auth',</code>가 있는데, 우리가 만드는 Pystagram에 사용할 Django App에 Django 인증 체계가 앱 형태로 기본 내장되어 있는 것입니다.</p>

<p>Django webframework으로 제품을 만든다면 Django 인증 체계를 사용하는 게 좋습니다. 오랜 기간 개발되어 보안 수준은 성숙하고 안전하며, 확장 가능하게 유연합니다. Django에서 제공하는 다른 여러 기능이 내장된 인증 기능 구조를 따르기 때문에 Django가 제공하는 기능을 유기성 있고 풍부하게 쓰기에도 Django 인증 체계를 쓰는 게 좋습니다.</p>

<h4 id="2-django-내장-권한-기능">(2) Django 내장 권한 기능</h4>

<p>권한 검사 기능도 Django에 내장되어 있습니다. 뷰(View) 단위 행동(behaviour), 데이터 단위 행동에 권한을 부여하여 운용 가능하며, 권한을 그룹 단위로 묶어서(grouping) 이용자에게 지정하는 기능도 제공합니다. 자세한 내용은 권한 기능을 적용할 때 다루겠습니다.</p>

<h3 id="2-로그인-기능-구현">2. 로그인 기능 구현</h3>

<h4 id="1-url-패턴-추가">(1) URL 패턴 추가</h4>

<p>Django에서 제공하는 인증 기능을 이용하여 로그인, 로그아웃 기능을 구현 하겠습니다. <code class="highlighter-rouge">settings.py</code> 파일이 있는 시작패키지에서 <code class="highlighter-rouge">urls.py</code> 파일을 열고, 다음 내용을 추가합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from django.contrib.auth import views as auth_views  # 이 줄 추가.

urlpatterns = [
    # 중략
    url(
        r'^accounts/login/',
        auth_views.login,
        name='login',
        kwargs={
            'template_name': 'login.html'
        }
    ),
    url(
        r'^accounts/logout/',
        auth_views.logout,
        name='logout',
        kwargs={
            'next_page': settings.LOGIN_URL,
        }
    ),
]
</code></pre></div></div>

<p><code class="highlighter-rouge">r'^accounts/login/'</code>은 로그인 하는 URL이고, 로그인 화면을 출력하거나 로그인 인증 처리를 하는 뷰 함수는 Django에 내장된 <code class="highlighter-rouge">login</code> 뷰 함수를 사용합니다. 이 함수 객체는 <code class="highlighter-rouge">django.contrib.auth.views</code> 모듈에 존재합니다. 이 URL 패턴의 이름을 <code class="highlighter-rouge">name</code> 키워드 인자를 이용하여 <code class="highlighter-rouge">login</code>이라고 지었는데, 이 인자를 사용하지 않아도 무방합니다. <code class="highlighter-rouge">kwargs</code>는 URL 패턴에 연결한 뷰 함수에 추가로 전달할 인자를 사전형(<code class="highlighter-rouge">dict</code>) 객체로 전달합니다. 키가 <code class="highlighter-rouge">'template_name'</code>이고 값이 <code class="highlighter-rouge">'login.html'</code>인 사전형 객체인데, Django에서 제공하는 <code class="highlighter-rouge">login</code> 뷰 함수에 <code class="highlighter-rouge">template_name</code> 이름으로 키워드 인자를 지정하면 로그인 화면을 출력하는 데 사용할 템플릿으로 사용합니다. <code class="highlighter-rouge">'login.html'</code>이라는 문자열을 지정했으니 우리가 <code class="highlighter-rouge">settings.py</code>에서 <code class="highlighter-rouge">TEMPLATE_DIRS</code>에 지정한 템플릿 디렉터리 중 최상위 순위에 있는 <code class="highlighter-rouge">login.html</code> 파일을 찾아서 로그인 화면을 출력하는 데 사용합니다.</p>

<p><code class="highlighter-rouge">r'^accounts/logout/'</code>은 로그아웃 하는 URL이며, 로그아웃 기능 역시 로그인 기능과 마찬가지로 Django에 내장된 뷰 함수를 사용합니다. 키워드 인자 <code class="highlighter-rouge">next_page</code>는 로그아웃 하고 난 뒤에 이동할 URL을 의미합니다. 이 항목이 없으면 로그아웃 화면이 출력됩니다. <code class="highlighter-rouge">template_name</code>: ‘logout.html’ 등으로 지정하지 않으면 Django에 내장된 로그아웃 화면이 나타납니다.</p>

<h4 id="2-로그인-템플릿-파일">(2) 로그인 템플릿 파일</h4>

<p>이번엔 로그인 화면에 사용할 <code class="highlighter-rouge">login.html</code> 템플릿 파일을 만듭니다. <code class="highlighter-rouge">templates</code> 디렉터리에 <code class="highlighter-rouge">login.html</code> 파일을 만들고 다음 내용을 담습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{% extends "layout.html" %}

{% block content %}

{% if form.errors %}
&lt;p&gt;ID나 비밀번호가 일치하지 않습니다.&lt;/p&gt;
{% endif %}

&lt;form method="post" action="{% url 'login' %}"&gt;
{% csrf_token %}
&lt;input type="hidden" name="next" value="" /&gt;



&lt;button type="submit"&gt;로그인&lt;/button&gt;
&lt;/form&gt;

{% endblock %}
</code></pre></div></div>

<p>Django에서 견본으로 제공하는 <a href="https://docs.djangoproject.com/en/1.10/topics/auth/default/#django.contrib.auth.views.login">login.html 템플릿 파일</a>에서 따와서 약간 고쳤습니다. 따로 뷰 함수에서 템플릿으로 로그인 폼을 템플릿 컨텍스트로 전달하지 않았지만, Django에서 관례로 많이 쓰는 이름인 <code class="highlighter-rouge">form</code>을 사용했습니다. form.errors<code class="highlighter-rouge">엔 입력한 폼 양식에 문제가 있는 경우에 문제 내용이 담겨 있습니다. ID(</code>username`)나 비밀번호를 입력하지 않거나 형식에 맞지 않는 등 여러 오류 종류가 있겠지만, 간결하게 ID와 비밀번호가 일치하지 않는다고만 안내합니다. 로그인에 대해서는 굳이 친절하게 뭐가 문제인지 자세히 알려줄 필요는 없습니다.</p>

<p><code class="highlighter-rouge">{% if next %}</code>에서 <code class="highlighter-rouge">next</code>는 로그인을 한 후 이동할 URL을 뜻합니다. 예를 들어, 로그인을 하지 않은 채 사진에 달린 댓글을 삭제하려 하면 로그인하는 URL로 이동하고 로그인을 하고 나면 로그인하기 전에 접근하려는 URL으로 이동하는데, 이동할 URL이 GET이나 POST 방식으로 전달된 Query String 키인 <code class="highlighter-rouge">next</code>에 담깁니다. 대개는 URL이 <code class="highlighter-rouge">https://pystagram.com/accounts/login/?next=/redirect_to_here/</code>와 같이 표현됩니다.</p>

<p>그외엔 <a href="http://blog.hannal.com/2015/05/start_with_django_webframework_07/">7. 사진 게시물 제출하여 게시하기</a> 편 내용과 비슷합니다. <code class="highlighter-rouge">form</code>은 <code class="highlighter-rouge">django.contrib.auth.forms</code> 모듈에 있는 <code class="highlighter-rouge">AuthenticationForm</code> 폼 클래스로 생성한 인스턴스 객체입니다.</p>

<p>이제 <code class="highlighter-rouge">http://localhost:8000/accounts/login/</code>에 접속하면 로그인 화면이 나옵니다. 잘못된 <code class="highlighter-rouge">username</code>과 <code class="highlighter-rouge">password</code>을 제출하면 이에 대한 안내도 나오고요.</p>

<p>현재 구현한 로그인 기능으로 로그인을 하면 “Page not found” 오류를 만나게 됩니다. 이에 대해서는 곧 처리하겠습니다.</p>

<h3 id="3-로그인-과정">3. 로그인 과정</h3>

<p>Django가 제공하는 로그인 뷰 함수가 어떤 과정을 거쳐 이용자 인증을 처리하는지 좀 더 살펴 보겠습니다. 이 부분을 몰라도 로그인 기능을 이용하는 데 문제 없습니다.</p>

<h4 id="1-form-검증">(1) Form 검증</h4>

<p>웹 페이지에서 폼 양식으로 넘어오는 값은 Form을 이용해 값을 검증합니다. Django는 로그인 절차에 <code class="highlighter-rouge">AuthenticationForm</code> 폼을 사용하며, 이 폼은 <code class="highlighter-rouge">django.contrib.auth.forms</code> 모듈에 있습니다. 이쯤되면 눈치 채셨을텐데, Django는 인증 관련 모델, 폼, 뷰, 미들웨어 등을 <code class="highlighter-rouge">django.contrib.auth</code> 패키지 안에 담아 놨습니다. 인증과 관련된 소스 코드를 보려면 이 패키지를 살펴 보시면 됩니다.</p>

<p><code class="highlighter-rouge">AuthenticationForm</code> 폼은 현재 이용자 정보와 HTTP 요청 정보를 담은 <code class="highlighter-rouge">request</code> 객체도 함께 인자로 전달 받는데, 세션 처리에 필요하기 때문에 그렇습니다. 폼 양식 값이 유효하면(<code class="highlighter-rouge">is_valid()</code>) 이용자가 로그인 후에 이동할 URL 문자열이 안전한 지 검사합니다. 그런 뒤 <code class="highlighter-rouge">auth_login()</code> 함수를 이용해 로그인 인증 처리를 마무리하고 나서 이용자를 다음 URL로 이동(redirect) 시킵니다.</p>

<p><code class="highlighter-rouge">auth_login()</code> 함수는 이름과는 달리 실제로는 인증 과정 마무리 단계를 담당합니다. 로그인 양식을 토대로 이용자 정보를 가져와서 HTTP Request(<code class="highlighter-rouge">request</code>) 정보와 함께 사용해 서버 세션 정보를 만듭니다. 세션 정보를 만들지 않으면 로그인 정보는 유지되지 않아서 다른 페이지에 방문할 때마다 매번 로그인을 해야 합니다.</p>

<p>로그인 양식, 그러니까 로그인 하려고 제출한 <code class="highlighter-rouge">username</code>과 <code class="highlighter-rouge">password</code>에 정확히 일치하는 이용자를 찾는 과정은 <code class="highlighter-rouge">AuthenticationForm</code> 폼에서 이뤄집니다. 이 폼의 <code class="highlighter-rouge">clean()</code> 메서드에서 <code class="highlighter-rouge">username</code>과 <code class="highlighter-rouge">password</code> 내용을 토대로 <code class="highlighter-rouge">authenticate()</code> 함수를 이용해 인증을 시도합니다. 일치하는 이용자가 없으면 Form 오류를 일으키고, 우리는 “ID나 비밀번호가 일치하지 않습니다.”라는 안내를 화면에서 만납니다. 일치하는 이용자가 있으면 이 이용자 계정이 활성화 된 상태인지(<code class="highlighter-rouge">is_active</code>) 검사하는 걸로 폼 안에서 처리하는 인증 과정을 마칩니다.</p>

<h4 id="2-인증-체계-기반으로-처리">(2) 인증 체계 기반으로 처리</h4>

<p><code class="highlighter-rouge">authenticate()</code> 함수는 <code class="highlighter-rouge">settings</code>의 <code class="highlighter-rouge">AUTHENTICATION_BACKENDS</code> 항목에 등록된 인증 체계 기반 클래스를 하나씩 가져와서 <code class="highlighter-rouge">authenticate()</code> 메서드를 호출하여 인증을 시도합니다. 우리가 <code class="highlighter-rouge">settings.py</code> 파일에 따로 이 항목을 설정하지 않아도 문제가 없는 건, Django에 기본으로 내장된 <code class="highlighter-rouge">global_settings.py</code>에 이 항목이 설정되어 있기 때문입니다. 이 항목에 있는 내용은 <code class="highlighter-rouge">'django.contrib.auth.backends.ModelBackend'</code> 이름영역인 클래스가 튜플 객체로 담겨 있습니다.</p>

<p>데이터베이스에서 <code class="highlighter-rouge">username</code>와 <code class="highlighter-rouge">password</code>로 이용자를 찾는 과정이 비로소 이 단계에서 이뤄집니다. 이용자 모델을 가져오고, 이 모델을 이용해 <code class="highlighter-rouge">username</code>으로 먼저 이용자 데이터를 가져오고, 이 이용자 데이터에 저장된 비밀번호와 이용자가 로그인하며 제출한 <code class="highlighter-rouge">password</code>를 비교합니다. 비밀번호까지 일치하면 해당 이용자 데이터, 그러니까 이용자 모델로 생성한 인스턴스 객체를 반환하고, 그렇지 않으면 <code class="highlighter-rouge">None</code>을 반환합니다.</p>

<p><code class="highlighter-rouge">settings</code>의 <code class="highlighter-rouge">AUTHENTICATION_BACKENDS</code> 항목에 <code class="highlighter-rouge">django.contrib.auth.backends.ModelBackend</code>이 튜플에 담겨져 있다는 말은 다음 두 가지를 의미합니다.</p>

<ol>
  <li>Django 인증 체계 기반(backend)을 꼭 사용하지 않아도 된다.</li>
  <li>인증 체계 기반을 여러 개 이상을 사용하는 게 가능하다.</li>
</ol>

<p>인증 체계 기반의 클래스 규칙대로 인터페이스를 만들기만 한다면 우리가 직접 만든 인증 체계를 사용하거나 Facebook, Twitter처럼 인증 API를 제공하는 서비스나 플랫폼을 기반으로 인증 체계를 운용해도 됩니다.</p>

<h4 id="3-이용자-모델-가져오기">(3) 이용자 모델 가져오기</h4>

<p>인증 체계 기반을 Django에서 제공하는 기본 인증 <code class="highlighter-rouge">ModelBackend</code>를 다른 것으로 갈아끼우거나 추가한다면, 이용자 정보를 데이터베이스에서 다루는 이용자 모델도 대체하여 쓸 수 있습니다. Django에 내장된 이용자 모델은 <code class="highlighter-rouge">django.contrib.auth.models</code>에 <code class="highlighter-rouge">User</code> 모델 클래스입니다. 이 이용자 모델엔 모델 필드이 간결하게 담겨 있습니다.</p>

<ul>
  <li><code class="highlighter-rouge">username</code> : 이용자 ID 역할. 다른 값과 중복되지 않는 고유한 값만 허용합니다(<code class="highlighter-rouge">unique=True</code>).</li>
  <li><code class="highlighter-rouge">password</code> : 비밀번호. <code class="highlighter-rouge">PasswordField</code> 모델 필드.</li>
  <li><code class="highlighter-rouge">first_name</code> : 성씨. <code class="highlighter-rouge">CharField</code> 모델 필드이며 생략 가능.</li>
  <li><code class="highlighter-rouge">last_name</code> : 이름. <code class="highlighter-rouge">CharField</code> 모델 필드이며 생략 가능.</li>
  <li><code class="highlighter-rouge">email</code> : 전자우편 주소. <code class="highlighter-rouge">EmailField</code> 모델 필드.</li>
  <li><code class="highlighter-rouge">is_staff</code> : 관리자 여부. <code class="highlighter-rouge">BooleanField</code> 모델 필드.</li>
  <li><code class="highlighter-rouge">is_active</code> : 활성화 된 계정인지 여부. <code class="highlighter-rouge">BooleanField</code> 모델 필드.</li>
</ul>

<p>이외에도 <code class="highlighter-rouge">is_superuser</code>나 <code class="highlighter-rouge">groups</code> 같은 모델 필드 몇 가지가 더 있지만, 이 모델 필드의 값을 직접 다룰 일은 드물고, 이 강좌 내용을 이해하시면 이런 모델 필드를 직접 찾아 다루는 건 어렵지 않으므로 이 강좌에선 다루지 않겠습니다.</p>

<p>만약, 필명이나 사용하는 언어, 거주 지역처럼 정보를 추가로 이용자로부터 입력 받아 관리하려면 이용자 모델 클래스를 <strong>확장</strong>해야 합니다. Django에서 제공하는 이용자 모델을 변경해도 되지만, Django 소스 파일을 직접 고쳐서 쓰지 않는 게 좋습니다. Django 판을 올릴 때마다 직접 수정한 부분을 매번 챙겨야 하고, 연계되어 동작하는 다른 기능에 부작용을 일으킬 여지도 있습니다. 그래서 변경하지 않고 <strong>확장</strong>해야 합니다.</p>

<p>확장하는 자세한 방법은 다른 편에서 따로 다루기로 하고<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>, 여기에선 확장 방법 종류만 간단히 언급하겠습니다.</p>

<ol>
  <li>따로 이용자 모델을 만들고, Django의 이용자 모델에 연결(Model relationship).</li>
  <li>이용자 모델과 모델 매니저, 이용자 폼 등을 모두 구현하여 이용자 모델 부분을 대체.</li>
</ol>

<p>2번 방법에서 “모델 부분을 대체”한다는 표현을 눈 여겨 보세요. 일일이 Django 소스에서 이용자 모델 관련 부분, 가령, <code class="highlighter-rouge">django.contrib.auth.models.User</code>를 <code class="highlighter-rouge">pystagram_auth.models.User</code>와 같이 교체하는 건 아닙니다. <code class="highlighter-rouge">settings</code>의 <code class="highlighter-rouge">AUTH_USER_MODEL</code> 항목에 지정하기만 하면 됩니다.</p>

<p>이 항목 역시 우리가 따로 설정한 적이 없는데, Django의 <code class="highlighter-rouge">global_settings</code>에 설정되어 있으며, 기본 값으로 <code class="highlighter-rouge">'auth.User'</code> 문자열이 할당되어 있습니다. <code class="highlighter-rouge">auth</code>는 Django 앱 이름(Python 패키지)이고, <code class="highlighter-rouge">User</code>는 모델 클래스 이름입니다. Python 이름영역(name space)으로 풀어 쓰면 <code class="highlighter-rouge">auth.models.User</code>인 셈입니다.</p>

<p><code class="highlighter-rouge">settings</code>의 <code class="highlighter-rouge">AUTH_USER_MODEL</code> 설정 항목을 참조하여 이용자 모델을 실제로 가져오는 역할은 <code class="highlighter-rouge">get_user_model()</code> 함수가 맡으며, <code class="highlighter-rouge">django.contrib.auth</code>에 있습니다. 이 함수를 이용하면 이용자 모델이 어떤 것으로 바뀌든 코드를 일관되게 유지하게 됩니다. <code class="highlighter-rouge">AUTH_USER_MODEL = 'auth.User'</code>라고 설정하고 <code class="highlighter-rouge">get_user_model()</code> 함수를 실행하면 <code class="highlighter-rouge">auth.models.User</code>를 반환하고, <code class="highlighter-rouge">AUTH_USER_MODEL = 'pystagram_auth.MyUser'</code>로 설정하고 실행하면 <code class="highlighter-rouge">pystagram_auth.models.MyUser</code>를 이용자 모델로 반환합니다. 그러므로 <code class="highlighter-rouge">get_user_model()</code> 함수로 이용자 모델을 가져오는 게 좋습니다.</p>

<p>인증 체계 기반(backend)과는 달리 기본 이용자 모델은 하나만 가능합니다.</p>

<h4 id="4-정리하면">(4) 정리하면</h4>

<p>로그인 과정을 정리하면 다음과 같습니다.</p>

<ul>
  <li><code class="highlighter-rouge">django.contrib.auth.views.login</code>
    <ul>
      <li><code class="highlighter-rouge">django.contrib.auth.forms.AuthenticationForm</code>
        <ul>
          <li><code class="highlighter-rouge">django.contrib.auth.authenticate()</code>
            <ul>
              <li><code class="highlighter-rouge">settings.AUTHENTICATION_BACKENDS</code>에서 인증 기반 하나씩 가져옴</li>
              <li><code class="highlighter-rouge">django.contrib.auth.backends.ModelBackend</code>의 <code class="highlighter-rouge">authenticate()</code> 메서드로 인증 처리</li>
            </ul>
          </li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">django.contrib.auth.auth_login</code> (정확히는 <code class="highlighter-rouge">django.contrib.auth.login</code>를 <code class="highlighter-rouge">auth_login</code>으로 import 한 것.)으로 인증 관련 세션 처리</li>
    </ul>
  </li>
  <li>로그인 이후 이동할 URL로 이동 처리(redirect)</li>
</ul>

<h3 id="4-로그인-관련-설정-항목">4. 로그인 관련 설정 항목</h3>

<p><code class="highlighter-rouge">settings.py</code>에 설정하는 로그인 관련 항목이 몇 가지 있습니다.</p>

<h4 id="1-login_url">(1) <code class="highlighter-rouge">LOGIN_URL</code></h4>

<p><code class="highlighter-rouge">LOGIN_URL</code>은 로그인 URL을 뜻합니다. Django에서 제공하는 장식자(decorator) 중 <code class="highlighter-rouge">login_required</code>는 뷰 함수에 접근할 때 로그인 여부를 검사하고, 로그인하지 않으면 로그인 URL로 이용자를 이동시키는데, 이 로그인 URL을 <code class="highlighter-rouge">settings.LOGIN_URL</code>에서 가져 옵니다. <code class="highlighter-rouge">global_settings</code>에 설정된 기본값은 <code class="highlighter-rouge">/accounts/login/</code>입니다. 로그인 URL을 다른 것으로 쓴다면 이 항목에 URL을 지정하면 제3자(3rd party) 도구 등에서 참조합니다.</p>

<h4 id="2-logout_url">(2) <code class="highlighter-rouge">LOGOUT_URL</code></h4>

<p><code class="highlighter-rouge">LOGIN_URL</code>과 비슷한 역할을 합니다. 기본값은 <code class="highlighter-rouge">/accounts/logout/</code>입니다. 그런데 사용할 일은 거의 없어서 사실상 죽은 설정 항목이나 마찬가지입니다. 이런 게 있다는 정도로 알아 두시면 됩니다.</p>

<h4 id="3-login_redirect_url">(3) <code class="highlighter-rouge">LOGIN_REDIRECT_URL</code></h4>

<p>로그인을 하고 나서 이동할 URL을 설정합니다. 로그인 하고나서 이동할 URL이 지정된 경우 그 URL로 이동하지만, 이동할 URL이 지정되지 않았거나 지정한 URL이 보안상 문제가 있는 경우 <code class="highlighter-rouge">settings.LOGIN_REDIRECT_URL</code>를 사용합니다.</p>

<p>현재 구현한 기능으로는 로그인을 마치면 “Page not found” 오류를 만납니다.</p>

<p><img src="http://blog.hannal.com/assets/uploads/2015/06/08-404_after_login.png" alt="" /></p>

<p>웹 브라우저 주소입력란을 잘 보면 <code class="highlighter-rouge">http://localhost:8000/accounts/profile/</code>과 같이 전혀 본 적 없는 URL로 되어 있습니다. 이는 Django 기본 <code class="highlighter-rouge">LOGIN_REDIRECT_URL</code> 설정값이 <code class="highlighter-rouge">/accounts/profile/</code>이라서 그렇습니다. 아직 우리는 프로필 페이지를 만들지 않았으니 임시로 <code class="highlighter-rouge">/photos/upload/</code>로 이동하도록 설정하겠습니다. 시작패키지에서 <code class="highlighter-rouge">settings.py</code> 파일을 열고 다음 코드를 추가합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>LOGIN_REDIRECT_URL = '/photos/upload/'
</code></pre></div></div>

<p>이제 로그인을 마치면 <code class="highlighter-rouge">/photos/upload/</code>로 이동하여 사진을 올리라는 압박을 줍니다.</p>

<hr />

<p>강좌 8편을 마칩니다.</p>

<ul>
  <li><a href="https://github.com/hannal/start_with_django_webframework/tree/l08">8편까지 진행한 전체 소스 코드</a></li>
</ul>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>다른 편에서 다루겠다는 내용이 늘어가니 불안해지네요. 까먹고 다루지 않을까봐요. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>
  <hr class="post-parting-line" />
  
  <div class="post">
    <h2 class="post-title">
      <a href="/2015/05/start_with_django_webframework_07/">
        7. 사진 게시물 제출하여 게시하기
      </a>
    </h2>

    <span class="post-date">18 May 2015</span>

    <ul>
  <li><a href="http://blog.hannal.com/category/start-with-django-webframework/">날로 먹는 Django 웹프레임워크 강좌 목차</a></li>
  <li>마지막 갱신일시 : 2017년 1월 29일 23시 40분</li>
</ul>

<p>그동안 우리는 사진 게시물을 Django Admin에서 게시했습니다. 이번엔 사진 게시물을 게시하는 기능을 구현하겠습니다. Django Form을 이용할 것인데, 이번 편에서는 왜 Django Form을 쓰면 좋고, 어떻게 동작하는 지 흐름을 이해하는 내용을 다루겠습니다.</p>

<h3 id="1-django-form">1. Django Form</h3>

<p>Django Form은 Django의 주요 매력 요소 중 하나라 생각합니다. <a href="http://blog.hannal.com/2014/9/start_with_django_webframework_03/">Django는 MTV 패턴을 따른다</a>고 하는데, Django Model과 Form을 활용하면 반복되는 처리를 Django가 대신 하고 이용자는 데이터(model)와 표현물(template)에 집중하게 됩니다.</p>

<p>Form은 이름에서 드러나듯이 입력 양식(form)을 다루는 기능입니다. “입력 양식”이란 Django가 웹 프레임워크이니 웹 입력 양식을 뜻합니다. Django Form은 HTML로 만든 웹 화면의 form 태그에서 서버로 전달된 항목이 유효한 지 검증(validation)할 뿐만 아니라 웹 입력 항목에 필요한 HTML 태그를 생성해 출력합니다. 유효하지 않은 항목이 있으면 어떻게 유효하지 않은 지 안내말을 출력하기도 합니다.</p>

<p>유효성은 꼼꼼하게 검사(validation)해야 합니다. 보안 측면에서 클라이언트(서비스 이용자)가 서버로 보내오는 데이터는 그다지 신뢰해서는 안 됩니다. 우리 서비스를 위태롭게 할 코드가 숨겨져 있을지도 모릅니다. 운영 측면에서도 이용자가 system이나 admin과 같이 운영자를 사칭하는 계정 이름을 짓거나 화면을 망가뜨리거나 다른 이용자의 권한을 가로채는 서비스 앞단(front-end)용 코드를 심을지도 모릅니다.</p>

<p>보안성을 높이려면 마냥 뚫고 들어오지 못 하게 폐쇄하기만 할 게 아니라 개방할 필요도 있습니다. 개발자 또는 개발팀이 아무리 뛰어난 능력을 가졌어도 갈수록 증가하는 소프트웨어 복잡성에서 발생하는 수많은 경우와 상황에 대응하는 건 불가능합니다. 또한 서비스에 구현된 모든 기능을 완전히 직접 구현하여 제공하는 것이 아닌 이상 우리가 만드는 소프트웨어는 다른 소프트웨어나 도구와 연결되는데, <a href="http://blog.dahlia.kr/post/82482810330">우리가 만든 소프트웨어의 바깥 환경이 변하면서 우리가 만든 소프트웨어도 녹슬어</a> 끊임없이 새로운 문제에 부딪히게 됩니다. 이 문제는 폐쇄하여 감출 게 아니라 오히려 개방하여 더 드러내서 많은 사람이 문제를 발견하는 게 낫습니다. Django는 오픈소스 프로젝트이며, 많은 개발자가 참여하고 기여하고 사용합니다. Django처럼 애용되고 활성화 된 오픈소스 프로젝트는 사람이 유발하는 보안 구멍을 주시하는 눈이 많아서 우리가 직접 구현하는 것보다 더 신뢰할 만하다고 생각합니다. 우리의 능력이 뛰어나든 그렇지 않든 말이지요.</p>

<p>운영 측면에서 대응해야 할 대응은 반복되는 처리가 많습니다. 예를 들어, 숫자만 입력받을 항목에 숫자 외 다른 글자가 입력되었는지 검사하고 들어 있으면 예외 처리하거나 첨부한 이미지 파일이 제대로 된 파일인지 검사하는 처리는 항목 개수만큼이나 반복되는 과정입니다. 이를 일일이 코드로 검사한다면 실수할 가능성이 큽니다. 일관성과 관리 차원에서 그러한 역할을 하는 검사기(validator)를 만들어 처리하는 게 좋습니다.</p>

<p>이렇게 클라이언트로부터 전송받은 데이터가 유효한지 검사하고 걸러내는 역할을 Django Form가 합니다. Django Form을 사용하면 상당히 다양한 입력 형식에 대해 수 년에 걸쳐 쌓인 경험으로 유효성을 검사합니다. 가령, Django Form의 <code class="highlighter-rouge">EmailField</code> 폼 필드를 사용하면, 다국어나 <code class="highlighter-rouge">.wiki</code>나 <code class="highlighter-rouge">.google</code>과 같은 새로운 최상위 도메인(Top-level domain), 심지어 IPv4나 IPv6와 같이 IP주소로 구성된 전자우편 주소에 대응 가능합니다.</p>

<p>물론 어디까지나 유효성을 검사하는 것이므로 제가 앞서 언급한 보안성에 대해 무결하지는 않습니다. 예를 들어, Django Form의 <code class="highlighter-rouge">ImageField</code> 폼 필드는 클라이언트가 제출한 파일이 <a href="https://github.com/django/django/blob/1.8.1/django/forms/fields.py#L691">이미지 파일로 유효한지 확인하는 방법을 Image Library인 PIL이나 Pillow의 <code class="highlighter-rouge">verify()</code>에 의존</a>합니다. <code class="highlighter-rouge">verify()</code> 메서드는 파일의 헤더 영역을 읽어 들여서 유효한 파일인지 검사할 뿐입니다. 그 마저도 일부 파일에 대해서만 제공하여, <a href="https://github.com/python-pillow/Pillow/blob/master/PIL/GifImagePlugin.py">GIF 파일</a>을 처리하는 모듈엔 <code class="highlighter-rouge">verify()</code>가 아예 없습니다. GIF, PNG, Jpeg과 같은 이미지 파일은 일반 문자열을 담는 Metadata 영역(chunk)을 지원하는데, 이 요소를 악용하여 보안을 위협하는 코드를 삽입하여 서버나 클라이언트(방문자)에게 해를 끼칠 가능성이 있습니다<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>.</p>

<p>하지만, 이는 Django Form이 보안에 초점을 맞춘 기능은 아니니 보안 대응용으로 Django Form에 의존하지 않아야 한다는 의미이며, 입력 항목이 유효한 지에 대한 필수 검사 요소는 갖추고 있으므로 Django Form을 가장 기본으로 사용하고 보안에 필요한 조치를 추가하는 것이 나을 것입니다.</p>

<h4 id="form과-modelform">Form과 ModelForm</h4>

<p>Django Form은 <code class="highlighter-rouge">django.forms</code> 모듈에서 <code class="highlighter-rouge">Form</code>과 <code class="highlighter-rouge">ModelForm</code> 클래스로 제공됩니다. <code class="highlighter-rouge">Form</code>은 앞서 설명한 내용을 그대로 담고 있는 클래스입니다. <code class="highlighter-rouge">ModelForm</code>은 Django Model과 연계한 Form 클래스입니다. Django Model을 사용한다면 <code class="highlighter-rouge">ModelForm</code>을 이용하여 입력 양식과 입력 항목 검증, 그리고 검증된 입력 데이터를 데이터베이스에 저장하는 과정을 편하게 처리합니다.</p>

<p>자세한 건 코드로 구현하면서 다루겠습니다.</p>

<h3 id="2-사진-게시물을-form을-이용하여-게시하기">2. 사진 게시물을 Form을 이용하여 게시하기</h3>

<h4 id="form-만들기">Form 만들기</h4>

<p><code class="highlighter-rouge">photos</code> 디렉터리에 <code class="highlighter-rouge">forms.py</code> 파일을 만듭니다. 앞으로 <code class="highlighter-rouge">photos</code> 앱에서 사용하는 Form은 이 모듈에 만듭니다. 이제 사진 게시물을 편집하는(생성하거나 수정) 폼을 <code class="highlighter-rouge">PhotoForm</code>이라는 이름으로 만듭니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">from</span> <span class="n">__future__</span> <span class="n">import</span> <span class="n">unicode_literals</span>

<span class="k">from</span> <span class="n">django</span> <span class="n">import</span> <span class="n">forms</span>

<span class="k">from</span> <span class="p">.</span><span class="n">models</span> <span class="n">import</span> <span class="n">Photo</span>


<span class="n">class</span> <span class="n">PhotoForm</span><span class="p">(</span><span class="n">forms</span><span class="p">.</span><span class="n">ModelForm</span><span class="p">):</span>
    <span class="n">class</span> <span class="n">Meta</span><span class="p">:</span>
        <span class="k">model</span> <span class="p">=</span> <span class="n">Photo</span>
        <span class="n">fields</span> <span class="p">=</span> <span class="p">(</span><span class="s1">'image'</span><span class="p">,</span> <span class="s1">'content'</span><span class="p">,</span> <span class="p">)</span>
</code></pre></div></div>

<p>아주 간결한 코드입니다. <code class="highlighter-rouge">forms</code> 모듈에 있는 <code class="highlighter-rouge">ModelForm</code> 클래스를 상속받는 <code class="highlighter-rouge">PhotoForm</code> 클래스를 만들면 이 클래스는 Form 클래스입니다. <code class="highlighter-rouge">ModelForm</code>이므로 클래스 안에 <code class="highlighter-rouge">Meta</code> 클래스를 또 만들고, 그 안에 <code class="highlighter-rouge"><span class="k">model</span> <span class="p">=</span> <span class="n">Photo</span></code>라는 코드로 이 Model form에 연계하는 Model을 <code class="highlighter-rouge">Photo</code>로 지정한 것입니다. 이 <code class="highlighter-rouge">Photo</code> 모델 클래스는 <code class="highlighter-rouge">photos</code> 앱 디렉터리의 <code class="highlighter-rouge">models.py</code> 모듈에 있으니 <code class="highlighter-rouge">from .models import Photo</code>로 읽어 들인 것입니다. <code class="highlighter-rouge">Meta</code> 클래스의 <code class="highlighter-rouge">fields</code> 속성은 폼에 사용할 모델의 모델 필드를 지정하는 데 사용합니다. <code class="highlighter-rouge">fields = ('image', 'content', )</code> 이 코드는 <code class="highlighter-rouge">Photo</code> 모델의 <code class="highlighter-rouge">image</code>와 <code class="highlighter-rouge">content</code> 모델 필드를 폼 필드로 만드는 설정인 셈입니다.</p>

<p><code class="highlighter-rouge">ModelForm</code>은 Form에 연결한 Model의 모델 필드를 기반으로 폼 필드를 만듭니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Photo(models.Model):
    image = models.ImageField(upload_to='%Y/%m/%d/orig')
    filtered_image = models.ImageField(upload_to='%Y/%m/%d/filtered')
    content = models.TextField(max_length=500, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
</code></pre></div></div>

<p><code class="highlighter-rouge">Photo</code> 모델이 이와 같은 모델 필드로 구성되어 있으니 <code class="highlighter-rouge">PhotoForm</code>을 일반 <code class="highlighter-rouge">Form</code> 클래스를 상속받아 만든다면 다음과 같이 만드는 셈입니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class PhotoForm(forms.Form):
    image = forms.ImageField()
    filtered_image = forms.ImageField()
    content = forms.CharField(
        max_length=500,
        required=False,
        widget=forms.Textarea
    )
    created_at = forms.DateTimeField(required=False)
</code></pre></div></div>

<p>Model과 비슷하게 생겼습니다. 웹페이지에 사용할 HTML도 거의 비슷합니다.</p>

<p>Model은 데이터베이스와 연관되어 있어서 모델 필드형(type)이 데이터베이스의 컬럼(column)형(type)에 맞추어져 있고, Form은 웹 입력 양식인 form 관련 태그의 종류에 맞추어져 소소한 차이가 있지만, 결국 웹에서 넘겨받은 데이터를 데이터베이스에 넣는 것이라 서로 비슷한 인터페이스를 갖습니다. <code class="highlighter-rouge">ModelForm</code>을 쓰면 모델 필드와 폼 필드 간 차이 마저도 별로 의식하지 않습니다. 그래서 Model을 잘 만들고 <code class="highlighter-rouge">ModelForm</code>을 이용하여 Model form을 만들면 우리는 데이터 유효성을 검사하고 이를 데이터베이스에 넣거나 찾아 쓰는 데이터 관리와 처리를 날로 먹게 됩니다.</p>

<h4 id="사진-게시물-작성-화면-만들기">사진 게시물 작성 화면 만들기</h4>

<p>사진 게시물을 게시하려면 사진 파일을 선택하고, 사진을 설명하는 본문 등 사진 게시물에 필요한 사항을 입력해야 합니다. 본 강좌 중 <a href="http://blog.hannal.com/2014/8/start_with_django_webframework_01/">Pystagram 기획</a>편에서 사진 게시물을 작성하고 게시하는 URL을 <code class="highlighter-rouge">/photos/upload/</code>로 하기로 했으니 <code class="highlighter-rouge">urls.py</code>에 이 주소 패턴을 등록합니다. 시작 패키지(<code class="highlighter-rouge">settings.py</code> 파일이 있는 디렉터리)에 있는 <code class="highlighter-rouge">urls.py</code> 파일을 열고 다음 URL 패턴을 추가합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 생략 
from photos.views import hello
from photos.views import detail
from photos.views import create  # 이 줄 추가


urlpatterns = [
    url(r'^hello/$', hello),
    url(r'^photos/(?P&lt;pk&gt;[0-9]+)/$', detail, name='detail'),
    url(r'^photos/upload/$', create, name='create'),  # 이 줄 추가
    url(r'^admin/', admin.site.urls),
]
# 생략
</code></pre></div></div>

<p><code class="highlighter-rouge">/photos/upload/</code> URL에 <code class="highlighter-rouge">photos</code> 앱 디렉터리에 있는 <code class="highlighter-rouge">views.py</code> 모듈의 <code class="highlighter-rouge">create</code> 뷰 함수를 연결(mapping)한 것입니다.</p>

<p>이번엔 <code class="highlighter-rouge">views.py</code> 파일에 <code class="highlighter-rouge">create</code> 뷰 함수를 만듭니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># 생략
from .forms import PhotoForm


def create(request):
    form = PhotoForm()
    ctx = {
        'form': form,
    }
    return render(request, 'edit.html', ctx)
</code></pre></div></div>

<p><code class="highlighter-rouge">edit.html</code> 템플릿 파일에 템플릿 맥락 요소(Context)로 앞서 만든 <code class="highlighter-rouge">PhotoForm</code> 클래스 객체를 전달하는데, 폼 클래스 자체가 아니라 폼 클래스를 인스턴스 객체로 생성하여 <code class="highlighter-rouge">form</code>에 할당하고, 이 <code class="highlighter-rouge">form</code>을 전달합니다.</p>

<p><code class="highlighter-rouge">render()</code> 함수는 <a href="http://blog.hannal.com/2014/11/start_with_django_webframework_05/">5. url에 view 함수 연결해서 사진 출력하기</a> 편에서 역할을 설명했고, 이번 편에서 처음 사용합니다. 이 함수는 대개 세 가지 인자를 필요로 합니다.</p>

<ul>
  <li><code class="highlighter-rouge">request</code></li>
  <li>템플릿 파일 이름</li>
  <li>사전형(<code class="highlighter-rouge">dict</code>) 객체로 전달되는 템플릿 맥락 요소(context)</li>
</ul>

<p><code class="highlighter-rouge">request</code> 객체는 뷰 함수에 첫 번째 인자로 전달되는 객체입니다. <a href="https://docs.djangoproject.com/en/1.10/ref/request-response/#httprequest-objects">HTTP Request</a>를 뜻합니다. 뷰 함수는 언제나 첫 번째 인자로 <code class="highlighter-rouge">request</code> 객체를 전달 받는데, 이 객체를 <code class="highlighter-rouge">render()</code> 함수의 첫 번째 인자로 전달합니다. 템플릿에서 템플릿 맥락 요소로 <code class="highlighter-rouge">request</code> 객체를 지정하는(mapping) 데 사용됩니다. 두 번째 인자는 템플릿 파일 경로를 문자열로 지정하며, 이 인자 역시 필수 인자입니다. 마지막으로, 세 번째 인자는 템플릿 파일 안에서 사용할 템플릿 맥락 요소를 사전형(<code class="highlighter-rouge">dict</code>) 객체로 전달합니다. <code class="highlighter-rouge">{'form': form}</code>에서 <code class="highlighter-rouge">Key</code>인 <code class="highlighter-rouge">'form'</code>은 템플릿 파일 안에서 <code class="highlighter-rouge">form</code>이라는 이름으로 사용하는 템플릿 변수가 되고, <code class="highlighter-rouge">Value</code>인 <code class="highlighter-rouge">form</code>(<code class="highlighter-rouge">PhotoForm()</code>의 인스턴스 객체)가 이 템플릿 변수에 연결된(mapped) 객체인 셈이지요.</p>

<p>이번엔 템플릿 파일인 <code class="highlighter-rouge">edit.html</code>을 만듭니다. <code class="highlighter-rouge">photo</code> 디렉터리에 <code class="highlighter-rouge">templates</code> 디렉터리를 만들고, 그 안에 <code class="highlighter-rouge">edit.html</code> 파일을 만들어 다음 내용을 담습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{% extends 'layout.html' %}

{% block content %}
&lt;form
    method="POST"
    action=""
    enctype="multipart/form-data"
&gt;
    {% csrf_token %}
    {{ form.as_p }}

    &lt;p&gt;
        &lt;button type="submit"&gt;저장&lt;/button&gt;
    &lt;/p&gt;
&lt;/form&gt;

{% endblock %}
</code></pre></div></div>

<p>Django Template은 추후 연재에서 자세히 다루겠습니다. 이 <code class="highlighter-rouge">edit.html</code>는 뷰 함수에서 지정한 템플릿 파일이니 이후엔 <strong>뷰 템플릿 파일</strong>이라 부르겠습니다. 템플릿 내용 중 눈여겨 볼 점은 <code class="highlighter-rouge">{{ form.as_p }}</code> 코드입니다. <code class="highlighter-rouge">form</code>은 <code class="highlighter-rouge">create</code> 뷰 함수가 <code class="highlighter-rouge">form</code> 폼 객체를 <code class="highlighter-rouge">form</code>이라는 템플릿 변수로 지정해 전달한 것입니다. 이 객체의 인스턴스 메서드인 <code class="highlighter-rouge">as_p()</code>를 호출하면 각 폼 필드를 HTML 태그인 <code class="highlighter-rouge">&lt;p&gt;&lt;/p&gt;</code>(paragraph, 문단 태그)로 감싸서 출력합니다. 실제로 출력되는 HTML 코드는 다음과 같습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;p&gt;&lt;label for="id_image"&gt;Image file:&lt;/label&gt; &lt;input id="id_image" name="image" type="file" /&gt;&lt;/p&gt;

&lt;p&gt;&lt;label for="id_content"&gt;Content:&lt;/label&gt; &lt;textarea cols="40" id="id_content" maxlength="500" name="content" rows="10"&gt;
&lt;/textarea&gt;&lt;/p&gt;
</code></pre></div></div>

<p><code class="highlighter-rouge">Photo</code> 모델에 있는 모델 필드 중 두 개가 HTML form 입력항목 태그로 표현 되었습니다. <code class="highlighter-rouge">created_at</code>은 없는데, 날짜나 시간 관련 모델 필드(<code class="highlighter-rouge">DateTimeField</code>, <code class="highlighter-rouge">DateField</code>, <code class="highlighter-rouge">TimeField</code>)에 <code class="highlighter-rouge">auto_now_add</code>나 <code class="highlighter-rouge">auto_now</code> 필드 옵션 중 하나라도 <code class="highlighter-rouge">True</code>로 지정되면 Model form으로 폼 필드를 만들 때 기본 입력 항목으로 지정되지 않고, 그래서 HTML 태그로도 만들어 내지 않습니다.</p>

<p><code class="highlighter-rouge">{% csrf_token %}</code>는 <a href="https://goo.gl/Bw90sV">CSRF(Cross Site Request Forgery)</a> 토큰을 만드는 템플릿 태그입니다. Django로 만든 웹 페이지에 접속하면 각 세션을 기반으로 CSRF 토큰을 만들며, 이 토큰이 조작되거나 존재하지 않으면 Form 데이터를 Django로 동작하는 웹 애플리케이션 서버에 보내지 못합니다<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>. CSRF 토큰 검사를 하지 않도록 하면 되지만, 보안 상 좋지 않으니 HTML 폼 영역에 CSRF 토큰을 생성하도록 <code class="highlighter-rouge">{% csrf_token %}</code>을 습관처럼 넣길 권합니다. 빠뜨리면 CSRF 검증을 실패하였다는 오류가 발생합니다.</p>

<p>뷰 템플릿 파일인 <code class="highlighter-rouge">edit.html</code>는 레이아웃 구조를 잡는 역할을 하는 <code class="highlighter-rouge">layout.html</code> 템플릿 파일로 확장하므로(<code class="highlighter-rouge">{% extends 'layout.html' %}</code>) 이 <code class="highlighter-rouge">layout.html</code> 파일도 만들어야 합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{% load staticfiles %}

<span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"ko"</span><span class="nt">&gt;</span>

<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;title&gt;</span>{% block page_title %}Pystagram{% endblock %}<span class="nt">&lt;/title&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"{% static 'js/jquery-2.1.3.min.js' %}"</span><span class="nt">&gt;&lt;/script&gt;</span>
<span class="nt">&lt;/head&gt;</span>

<span class="nt">&lt;body&gt;</span>
{% block content %}{% endblock %}
<span class="nt">&lt;/body&gt;</span>

<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>지난 6회 연재 글에서 다룬 정적(static) 파일 내용이 얼핏 보이네요. 이것도 Django Template을 다루는 연재 글에서 자세히 다루겠습니다.</p>

<p>이제 Django의 개발용 내장 웹 서버를 구동하고(<code class="highlighter-rouge">python manage.py runserver</code>) <code class="highlighter-rouge">/photo/upload/</code> URL로 접속하면 사진 게시물을 작성하는 편집 화면이 나옵니다. <code class="highlighter-rouge">filtered_image</code>은 이미지 필터를 적용하여 가공된 이미지 파일을 담는 모델 필드입니다. 다시 말하면 사진 게시물을 편집하는 단계에서 이용자가 접근해서는 안 되는 필드입니다. 그래서 화면에 나타나지 않게 감추었습니다. 앞서 모델폼을 만들 때 <code class="highlighter-rouge">fields</code> 속성에서 누락한 탓입니다.</p>

<p><code class="highlighter-rouge">fields</code>는 폼에서 사용할 모델 필드를 지정하는 데 사용하며, 모델 필드 이름을 문자열로 리스트(<code class="highlighter-rouge">list</code>)나 튜플(<code class="highlighter-rouge">tuple</code>) 객체에 나열해 담으면 됩니다. 그런데 폼 필드로 사용하지 않을 모델 필드는 <code class="highlighter-rouge">filtered_image</code> 하나이고, 사용할 모델 필드는 221개쯤 있다고 가정하겠습니다. 고작 하나를 사용하지 않으려고 221개 모델 필드 이름을 나열하면 무척 고통스럽습니다. 이런 경우는 사용하지 않을 모델 필드만 지정해야 편한데, <code class="highlighter-rouge">exclude</code>에 지정하면 됩니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">class</span> <span class="n">PhotoForm</span><span class="p">(</span><span class="n">forms</span><span class="p">.</span><span class="n">ModelForm</span><span class="p">):</span>
    <span class="n">class</span> <span class="n">Meta</span><span class="p">:</span>
        <span class="k">model</span> <span class="p">=</span> <span class="n">Photo</span>
        <span class="n">exclude</span> <span class="p">=</span> <span class="p">(</span><span class="s1">'filtered_image'</span><span class="p">,</span> <span class="p">)</span>
</code></pre></div></div>

<p>이 코드에서 유의할 점은 <code class="highlighter-rouge">exclude</code> 역시 리스트나 튜플 객체를 할당해야 하므로 <code class="highlighter-rouge">'filtered_image'</code> 뒤에 쉼표 하나 더 찍어줘야 합니다<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>.</p>

<p><code class="highlighter-rouge">photos</code> 앱 디렉터리에 <code class="highlighter-rouge">templates</code> 디렉터리를 만들고 그곳에 템플릿 파일을 담으면 Django가 알아서 앱 디렉터리에 있는 템플릿 파일을 가져옵니다. 이 동작은 <code class="highlighter-rouge">settings.py</code>에 따로 설정되어 있어서 그렇습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates'), ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
</code></pre></div></div>

<p><code class="highlighter-rouge">settings.py</code>의 <code class="highlighter-rouge">TEMPLATES</code> 항목을 보면 <code class="highlighter-rouge">'APP_DIRS': True,</code> 코드가 있는데, 이 부분이 바로 Django 앱 별로 템플릿 파일을 다루도록 할 것인지 여부를 지정한 것이며 앱 안에 위치하는 템플릿 디렉터리 이름은 <code class="highlighter-rouge">templates</code>로 고정되어 있습니다. <code class="highlighter-rouge">False</code>로 바꾸면 앱 디렉터리에 있는 템플릿 파일을 다루지 않습니다.</p>

<h4 id="사진-게시물-게시하기">사진 게시물 게시하기</h4>

<p>우리는 사진 게시물 내용을 작성하는 URL과 사진 게시물을 제출하여 게시하는 URL을 같이 쓰겠습니다. 즉, <code class="highlighter-rouge">/photo/upload/</code>에 HTTP Get 방식으로 접근하면 사진 게시물을 작성하는 화면이 나오고, POST 방식으로 접근하면 게시물을 제출합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from django.shortcuts import redirect


def create(request):
    if request.method == "GET":
        form = PhotoForm()
    elif request.method == "POST":
        form = PhotoForm(request.POST, request.FILES)

        if form.is_valid():
            obj = form.save()
            return redirect(obj)

    ctx = {
        'form': form,
    }

    return render(request, 'edit.html', ctx)
</code></pre></div></div>

<p><code class="highlighter-rouge">request.method</code>가 <code class="highlighter-rouge">GET</code>인 경우는 기존 코드를 그대로 사용하면 됩니다. <code class="highlighter-rouge">POST</code> 방식, 즉, 게시물 내용과 파일을 제출 받는 부분을 추가했습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PhotoForm(request.POST, request.FILES)
</code></pre></div></div>

<p><code class="highlighter-rouge">PhotoForm</code> 폼에 첫 번째 인자로 <code class="highlighter-rouge">request.POST</code>를, 두 번째 인자로 <code class="highlighter-rouge">request.FILES</code>를 전달합니다. 첫 번째 인자는 폼에서 다룰 데이터를 뜻하며, 사전형(<code class="highlighter-rouge">dict</code>) 객체나 사전형 객체처럼 동작하는(비슷한 인터페이스를 제공하는) 객체<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup>여야 합니다. 파일을 제외한 HTML Form에서 <code class="highlighter-rouge">POST</code> 방식으로 전송해온 모든 formdata 데이터가 <code class="highlighter-rouge">request.POST</code>에 있습니다. 파일은 <code class="highlighter-rouge">request.FILES</code>에 있습니다. 그래서, 이 둘을 분리하여 첫 번째 인자, 두 번째 인자로 전달한 것입니다.</p>

<p>여기까지는 폼에서 처리할 데이터를 인자로 전달하여 설정한 것일 뿐이므로, <code class="highlighter-rouge">form = PhotoForm()</code>와 다를 바 없습니다. 그렇다고 해서 다음과 같이 코드를 작성해서는 안 됩니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    form = PhotoForm()
    if request.method == "POST":
        form.data = request.POST
        form.files = request.FILES

        if form.is_valid():
            obj = form.save()
</code></pre></div></div>

<p>Django Form은 첫 번째 인자로 넘어온 데이터는 <code class="highlighter-rouge">data</code> 멤버에, 파일은 <code class="highlighter-rouge">files</code> 멤버에 할당하는 걸 이용한 것인데, Form 클래스로 인스턴스 객체를 생성해 할당하는 과정에서(<code class="highlighter-rouge">__init__()</code>) 인자로 전달된 데이터나 파일이 있으면 <code class="highlighter-rouge">is_bound</code>라는 멤버에 <code class="highlighter-rouge">True</code>가 할당되고, 이 <code class="highlighter-rouge">is_bound</code>가 <code class="highlighter-rouge">True</code>여야만 <code class="highlighter-rouge">is_valid()</code>를 비롯한 폼 검사를 수행하기 때문입니다. 물론,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    if request.method == "POST":
        form.is_bound = True
        form.data = request.POST
        form.files = request.FILES
</code></pre></div></div>

<p>이렇게 <code class="highlighter-rouge">is_bound</code>를 직접 <code class="highlighter-rouge">True</code>로 할당하면 되지만, <code class="highlighter-rouge">form = PhotoForm(request.POST, request.FILES)</code>라고 코드를 짜면 그만인 것을 굳이 저렇게 짤 필요는 없습니다.</p>

<p>폼에 검사할 데이터를 전달하여 초기화하여 인스턴스 객체(<code class="highlighter-rouge">form</code>)에는 전달된 데이터를 검사하는 몇 가지 인스턴스 메서드를 제공합니다. <code class="highlighter-rouge">full_clean()</code>나 <code class="highlighter-rouge">clean()</code> 메서드가 폼 데이터를 검사하는 데 사용하는 메서드인데, 실제로는 <code class="highlighter-rouge">is_valid()</code> 메서드를 사용하면 됩니다. <code class="highlighter-rouge">is_valid()</code> 메서드는 폼에 전달된 데이터를 폼 필드를 기준으로 검사하여 모든 데이터가 유효하면 <code class="highlighter-rouge">True</code>를, 하나라도 유효하지 않은 항목이 있으면 <code class="highlighter-rouge">False</code>를 반환합니다. 동작은 다음과 같습니다.</p>

<ol>
  <li><code class="highlighter-rouge">is_valid()</code> : 폼 검사와 관련된 오류(error)가 있는 지 검사.</li>
  <li><code class="highlighter-rouge">full_clean()</code> : <code class="highlighter-rouge">_clean_fields()</code>, <code class="highlighter-rouge">_clean_form()</code>, <code class="highlighter-rouge">_post_clean()</code> 메서드를 차례대로 수행하여 폼 데이터 유효성을 검사.</li>
  <li>최종 : <code class="highlighter-rouge">is_valid()</code>는 오류(errors)가 없으면 <code class="highlighter-rouge">True</code>를 반환하고, 있으면 데이터가 유효하지 않아 <code class="highlighter-rouge">False</code>를 반환하며, 어떤 항목에 문제가 유효하지 않은 지 여부는 폼 인스턴스 객체의 <code class="highlighter-rouge">errors</code> 멤버(프로퍼티)에 사전형 객체처럼 생긴 <code class="highlighter-rouge">ErrorDict</code>의 인스턴스 객체로 할당.</li>
</ol>

<p>데이터가 모두 유효하면 <code class="highlighter-rouge">PhotoForm</code> 폼의 인스턴스 객체인 <code class="highlighter-rouge">form</code>의 <code class="highlighter-rouge">save()</code> 메서드를 실행하고, 이 메서드는 연결된 모델을 이용하여 데이터를 저장합니다. <code class="highlighter-rouge">save()</code> 메서드는 <code class="highlighter-rouge">ModelForm</code> 클래스에 있는 메서드인데, 모델 폼에 연결한 모델을 이용하여 데이터를 저장하고 저장한 모델의 인스턴스 객체를 반환합니다. <code class="highlighter-rouge">PhotoForm</code>에 <code class="highlighter-rouge">Photo</code> 모델을 연결하였으므로 <code class="highlighter-rouge">Photo</code> 모델로 생성한 인스턴스 객체를 반환하는 셈이지요.</p>

<p><code class="highlighter-rouge">return redirect(obj)</code> 에서 <code class="highlighter-rouge">redirect()</code> 함수는 HTTP Response를 반환하는 Django의 <code class="highlighter-rouge">HttpResponseRedirect</code> 클래스를 이용하여 클라이언트를 지정한 URL로 이동(redirect)시킵니다. <code class="highlighter-rouge">render()</code> 함수처럼 몇 가지 절차를 간편하게 줄여준 함수이며, <code class="highlighter-rouge">django.shortcuts</code> 모듈에 있습니다.</p>

<p><code class="highlighter-rouge">redirect(obj)</code>에서 눈 여겨 볼 부분은 바로 <code class="highlighter-rouge">obj</code>입니다. <code class="highlighter-rouge">obj</code> 변수엔 <code class="highlighter-rouge">Photo</code> 모델의 인스턴스 객체가 연결되어 있습니다. <code class="highlighter-rouge">redirect</code> 함수는 전달된 객체가 모델의 인스턴스 객체인 경우 그 객체의 <code class="highlighter-rouge">get_absolute_url()</code> 메서드를 호출합니다. 음, 우리는 <code class="highlighter-rouge">Photo</code> 모델에 <code class="highlighter-rouge">get_absolute_url()</code> 인스턴스 메서드를 만든 적이 없습니다. 먼저 만들고 설명하겠습니다. <code class="highlighter-rouge">photo</code> 앱 디렉터리 안에 있는 <code class="highlighter-rouge">models.py</code>에서 <code class="highlighter-rouge">Photo</code> 모델 클래스에 다음 코드를 추가합니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from django.core.urlresolvers import reverse_lazy


class Photo(models.Model):
    # 중략

    def get_absolute_url(self):
        url = reverse_lazy('detail', kwargs={'pk': self.pk})
        return url
</code></pre></div></div>

<p>Django Model의 <code class="highlighter-rouge">get_absolute_url()</code> 메서드는 모델의 개별 데이터에 접근하는 URL을 문자열로 반환합니다. 우리는 개별 사진을 보는 URL을 <code class="highlighter-rouge">/photos/사진ID/</code> 패턴으로 제공하므로, 2번 사진은 <code class="highlighter-rouge">/photos/2/</code>, 1023번 사진은 <code class="highlighter-rouge">/photos/1023/</code> URL로 접근합니다. 각 사진의 데이터는 <code class="highlighter-rouge">Photo</code> 모델에 존재하며, 사진 데이터란 모델 클래스의 인스턴스 객체이므로 모델 클래스에 인스턴스 메서드로 <code class="highlighter-rouge">get_absolute_url()</code>를 만드는 것입니다.</p>

<p><code class="highlighter-rouge">get_absolute_url</code>라는 이름을 반드시 따를 필요는 없으며 없어도 무방합니다. <code class="highlighter-rouge">permalink()</code>라는 이름으로 메서드를 만들어도 무방합니다. 다만, <code class="highlighter-rouge">get_absolute_url</code>는 Django가 개별 모델 데이터의 URL을 제공하는 메서드라고 전제해 놓은 관례(conventional) 이름이어서 Django가 알아서 처리하는 감춰진 동작<sup id="fnref:5"><a href="#fn:5" class="footnote">5</a></sup>에 사용됩니다. 이런 관례(convention)를 따르면 일일이 지정하고 설정하지 않아도 되어 코드가 간결해집니다.</p>

<p><code class="highlighter-rouge">reverse_lazy()</code>는 나중에 좀 더 자세히 다루기로 하고, 이번 편에서는 <code class="highlighter-rouge">urls.py</code>에 <code class="highlighter-rouge">'create'</code> 이름으로 등록한 URL 패턴에 키워드 인자인 <code class="highlighter-rouge">pk</code>의 값으로 <code class="highlighter-rouge">self.pk</code>를 할당하여 URL 문자열을 가져오는 데 사용했다고 이해하고 넘어가겠습니다.</p>

<p>사진 게시물을 게시하는 기능을 구현했습니다. 실제로 올려보세요. 잘 게시됩니다.</p>

<h4 id="유효하지-않은-폼-항목-오류-출력하기">유효하지 않은 폼 항목 오류 출력하기</h4>

<p>혹시 사진으로 이미지 파일을 첨부하지 않거나 이미지 파일이 아닌 파일을 첨부하여 게시물을 첨부해 보셨나요? 강좌 소스 코드대로 잘 따라 오셨다면, 오류 내용이 안내됩니다. 우리는 템플릿 파일 어디에도 폼 오류 안내말을 출력하지 않았는데, 이게 어떻게 된 일일까요? 우리가 템플릿 파일에 폼 관련 내용을 담은 건 고작 한 줄 뿐입니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    {{ form.as_p }}
</code></pre></div></div>

<p><code class="highlighter-rouge">as_p</code>로 폼 내용을 HTML로 출력하려 하면, 폼 항목에 오류가 있는 지, 즉, 폼 인스턴스 객체의 <code class="highlighter-rouge">errors</code> 속성에 내용이 있는 지 확인하고, 있다면 오류 내용을 출력합니다. <code class="highlighter-rouge">{{ form.as_p }}</code>를 풀어쓰면 다음과 같습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    {% for field in form %}
    &lt;p&gt;
        {% if field.errors %}
        {{ field.errors }}
        {% endif %}

        {{ field }}
    &lt;/p&gt;
    {% endfor %}
</code></pre></div></div>

<p><code class="highlighter-rouge">form</code> 템플릿 변수(<code class="highlighter-rouge">views.py</code>에서는 <code class="highlighter-rouge">form</code> 객체)는 <code class="highlighter-rouge">for</code>문으로 순환 가능합니다. 순환하면 폼에 등록된 폼 필드 순서대로 하나씩 폼 필드 객체를 꺼냅니다. 이 필드 객체를 출력하려 하면 이 필드가 생성하는 HTML 내용을 반환하는데, 이 필드 객체에 오류가 있는 경우, 오류 내용이 필드 객체의 <code class="highlighter-rouge">errors</code>에 할당됩니다. 한 폼 필드에 오류 내용은 한 개 이상인 경우도 생기므로 순서열 객체(<code class="highlighter-rouge">list</code>)에 오류가 하나씩 할당됩니다. <code class="highlighter-rouge">{{ field.errors }}</code> 마저도 더 풀어쓰면 다음과 같습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        {% if field.errors %}
        &lt;ul&gt;
            {% for error in field.errors %}
            &lt;li&gt;{{error}}&lt;/li&gt;
            {% endfor %}
        &lt;/ul&gt;
        {% endif %}
</code></pre></div></div>

<p>폼 필드를 직접 명시하여 오류를 확인하는 방법도 있습니다. 예를 들어, 이미지 파일 필드인 <code class="highlighter-rouge">image</code>에 오류가 있는 지 확인하는 방법은 다음과 같습니다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{% if form.errors.image %}
    {{form.errors.image}}
{% endif %}

또는

{% if form.image.errors %}
    {{form.image.errors}}
{% endif %}
</code></pre></div></div>

<p>대개는 Django Form이 자동으로 만들어주는 폼 항목 구성을 그대로 사용하진 않습니다. 각 폼 항목에 CSS나 HTML 속성을 다르게 부여하는데, Django 애플리케이션 개발자가 고치지 않고 Front-end 개발자가 수정하는 경우도 있습니다. 그래서 폼 필드를 구성하는 요소(레이블, 오류, 폼 필드 자체)를 분리해서 위와 같이 다루는 경우가 흔하고, 오히려 <code class="highlighter-rouge">{{ form.as_p }}</code>와 같이 Django에서 만들어내는 HTML 그대로를 사용하는 경우가 드뭅니다.</p>

<hr />

<p>강좌 7편을 마칩니다. 이번 편에서 다룬 Django Form이 동작하는 큰 흐름을 이해하면 앞으로 다룰 Form 세부 요소를 이해하기 쉽습니다.</p>

<ul>
  <li><a href="https://github.com/hannal/start_with_django_webframework/tree/l07">7편까지 진행한 전체 소스 코드</a></li>
</ul>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p><a href="https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/">Encoding Web Shells in PNG IDAT chunks</a> 글이나 <a href="https://blog.sucuri.net/2013/07/malware-hidden-inside-jpg-exif-headers.html">Malware Hidden Inside JPG EXIF Headers</a> 글 참조. <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p><a href="https://dobest.io/how-csrf-token-works/">Django와 Rails에서 CSRF Token의 동작 방식</a>이라는 글을 참조하세요. <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>쉼표를 빼서 <code class="highlighter-rouge">('filtered_image')</code>로 표기하면 그냥 문자열 객체가 됩니다. 리스트 객체를 만드는 데 대괄호를(<code class="highlighter-rouge">[</code>와 <code class="highlighter-rouge">]</code>) 사용하고 튜플 객체를 만드는 데 소괄호(<code class="highlighter-rouge">(</code>와 <code class="highlighter-rouge">)</code>)를 활용해서 헷갈리기 일쑤인데, 튜플을 만드는 데에 필요한 건 괄호가 아니라 쉼표(<code class="highlighter-rouge">,</code>)입니다. 왜냐하면 쉼표로 항목을 구분하여 나열하며, 괄호는 명시적으로 생략 가능하기 때문입니다. 단, 예외로 아무 항목이 없는 빈 튜플을 만드는 경우엔 그냥 소괄호로 짝지으면 됩니다. 자세한 내용은 <a href="https://docs.python.org/3/library/stdtypes.html#tuples">공식 문서의 Tuples</a>를 참조하세요. <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>사전형 객체처럼 생긴 이런 객체를 인스턴스로 만드는 데 사용하는 클래스(<code class="highlighter-rouge">type</code>)도 <code class="highlighter-rouge">dict</code>를 상속받아서 만들어서 <code class="highlighter-rouge">dict</code>형이 제공하는 인터페이스를 포함합니다. <a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:5">
      <p>“magic”이라는 표현을 씁니다. 뭔가 알아서 수행되는데, 이용자(개발자)가 굳이 알 필요가 없는 내부에 감춰진 동작을 뜻하지요. <a href="#fnref:5" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>
  <hr class="post-parting-line" />
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page11">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page9">Newer</a>
    
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-33535239-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-KS9HDB"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KS9HDB');</script>
<!-- End Google Tag Manager -->
 <!--[if lt IE 9]>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <![endif]-->
    <!--[if gte IE 9]><!-->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <!--<![endif]-->
    </body>
</html>
