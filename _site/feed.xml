<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kay on the rails</title>
    <description>Kay as known as Hannal walks on the rails
</description>
    <link>http://blog.hannal.com//</link>
    <atom:link href="http://blog.hannal.com//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 22 Mar 2015 01:56:02 +0900</pubDate>
    <lastBuildDate>Sun, 22 Mar 2015 01:56:02 +0900</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>Python 3에서 함수의 위치 인자와 주석문</title>
        <description>&lt;p&gt;Python 3에 도입된 함수 선언 문법 중 위치 인자 개수를 지정하는 것과 주석문(&lt;code&gt;annotation&lt;/code&gt;)이 있다. Python의 매력 요소 중 하나가 깔끔하고 명료한 코드라 생각하는데, 이 두 문법은 기호를 남발하는 코드처럼 보여서 좀 불만스럽지만 코드 문맥(context)을 읽는 데엔 참 유익하다. 그나마 &lt;code&gt;$&lt;/code&gt; 기호가 사용되는 건 아니라서 다행이랄까?! :)&lt;/p&gt;

&lt;h3&gt;위치 인자 개수 지정&lt;/h3&gt;

&lt;p&gt;Python은 함수 매개 인자 방식으로 위치 인자(positional argument)와 키워드 인자(keywords argument)를 지원한다. 위치 인자는 함수로 전달하는 매개 인자를 순서대로 나열하는 것이고, 키워드 인자는 인자 이름과 인자에 할당할 값을 특정하는 것이다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def args_func(arg1, arg2, arg3):
    print(arg1, arg2, arg3)

args_func(&amp;#39;hello&amp;#39;, &amp;#39;world&amp;#39;, &amp;#39;!&amp;#39;)
args_func(&amp;#39;!&amp;#39;, arg3=&amp;#39;hello&amp;#39;, arg2=&amp;#39;world&amp;#39;)
args_func(&amp;#39;world&amp;#39;, arg3=&amp;#39;!&amp;#39;, arg2=&amp;#39;hello&amp;#39;)
args_func(&amp;#39;hello&amp;#39;, &amp;#39;!&amp;#39;, arg3=&amp;#39;world&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위 코드에서&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;args_func(&amp;#39;hello&amp;#39;, &amp;#39;world&amp;#39;, &amp;#39;!&amp;#39;)&lt;/code&gt;는 &lt;code&gt;hello world !&lt;/code&gt;를 출력하고,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;args_func(&amp;#39;!&amp;#39;, arg3=&amp;#39;hello&amp;#39;, arg2=&amp;#39;world&amp;#39;)&lt;/code&gt;는 &lt;code&gt;! world hello&lt;/code&gt;를 출력한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;args_func(&amp;#39;world&amp;#39;, arg3=&amp;#39;!&amp;#39;, arg2=&amp;#39;hello&amp;#39;)&lt;/code&gt;는 &lt;code&gt;world hello !&lt;/code&gt;를 출력하며,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;args_func(&amp;#39;hello&amp;#39;, &amp;#39;!&amp;#39;, arg3=&amp;#39;world&amp;#39;)&lt;/code&gt;는 &lt;code&gt;hello ! world&lt;/code&gt;를&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;출력한다. 위치 인자, 키워드 인자 순서로 전달만 하면 어떤 인자를 위치 인자로 전달하고, 어떤 인자를 키워드 인자로 전달하는지에 별다른 제한은 없다.&lt;/p&gt;

&lt;p&gt;Python 3는 키워드 인자를 강제하는 문법을 지원한다. 바로 &lt;code&gt;*&lt;/code&gt; 문자를 쓰는 것이다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def args2_func(arg1, *, arg2, arg3):
    print(arg1, arg2, arg3)

args2_func(&amp;#39;hello&amp;#39;, &amp;#39;world&amp;#39;, &amp;#39;!&amp;#39;)
args2_func(&amp;#39;!&amp;#39;, arg3=&amp;#39;hello&amp;#39;, arg2=&amp;#39;world&amp;#39;)
args2_func(&amp;#39;world&amp;#39;, arg3=&amp;#39;!&amp;#39;, arg2=&amp;#39;hello&amp;#39;)
args2_func(&amp;#39;hello&amp;#39;, &amp;#39;!&amp;#39;, arg3=&amp;#39;world&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 이후에 나열된 매개 인자는 반드시 키워드 인자로 전달돼야 한다. 위 코드에서 &lt;code&gt;args2_func&lt;/code&gt; 함수를 실행하는 네 개 실행 줄 중 첫 번째와 네 번째는 &lt;code&gt;TypeError&lt;/code&gt; 예외가 일어난다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: args2_func() takes 1 positional argument but 3 were given
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;즉, &lt;code&gt;args2_func&lt;/code&gt; 함수는 위치 인자를 1개 취하는데, 이 개수보다 많은 인자가 위치 인자로 전달되었다는 뜻이다.&lt;/p&gt;

&lt;p&gt;그렇다면 &lt;code&gt;*&lt;/code&gt; 이전에 나열된 매개 인자를 키워드 인자로 값을 전달하면 어떻게 될까?&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;args2_func(arg1=&amp;#39;hello&amp;#39;, arg2=&amp;#39;world&amp;#39;, arg3=&amp;#39;!&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;아무 문제도 발생하지 않는다. 즉, &lt;code&gt;*&lt;/code&gt;는 위치 인자 개수를 특정하거나(exact) &lt;code&gt;*&lt;/code&gt; 앞에 나열된 인자를 위치 인자로 강제하는 것이 아니라 &lt;code&gt;*&lt;/code&gt; 이후에 나열되는 인자는 반드시 키워드 인자로 전달 받도록 강제하는 것이다. 만약 위치 인자를 단 한 개도 허용하지 않고자 한다면 다음과 같이 함수 매개 인자를 선언하면 된다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def kwargs_func(*, arg1, arg2, arg3):
    print(arg1, arg2, arg3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 함수는 모든 매개 인자를 키워드 인자로 전달해야 한다.&lt;/p&gt;

&lt;h3&gt;주석문 (annotation)&lt;/h3&gt;

&lt;p&gt;annotation 문법은 함수 매개 인자와 반환 값에 대한 주석(annotation)을 지정하는 것이다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def anno_func(arg1: str, arg2: &amp;#39;also str&amp;#39;, arg3: 1 is True) -&amp;gt; bool:
    print(arg1, arg2, arg3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;표현된 코드를 보면 마치 인자의 형(&lt;code&gt;type&lt;/code&gt;)을 지정하는 것 같지만, 실제로는 주석이기 때문에 인자의 형이 무엇이 되든 영향을 받지 않아서 다음과 같이 함수를 호출해도 아무 문제가 발생하지 않는다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;anno_func(1, True, &amp;#39;world&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;반환하는(return) 값의 형도 주석으로 설명한 것과 달라도 무방하다. &lt;code&gt;anno_func&lt;/code&gt;은 주석으로 반환 값을 &lt;code&gt;bool&lt;/code&gt;이라 명기했지만, 실제로는 &lt;code&gt;return&lt;/code&gt;문이 따로 없기 때문에 &lt;code&gt;None&lt;/code&gt; 값을 반환한다. 물론, 아무 문제도 없다.&lt;/p&gt;

&lt;p&gt;이렇게 지정한 주석은 함수 객체에 &lt;code&gt;__annotations__&lt;/code&gt; 속성에 담겨 있으며, 사전형(&lt;code&gt;dict&lt;/code&gt;) 객체이다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;print(anno_func.__annotations__)
print(anno_func.__annotations__[&amp;#39;arg1&amp;#39;])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;재밌는 점은 &lt;code&gt;__annotations__&lt;/code&gt;에는 주석으로 지정한 값(&lt;code&gt;value&lt;/code&gt;)이 그대로 할당되어 있다는 점이다. 이 점을 이용하면 함수 매개 인자를 특정할 수 있다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def static_args_func(arg1: str, arg2: str, arg3: int) -&amp;gt; bool:
    args = locals()
    for _k, _v in args.items():
        arg_type = static_args_func.__annotations__[_k]

        if isinstance(_v, arg_type):
            continue

        raise TypeError(
            &amp;quot;The type of &amp;#39;{}&amp;#39; does not match &amp;#39;{}&amp;#39; type&amp;quot;.format(
                _k, arg_type.__name__
            )
        )
    print(arg1, arg2, arg3)

static_args_func(1, 2, 3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;static_args_func&lt;/code&gt; 함수의 &lt;code&gt;arg1&lt;/code&gt;, &lt;code&gt;arg2&lt;/code&gt; 인자는 주석으로 &lt;code&gt;str&lt;/code&gt;형을 명기했다. 그래서 사전형 속성인 &lt;code&gt;__annotations__&lt;/code&gt;의 &lt;code&gt;arg1&lt;/code&gt;키에는 명기한 값인 &lt;code&gt;str&lt;/code&gt;이 할당되어 있다. &lt;code&gt;__annotations__&lt;/code&gt;에 할당되어 있는 주석 값을 이용해 &lt;code&gt;arg1&lt;/code&gt;과 같은 함수 매개 인자의 형을(&lt;code&gt;type&lt;/code&gt;) 검사한 것이 &lt;code&gt;if not isinstance(_v, arg_type):&lt;/code&gt; 부분이다.&lt;/p&gt;

&lt;p&gt;이 함수를 &lt;code&gt;static_args_func(1, 2, 3)&lt;/code&gt;와 같이 호출하면 &lt;code&gt;arg1&lt;/code&gt;과 &lt;code&gt;arg2&lt;/code&gt;에 대해 코드에서 지정한 &lt;code&gt;TypeError&lt;/code&gt; 예외가 일어난다.&lt;/p&gt;

&lt;p&gt;다음 코드는 가변 매개 인자도 형 검사를 한다. 더이상 형 검사를 하지 않는 위치부터 나머지 인자까지는 &lt;code&gt;Ellipsis&lt;/code&gt; 형(&lt;code&gt;...&lt;/code&gt;)을 썼다. 즉, 두 번째 인자까지는 형 검사를 하고, 이후 인자는 형 검사를 생략한다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def type_checking_func(*args: (int, int, ...)):
    annotations = type_checking_func.__annotations__

    if (
        not isinstance(annotations, dict) or
        len(annotations) == 0
    ):
        return type_checking_func(*args)

    try:
        _check_index = annotations[&amp;#39;args&amp;#39;].index(Ellipsis)
    except ValueError:
        _check_index = len(annotations) - 1

    for i, _v in enumerate(args[:_check_index]):
        arg_type = annotations[&amp;#39;args&amp;#39;][i]

        if isinstance(_v, arg_type):
            continue

        raise TypeError(
            &amp;quot;The type of &amp;#39;{}&amp;#39; does not match &amp;#39;{}&amp;#39; type&amp;quot;.format(
                _v, arg_type.__name__
            )
        )
    print(*args)

type_checking_func(1, 2, &amp;#39;3&amp;#39;, &amp;#39;a&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;인자의 형을 검사하는 기능을 장식자(&lt;code&gt;decorator&lt;/code&gt;)로 만들어서 여러 함수에 간편하게 사용하면 더 낫다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;def check_argument_type(func):
    def wrapper(*args):
        annotations = func.__annotations__
        if (
            not isinstance(annotations, dict) or
            len(annotations) == 0
        ):
            return func(*args)

        try:
            check_index = annotations[&amp;#39;args&amp;#39;].index(Ellipsis)
        except ValueError:
            check_index = len(annotations[&amp;#39;args&amp;#39;]) - 1

        for _i, _v in enumerate(args[:check_index]):
            _arg_type = annotations[&amp;#39;args&amp;#39;][_i]

            if isinstance(_v, _arg_type):
                continue

            raise TypeError(
                &amp;quot;The type of &amp;#39;{}&amp;#39; does not match &amp;#39;{}&amp;#39; type&amp;quot;.format(
                    _v, _arg_type.__name__
                )
            )
        return func(*args)
    return wrapper

@check_argument_type
def hello_func(*args: (int, int, ...)):
    print(*args)

hello_func(1, 2, &amp;#39;3&amp;#39;, &amp;#39;a&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Python스러운 구현인 지 아닌 지 모르겠지만, 함수 매개 인자가 어떤 자료형으로 넘어올 지 몰라서 받는 스트레스는 줄어들 것 같다. :)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/hannal/12597a1466307f4290a4&quot;&gt;Python 3에서 함수의 위치 인자와 주석문 예제 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 22 Mar 2015 01:50:49 +0900</pubDate>
        <link>http://blog.hannal.com//2015/03/positioning_argument_and_annotations_for_python3/</link>
        <guid isPermaLink="true">http://blog.hannal.com//2015/03/positioning_argument_and_annotations_for_python3/</guid>
        
        <category>Python 3</category>
        
        <category>위치 인자</category>
        
        <category>positional argument</category>
        
        <category>키워드 인자</category>
        
        <category>keywords argument</category>
        
        <category>annotation</category>
        
        
        <category>devlife</category>
        
      </item>
    
      <item>
        <title>개발 생활 - 6</title>
        <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-01/&quot;&gt;개발 생활 - 1&lt;/a&gt; : PDF 문서 생성 서버&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;개발 생활 - 2&lt;/a&gt; : 연산된 데이터 수집 작업자&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-03/&quot;&gt;개발 생활 - 3&lt;/a&gt; : 전자우편 알림 서버&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;개발 생활 - 4&lt;/a&gt; : Python과 Django 강의&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-05/&quot;&gt;개발 생활 - 5&lt;/a&gt; : 공부 자료&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-06/&quot;&gt;&lt;code&gt;개발 생활 - 6&lt;/code&gt;&lt;/a&gt; : 앞으로 계획&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;5. 앞으로 계획&lt;/h3&gt;

&lt;h4&gt;개요&lt;/h4&gt;

&lt;p&gt;지난 6~7개월 동안 학습과 실무가 겹친 개발 생활을 보냈다. 내가 뭘 할 수 있고, 하고 싶은 건 무엇인지, 재밌다고 여기는 건 무엇이며, 앞으로 뭘 할 것인지를 찾는 시간이었다.&lt;/p&gt;

&lt;p&gt;다음 단계는 현재 내가 맡고 있는 분야와 관심 갖고 있는 분야에 대한 기초와 기본부터 계발하여 제대로 이해한 기술로 구현하려 한다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어는 Python을 주력으로 사용하고, Go 비중을 높여갈 계획이다. 추후엔 주 Go를 주로 사용하고 Python을 특정 목적용으로 사용할 것으로 예상한다. &lt;a href=&quot;http://julialang.org/&quot;&gt;Julia&lt;/a&gt;, &lt;a href=&quot;http://nim-lang.org/&quot;&gt;Nim&lt;/a&gt;가 재밌어 보이고, Scala, Java, C++은 별로 끌리진 않지만 공부할 필요성을 느낀다. 하지만 현재 진행하고 있거나 계획한 공부 대상으로도 벅차서 Scala, Java, C++은 당분간 공부하진 않을 것이다.&lt;/p&gt;

&lt;p&gt;테스트 케이스, 문서화, 배포/배치 등 여러 부분을 자동화하고 있고 더 많이 자동화 할 예정이다. 맡은 프로젝트가 늘어나고 각 프로젝트 구현단이 확장되면서 개발과 운영 복잡도가 증가하다 보니 자연스레 기존 자동화 도구나 방법이 필요한 이유를 이해하여 필요로 하게 됐다.&lt;/p&gt;

&lt;h4&gt;PDF 문서 생성 서버&lt;/h4&gt;

&lt;p&gt;현재(2015년 3월 기준) PDF 문서 생성 서버를 리팩토링하고 있으며, 리팩토링 후 신규 버전을 개발할 예정이다. 신규 버전은 다음 내용을 목표로 한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;메모리 사용량 줄이기 (lazy evaluation)&lt;/li&gt;
&lt;li&gt;PDF 생성을 병렬로 처리&lt;/li&gt;
&lt;li&gt;Python 3 지원&lt;/li&gt;
&lt;li&gt;캐쉬(cache) 강화&lt;/li&gt;
&lt;li&gt;전자우편 알림 서버(&lt;code&gt;postman&lt;/code&gt;) 연동&lt;/li&gt;
&lt;li&gt;통계 기능 추가&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sentry&lt;/code&gt; 연동&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;편의점 프로젝트 (연산된 데이터 수집 작업자)&lt;/h4&gt;

&lt;p&gt;4월 이후에 리팩토링을 한 후 소소한 업그레이드를 계획하고 있다. 회사 개발 일정이나 계획에 따로 잡은 건 아니어서 짬짬히 시간 내어 해결할 범위로 구상하고 있다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PyPy&lt;/code&gt;로 이전&lt;/li&gt;
&lt;li&gt;통계 기능 추가&lt;/li&gt;
&lt;li&gt;Sentry 연동&lt;/li&gt;
&lt;li&gt;CEP(Complex Event Processing) 적용&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;전자우편 알림 서버&lt;/h4&gt;

&lt;p&gt;현재 새로운 알림 조건을 추가하고 있으며, 4월 이후 개인화 된 소식지(newsletter) 기능을 준비한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;전자우편 발송부를 Go 언어로 이전&lt;/li&gt;
&lt;li&gt;애플리케이션 서버들 간 통신 방법 변경&lt;/li&gt;
&lt;li&gt;알림 조건 종류 확장&lt;/li&gt;
&lt;li&gt;모바일 푸시 알림 기능 추가 (&lt;code&gt;mqtt&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;개인화 된 소식지 기능 추가 (data processing, batch)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;공부&lt;/h4&gt;

&lt;p&gt;공부할 게 많은데, 책을 기준으로 나열하면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;동시성, 병렬성

&lt;ul&gt;
&lt;li&gt;입문자를 위한 병렬 프로그래밍 (ISBN : 9791185890159)&lt;/li&gt;
&lt;li&gt;Pattern-Oriented Software Architecture, Volume 2: Patterns for Concurrent and Networked Objects (ISBN : 0471606956)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;프로그래밍

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;클린 코드&lt;/em&gt; (ISBN : 9788966260959)&lt;/li&gt;
&lt;li&gt;&lt;em&gt;프로그램 디자인, 어떻게 할 것인가&lt;/em&gt; (ISBN : 9788991268975)&lt;/li&gt;
&lt;li&gt;Pattern-Oriented Software Architecture, Volume 1: A System of Patterns (ISBN : 9780471958697)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;시스템

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;리눅스 시스템 프로그래밍&lt;/em&gt; (ISBN : 9788968481482)&lt;/li&gt;
&lt;li&gt;컴퓨터 구조 및 설계 (ISBN : 9788996276531)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;네트워크

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;트위스티드&lt;/em&gt; (ISBN : 9788966261154)&lt;/li&gt;
&lt;li&gt;컴퓨터 네트워킹 하향식 접근 (ISBN : 9788945006585)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;언어

&lt;ul&gt;
&lt;li&gt;Programming in Go (ISBN : 9780321774637)&lt;/li&gt;
&lt;li&gt;The Go Programming Language (ISBN : 9780134190440. 2015년 8월 출간 예정)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;데이터, 통계 관련

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;파이썬을 활용한 베이지안 통계&lt;/em&gt; (ISBN : 9788968481147)&lt;/li&gt;
&lt;li&gt;파이썬 라이브러리를 활용한 데이터 분석 (ISBN : 9788968480478)&lt;/li&gt;
&lt;li&gt;Building Machine Learning Systems with Python (ISBN : 9788960775367)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;알고리즘

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;알고리즘 기초&lt;/em&gt; (ISBN : 9791156000129)&lt;/li&gt;
&lt;li&gt;문제로 풀어보는 알고리즘 (ISBN : 9788966260461)&lt;/li&gt;
&lt;li&gt;알고리즘 문제 해결 전략 (ISBN : 9788966260546)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;수학

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;수학독본&lt;/em&gt; (ISBN : 9788935640379)&lt;/li&gt;
&lt;li&gt;착한 수학 (ISBN : 9788993827866)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;현재(2015년 3월 기준) 보고 있는 책은 따로 표시했으며, 이외엔 다음에 읽거나 틈틈히 부분 참고하며 읽을 책들이다.&lt;/p&gt;

&lt;h4&gt;잉여&lt;/h4&gt;

&lt;p&gt;잉여 시간이 나면 Lego mindstorm과 Arduino를 갖고 놀며, &lt;code&gt;Docker&lt;/code&gt;와 &lt;code&gt;Open stack&lt;/code&gt;을 구현 관점에서 분석할 계획이다.&lt;/p&gt;

&lt;h4&gt;집필&lt;/h4&gt;

&lt;p&gt;Python과 Django를 도구로 삼은 입문서를 준비하고 있다. 함께 논의하고 있는 편집자가 믿음직스러워서 정말 출간할 수 있겠다는 기대감이 든다. 학습하고, 개발하고, 가르치는 경험을 잘 녹여내어 올해 안에 출간하고 싶다.&lt;/p&gt;

&lt;h4&gt;개발 환경&lt;/h4&gt;

&lt;p&gt;대개는 문서를 &lt;code&gt;markdown&lt;/code&gt;으로 작성하는데, &lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;Python과 Django 강의&lt;/a&gt; 이후로 IPython을 사용하는 빈도가 늘고 있다. 최근엔 Python 뿐만 아니라 다른 프로그래밍 언어도 지원하는 &lt;a href=&quot;http://jupyter.org/&quot;&gt;Jupyter&lt;/a&gt;를 사용하고 있다. 앞으로 많은 문서를 Jupyter를 이용할 생각이다.&lt;/p&gt;

&lt;p&gt;코드 편집기는 Sublime text 3를 주로 사용하며, &lt;code&gt;PyCharm&lt;/code&gt; 등 JetBrains사의 도구를 사용하려 몇 번 시도했으나 좀처럼 적응하지 못하고 있다. 마음에 드는 기능이 많은데, 미묘하게 느린 화면 반응을 견디기 힘들다. &lt;a href=&quot;http://www.sourcetreeapp.com/&quot;&gt;SourceTree&lt;/a&gt;도 답답해서 터미널에서 &lt;code&gt;git&lt;/code&gt;을 콘솔로 쓰고 있으니, 당분간 IDE에 적응하는 데 적지않은 노력을 들이거나 결국 포기할 것 같다.&lt;/p&gt;

&lt;h4&gt;마치며&lt;/h4&gt;

&lt;p&gt;전업 프로그래머가 된 이후로도 사업 개발이나 기획 업무를 맡아달라는 제안을 받고 있지만, 현재 내가 참여하는 조직들(?)에서는 전부 프로그래밍 관련 일만 하고 있다. 이 조직들 모두 내게 권한과 기회를 위임하고 지원해주는 덕분에 힘든 시기를 즐겁게 보냈다.&lt;/p&gt;

&lt;p&gt;미숙해서 문제를 푸느라 고생하는 상황에 처했을 때, 누군가에게 물어봐서 문제를 빨리 해결하고 싶은 충동을 많이 느꼈다. 이 문제 좀 풀어주세요, 라는 말이 목까지 치밀어 올라온 문제도 몇 개 있었다. 하지만, 내가 부딪힌 문제 대부분은 스스로 해결해야 의미있는 단계라는 걸 알고 있었고, 거의 모두 스스로 해결했다&lt;sup id=&quot;fnref1&quot;&gt;&lt;a href=&quot;#fn1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;지인이 (프로그래밍으로)개발하는 생활을 만족하느냐고 물었다. 재밌고 만족한다고 답했는데, 아직은 혼자 고민하여 스스로 문제를 해결하는 데 들이는 노력이 크지 않은 단계여서 재밌다고 여기는 것일 것이다. 여태껏 겪어 온 문제보다 더 어려운 난관에 부딪히면 그 재미는 (아마도) 줄어들 것이고, 끝내 내 능력으로 풀어내지 못해 좌절할 지도 모른다.&lt;/p&gt;

&lt;p&gt;괜찮다. 프로그래머 생활을 만족하는 이유는 난관을 극복하며 성장하는 즐거움 뿐만 아니라 내 생각을 표현하는 방법으로써 매력과 재미를 느끼기 때문이다. 가령, 요리나 춤, 노래, 대화는 취미나 관심사로 재밌을지 몰라도 직업으로 내 생각을 표현할 방법으로 삼을만큼 재밌지도 매력있게 느껴지지도 않는다.&lt;/p&gt;

&lt;p&gt;지난 6~8개월 동안 겪은 개발 생활은 즐거웠다. 더 재밌고 즐겁고 만족스러운 개발 생활을 보내기 위해 계속 노력하려 한다.&lt;/p&gt;

&lt;hr&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;

&lt;li id=&quot;fn1&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;편의점 프로젝트&lt;/a&gt;에서 SQL Query를 짜는 문제 하나는 결국 동료가 해결해 주었다.&amp;nbsp;&lt;a href=&quot;#fnref1&quot; rev=&quot;footnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Tue, 17 Mar 2015 04:13:40 +0900</pubDate>
        <link>http://blog.hannal.com//2015/03/devlife-s1-06/</link>
        <guid isPermaLink="true">http://blog.hannal.com//2015/03/devlife-s1-06/</guid>
        
        <category>Python</category>
        
        <category>SMTP</category>
        
        <category>Jinja2</category>
        
        <category>Celery</category>
        
        <category>Mailjet</category>
        
        <category>Sentry</category>
        
        <category>Upstart</category>
        
        
        <category>devlife</category>
        
      </item>
    
      <item>
        <title>개발 생활 - 5</title>
        <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-01/&quot;&gt;개발 생활 - 1&lt;/a&gt; : PDF 문서 생성 서버&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;개발 생활 - 2&lt;/a&gt; : 연산된 데이터 수집 작업자&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-03/&quot;&gt;개발 생활 - 3&lt;/a&gt; : 전자우편 알림 서버&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;개발 생활 - 4&lt;/a&gt; : Python과 Django 강의&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-05/&quot;&gt;&lt;code&gt;개발 생활 - 5&lt;/code&gt;&lt;/a&gt; : 공부 자료&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-06/&quot;&gt;개발 생활 - 6&lt;/a&gt; : 앞으로 계획&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;4. 공부 자료&lt;/h3&gt;

&lt;h4&gt;개요&lt;/h4&gt;

&lt;p&gt;2014년 7월부터 2015년 2월까지 지낸 개발 생활 중 공부하거나 참고한 자료를 정리했다. 미처 따로 기록하지 못 한 자료는 기재하지 않았다.&lt;/p&gt;

&lt;p&gt;일부는 부분 참고를 했고, 일부는 여전히 공부하느라 참고하고 있다.&lt;/p&gt;

&lt;h4&gt;책&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;파이썬 완벽 가이드

&lt;ul&gt;
&lt;li&gt;ISBN : 9788966260256&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;파이썬 인 프랙티스

&lt;ul&gt;
&lt;li&gt;ISBN : 9788998139650&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;실전 파이썬 프로그래밍

&lt;ul&gt;
&lt;li&gt;ISBN : 9788966261246&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Linux System Programming

&lt;ul&gt;
&lt;li&gt;ISBN : 9788968481482&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;열혈강의 파이썬

&lt;ul&gt;
&lt;li&gt;ISBN : 9788989345770&lt;/li&gt;
&lt;li&gt;강의 준비할 때 참고&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Python Network Programming

&lt;ul&gt;
&lt;li&gt;ISBN : 9781430230038&lt;/li&gt;
&lt;li&gt;웹 소켓 서버와 전자우편 알림 서버 개발에 참고&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;트위스티드

&lt;ul&gt;
&lt;li&gt;ISBN : 9788966261154&lt;/li&gt;
&lt;li&gt;비동기 처리 학습&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Programming in Python 3, 2nd Edition

&lt;ul&gt;
&lt;li&gt;ISBN : 9780321680563&lt;/li&gt;
&lt;li&gt;Python 3 준비하기 위해 부분 참고&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;웹 자료&lt;/h4&gt;

&lt;h5&gt;Python&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.python.org&quot;&gt;Python 공식 문서&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.python.org/3/library/asyncio-task.html&quot;&gt;Tasks and coroutines&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.flowdas.com/thinkpython/&quot;&gt;Think Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;PEP 8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.eairship.kr/271&quot;&gt;금지된 엑시노아의 비공정 - 파이썬 강좌&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.flowdas.com/blog/asyncio-python-tulip/&quot;&gt;asyncio - Python Tulip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@cookatrice/why-python-is-slow-looking-under-the-hood-7126baf936d7&quot;&gt;파이썬은 왜 느릴까요? 내부 원리를 살펴 봅시다.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.pycon.kr/2014/program/2&quot;&gt;위대한 dict 이해하고 사용하기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.python.org/doc/essays/list2str/&quot;&gt;Python Patterns - An Optimization Anecdote&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openlook.org/wp/?p=801&quot;&gt;파이썬을 두루 이해하는 데 도움 되는(?) 퀴즈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.dabeaz.com/generators/index.html&quot;&gt;Generator Tricks for Systems Programmers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cafepy.com/article/python_types_and_objects/python_types_and_objects.html&quot;&gt;Python Types and Objects&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://techspot.zzzeek.org/2015/02/15/asynchronous-python-and-databases/&quot;&gt;Asynchronous Python and Databases&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.python-guide.org/&quot;&gt;The Hitchhiker’s Guide to Python!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;Python 관련 frameworks나 libraries&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Django

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.djangoproject.com&quot;&gt;Django 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/cs-math/11-things-i-wish-i-knew-about-django-development-before-i-started-my-company-f29f6080c131&quot;&gt;11 Things I Wish I Knew About Django Development Before I Started My Company&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.looah.com/article/view/2025&quot;&gt;2014년에 Django로 개발하면서 실수한 부분&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.etianen.com/blog/2013/06/08/django-querysets/&quot;&gt;Using Django querysets effectively&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;번역 : &lt;a href=&quot;http://raccoonyy.github.io/using-django-querysets-effectively-translate/&quot;&gt;Django에서 쿼리셋 효과적으로 사용하기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.michelepasin.org/blog/2010/07/20/the-power-of-djangos-q-objects/&quot;&gt;The power of django’s Q objects&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;gevent

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.gevent.org/contents.html&quot;&gt;gevent 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sdiehl.github.io/gevent-tutorial/&quot;&gt;gevent tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.pycon.kr/2014/program/3&quot;&gt;제약을 넘어 : Gevent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.pythonisito.com/2011/07/gevent-zeromq-websockets-and-flot-ftw.html&quot;&gt;Gevent, ZeroMQ, WebSockets, and Flot FTW!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.miguelgrinberg.com/post/easy-websockets-with-flask-and-gevent/page/9&quot;&gt;Easy WebSockets with Flask and Gevent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Celery

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://celery.readthedocs.org/&quot;&gt;Celery 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zapier.com/blog/async-celery-example-why-and-how/&quot;&gt;Async Celery by Example: Why and How&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://celery.readthedocs.org/en/latest/userguide/periodic-tasks.html&quot;&gt;Periodic Tasks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;SQLAlchemy

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.sqlalchemy.org/&quot;&gt;SQLAlchemy 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.pythoncentral.io/understanding-python-sqlalchemy-session/&quot;&gt;Understanding Python SQLAlchemy’s Session&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;이외

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.python-requests.org/&quot;&gt;Requests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://siriux.net/2013/06/nginx-and-websockets/&quot;&gt;nginx and WebSockets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://flask.pocoo.org/docs&quot;&gt;Flask 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jinja.pocoo.org/docs&quot;&gt;Jinja2 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kombu.readthedocs.org&quot;&gt;Kombu 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ipython.org/documentation.html&quot;&gt;IPython 공식 문서&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://nbviewer.ipython.org/github/re4lfl0w/ipython/blob/master/books/python_data_analysis/ch03_Introduction%20IPython.ipynb&quot;&gt;IPython 소개&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;Go&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://go-tour-kr.appspot.com/&quot;&gt;A Tour of Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.golang-book.com/&quot;&gt;An introduction to programming in Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://code.google.com/p/golang-korea/wiki/EffectiveGo&quot;&gt;Go언어 잘 사용하는 방법&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gobyexample.com/&quot;&gt;Go by Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://talks.golang.org/2012/waza.slide&quot;&gt;Concurrency is not Parallelism&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;Redis&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.joinc.co.kr/modules/moniwiki/wiki.php/man/12/REDIS/DataModeling&quot;&gt;REDIS 데이터 모델링 예제들&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://charsyam.wordpress.com/category/cloud/redis/&quot;&gt;CharSyam&amp;#39;s Redis posts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;이외&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.codeok.net/&quot;&gt;CODEOK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://sentry.readthedocs.org/&quot;&gt;Sentry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://natepinchot.com/2014/01/31/building-static-wkhtmltopdf/&quot;&gt;Building static wkhtmltopdf (and static QT)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://ghebook.blogspot.kr/2010/10/permutation-combination.html&quot;&gt;순열(順列, permutation)과 조합(組合, combination)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.rfc-editor.org/rfc-index.html&quot;&gt;RFC Index&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://bespokebytes.com/start-getting-up-and-running-with-upstart/&quot;&gt;Start getting up and running with Upstart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lqez.github.io/blog/fool-upstart.html&quot;&gt;Fool Upstart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 14 Mar 2015 21:13:40 +0900</pubDate>
        <link>http://blog.hannal.com//2015/03/devlife-s1-05/</link>
        <guid isPermaLink="true">http://blog.hannal.com//2015/03/devlife-s1-05/</guid>
        
        <category>Python</category>
        
        <category>책</category>
        
        <category>참고자료</category>
        
        <category>Go</category>
        
        <category>비동기</category>
        
        <category>Sentry</category>
        
        <category>Django</category>
        
        <category>Redis</category>
        
        <category>gevent</category>
        
        
        <category>devlife</category>
        
      </item>
    
      <item>
        <title>개발 생활 - 4</title>
        <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-01/&quot;&gt;개발 생활 - 1&lt;/a&gt; : PDF 문서 생성 서버&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;개발 생활 - 2&lt;/a&gt; : 연산된 데이터 수집 작업자&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-03/&quot;&gt;개발 생활 - 3&lt;/a&gt; : 전자우편 알림 서버&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;&lt;code&gt;개발 생활 - 4&lt;/code&gt;&lt;/a&gt; : Python과 Django 강의&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-05/&quot;&gt;개발 생활 - 5&lt;/a&gt; : 공부 자료&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-06/&quot;&gt;개발 생활 - 6&lt;/a&gt; : 앞으로 계획&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;3. Python과 Django 강의&lt;/h3&gt;

&lt;h4&gt;개요&lt;/h4&gt;

&lt;p&gt;2014년 12월 4일부터 2015년 1월 31일까지 &lt;a href=&quot;http://www.fastcampus.co.kr&quot;&gt;패스트캠퍼스&lt;/a&gt;에서 Python과 Django를 이용해 &lt;a href=&quot;http://www.fastcampus.co.kr/camp_wpa/&quot;&gt;웹서비스를 개발하는 커리큘럼으로 강의&lt;/a&gt;를 했다. 나는 이론 부분을, 함께 강의한 고빈섭님은 실습 부분을 담당했고, 김구영님은 조교로 강의를 도와주셨다.&lt;/p&gt;

&lt;p&gt;패스트캠퍼스에는 &lt;a href=&quot;http://www.fastcampus.co.kr/camp_wpb/&quot;&gt;웹 프로그래밍 입문&lt;/a&gt; 과정이 있는데, 내가 강의를 맡은 &lt;code&gt;웹 서비스 개발&lt;/code&gt; 과정은 입문 과정의 후속 과정이다. 그래서 초기 교육 과정 이름은 가칭 웹 프로그래밍 중급이었다가 실전 웹 서비스 개발에 초점을 맞추어 교육 과정 이름이 웹 서비스 개발로 바뀌었다.&lt;/p&gt;

&lt;p&gt;패스트캠퍼스에서 내게 제안한 중급 과정 강의를 수락한 동기는 집필이었다. 내가 프로그래머로 전업을 결심하기 전에 한 출판사로부터 집필 제안을 받아서, 몇 몇 개발자에게 의견을 구하고 Django 입문 강좌의 후속 강좌인 &lt;a href=&quot;http://blog.hannal.com/category/start-with-django-webframework/&quot;&gt;날로 먹는 Django 웹프레임워크&lt;/a&gt; 강좌 연재를 시작하면서 집필을 준비하고 있었다. 하지만 목차를 구상하는 게 쉽지 않아 좀처럼 진도를 나가지 못하고 있던 차에 패스트캠퍼스로부터 제안을 받은 것이다.&lt;/p&gt;

&lt;h4&gt;교육 재료, 환경&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;프로그래밍 재료 : Python 2.7, Django 1.7&lt;/li&gt;
&lt;li&gt;교재 재료 : 수강생 교재는 IPython으로 작성, 강사 발표는 Apple Keynote로 작성&lt;/li&gt;
&lt;li&gt;소통 공간 : 페이스북 비공개 그룹&lt;/li&gt;
&lt;/ul&gt;

&lt;h4&gt;강의 준비 과정&lt;/h4&gt;

&lt;p&gt;교육 과정이 시작되기 전에 나부터 교육할 필요가 있었다. 경험이나 직관으로 알던 것에서 그치지 않고, 제대로 설명하여 정확히 이해시켜야 하기 때문이다. 더구나 나는 입문 과정을 강의하는 게 아니기 때문에 명확하게  이해시키는 걸 넘어 더 깊은 내용을 설명할 줄 알아야 했다.&lt;/p&gt;

&lt;p&gt;곧바로 여러 Python 책과 공식 문서로 공부했다. 한창 &lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;편의점 프로젝트&lt;/a&gt;를 진행하던 시기였기 때문에 내 서재 책상엔 개발 관련 책 대여섯 권이 늘 펼쳐져 있었고, 웹브라우저엔 관련 자료에 대한 탭이 스무 개 이상 열려 있었다. 한 달 동안 책 다섯 권을 정독하고, 모든 예제를 실습하였다.&lt;/p&gt;

&lt;p&gt;그 다음 공부 주제는 Django로 잡았다. 내가 Django를 얼마만큼 제대로 알고 있는 지 파악해야 해서 Django를 이용해 인스타그램 같은 웹 서비스를 서로 다른 구현 방법과 구조로 세 번 만들었다. 그 중 한 버전은 블로그에 연재 중인 강좌에 사용하고&lt;sup id=&quot;fnref1&quot;&gt;&lt;a href=&quot;#fn1&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, 다른 한 버전은 강의 실습용으로 정했다. 그러고나서 Django 공식 문서를 보며 하나 하나 뜯어보고 다듬었는데, 각 기능마다 다른 사람이 구현한 방법을 웹에서 찾아다녔고, 구현 방법이 다른 경우 Django 소스를 열어서 Django의 작동 방식이나 의도를 분석했다. 이 과정에 약 4주가 걸렸고, Django 소스 코드 중 많은 부분에 대해 리뷰 아닌 리뷰를 두 차례 했다.&lt;/p&gt;

&lt;p&gt;마지막으로 Django 릴리즈 노트와 &lt;a href=&quot;https://github.com/django/django/commits/master&quot;&gt;Django의 master 브랜치&lt;/a&gt;에 쌓인 commit들을 훑으며 주목할만한 변화를 찾아 보았다. Django 1.0 이후로 Django를 사용하지 않아서 주요 변동 이력을 알지 못했기 때문이다.&lt;/p&gt;

&lt;p&gt;학습을 일단락하고 강의를 준비했다. 나는 markdown 문서 형식을 애용하지만, &lt;a href=&quot;http://ipython.org/&quot;&gt;IPython&lt;/a&gt;으로 교재를 만들어 보기로 했다. IPython은 2014년 초에 회사 개발 프로젝트에 도입하면서&lt;sup id=&quot;fnref2&quot;&gt;&lt;a href=&quot;#fn2&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 처음 접했는데, 상상력을 일으키는 재밌는 도구라 여겨왔다. 프로젝터에 띄울 강의 자료도 IPython으로 작성하려 했지만, 가독성이 좋지 않아 Apple Keynote로 작성하기로 했다.&lt;/p&gt;

&lt;h4&gt;강의 과정&lt;/h4&gt;

&lt;p&gt;첫 수업에서 나는 무척 당황했다. 여러 수강자가 예상보다 내 강의를 어려워했기 때문이다. 입문 단계는 뗀 사람을 대상으로 하는 커리큘럼이니 입문서나 자료에 나오는 내용에서 그치지 않고 좀 더 이론 부분을 다뤘는데, 일부 수강자를 보니 무척 혼란스러워 하는 표정이었다. 가령, Python에서 모든 데이터는 객체라는 내용을 설명할 때, &lt;strong&gt;Python에서 객체가 무엇인지&lt;/strong&gt; 설명했다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;모든 데이터는 객체(object)

&lt;ul&gt;
&lt;li&gt;객체 구조 : 신원(identity), 타입(type, class), 값(value)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;number = 1&lt;/code&gt;에서 &lt;code&gt;number&lt;/code&gt;는 신원, &lt;code&gt;1&lt;/code&gt;은 값, 이 값이 할당된(assigned) 객체의 타입은 &lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;모든 객체의 조상은 &lt;code&gt;object&lt;/code&gt;이며, &lt;code&gt;type&lt;/code&gt;은 모든 타입의 조상. &lt;code&gt;object&lt;/code&gt;는 &lt;code&gt;type&lt;/code&gt;의 인스턴스이며, &lt;code&gt;type&lt;/code&gt;은 &lt;code&gt;object&lt;/code&gt;의 하위 클래스. &lt;code&gt;type&lt;/code&gt;은 자기 자신에 대한 &lt;code&gt;type&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;동적 형(type) 변환 : 객체의 타입이 변하는 게 아니라 객체의 신원이 가리키는(reference) 대상(값)이 바뀌는 것.&lt;/li&gt;
&lt;li&gt;변수, 즉 신원 자체는 객체나 값이 아니다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;del&lt;/code&gt;문은 객체를 지우는 것이 아니라 객체 참고 관계를 끊는 것.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 == True&lt;/code&gt;와 &lt;code&gt;1 is True&lt;/code&gt;의 차이

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;True&lt;/code&gt;의 값은 &lt;code&gt;1&lt;/code&gt;이고, &lt;code&gt;False&lt;/code&gt;의 값은 &lt;code&gt;0&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;값 비교는 &lt;code&gt;==&lt;/code&gt; 연산자로, 신원 비교는 &lt;code&gt;is&lt;/code&gt; 연산자로 평가.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하지만, 일부 수강자가 “객체”라는 것 자체를 생소해 하거나 잘 모르는 상황이었다. 그들 입장에선 내가 어렵게 강의를 준비하고 설명한 것이었고, 결국 미리 준비한 강의 자료와 교재를 전면 수정해야 했다.&lt;/p&gt;

&lt;p&gt;커리큘럼은 이론 부분과 실습 부분으로 구성했고, 나는 이론을 담당했다. 그러다보니 실습할 내용에 대해 이론 부분을 여러 방면으로 준비했다.&lt;/p&gt;

&lt;p&gt;가령, Django의 모델 필드형 중 &lt;code&gt;TextField&lt;/code&gt;를 Django 공식 문서에서는 큰(large) 텍스트를 담는 필드라고 설명하는데, 나는 SQLite 3는 &lt;code&gt;text&lt;/code&gt;형으로 약 1기가 바이트, PostgreSQL은 길이 제한이 없는 &lt;code&gt;text&lt;/code&gt;, MySQL은 &lt;code&gt;longtext&lt;/code&gt;형으로 약 4기가 바이트, Oracle은 8~12테라 바이트를 담는 &lt;code&gt;NCLOB&lt;/code&gt;형이라고 설명하는 것이다. 수강자가 얼마나 긴 문자열을 담느냐는 질문을 하는데 &lt;code&gt;CharField&lt;/code&gt;보다 긴, 게시판의 글 본문에 쓸만큼 긴 문자열이라고 대답하고 싶진 않았다.&lt;/p&gt;

&lt;p&gt;또는, 흥미롭게 구현된 Django 기능이 있는 경우, 그 기능이 작성된 Django 소스를 직접 설명하기도 했다. 예를 들어, Django의 &lt;code&gt;settings&lt;/code&gt;는 수강자들이 재밌다고 느낄만한 Python 기법이 잘 녹아있는 모듈이라서 가볍게 훑고 지나가지 않고 동작하는 방식에 대해 설명했다. Django 자체보다는 Python 기법에 대한 내용이다보니 다른 Django 자료에서는 잘 다루지 않는 내용이고, 내 강의를 듣기 때문에 접하는 내용이었다. 가능하면 이런 내용을 다루려 했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2015/03/django_conf_settings.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;수업은 4회차부터 강의 목표와 계획을 완전히 수정했다. 수강자들이 수업 당시에는 수업 내용을 완전히 이해하지 못하더라도 교재를 보며 복습하여 언젠가는 이해하는 것으로 목표를 바꿨다. 일명 “교재라도 남기자”. 그래서 교재도 최대한 서술형으로 풀어서 문장을 작성했다. 마치 내가 교재를 강의 원고로 삼아 그대로 읽는 것처럼 작성했고, 발표용 슬라이드는 목차처럼 활용하도록 작성했다. 그러다보니 매 수업에 사용하는 교재는 100여 장을 넘기곤 했다. 한 수강자는 우스개소리로 100만원이 넘는 Python + Django 책이라고 말하기도 했다.&lt;/p&gt;

&lt;p&gt;서술형 교재는 IPython으로 작성했다. 의도와 목표는 교재를 IPython으로 열어서 코드를 교재 안에서 직접 실행(run)하고 실습하는 상호작용 교재로 활용하도록 하는 것이었지만, 의도대로 활용되는 것 같진 않았다. 그래서 소스 문법 강조가(highlighting) 잘 된 문서로라도 활용하였고, 실제로 교재도 IPython 파일을 HTML 파일로 내보낸(export) 문서도 함께 배포하였다.&lt;/p&gt;

&lt;p&gt;실습을 본격 시작한 수업부터는 매 수업에 진행한 전체 소스 코드도 배포하였다. 그러니까, 4회 수업까지 진행한 소스 코드, 5회 수업까지 진행한 소스 코드를 구분하여 매 수업 때 마다 배포한 것이다. 처음엔 &lt;code&gt;git&lt;/code&gt;으로 관리하여 각 수업에 진행한 소스 이력에 tag를 달아서 접근하도록 하려 했다. 하지만, 이 교육 과정으로 입문한 것이나 마찬가지인 수강자는 새로운 개념이 등장할 때마다 힘들어해서 git을 수업에 도입하진 않았다.&lt;/p&gt;

&lt;p&gt;이렇게 교재를 만들어 배포하다보니 일단 수업엔 참여해서 최대한 듣고 따라오고, 수업 이후엔 내가 작성한 소스 코드를 기반으로 실습하거나 복습하고, 설명은 교재를 읽는 사례가 나타났다. 수강자 나름대로 적응하고 수업과 교재를 활용하는 것이다.&lt;/p&gt;

&lt;p&gt;점차 강의에 익숙해지다보니 분량 조절이 맞아서 수업 시간 운용도 안정되었다. 교재를 만드는 건 여전히 힘들었지만, 강의 진행은 한결 편안해졌다. 수강자 개개인을 알아가면서 강의와 교재에 예제나 보충 설명을 반영하기도 했다. 글로 강좌를 연재하는 것과는 다른 매력이었다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://getbootstrap.com/&quot;&gt;Bootstrap&lt;/a&gt;을 적용하고, &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku&lt;/a&gt;에 개발한 프로젝트를 배치(deployment)하는 것으로 전체 강의를 마쳤다. Heroku 무료판은 무척 느린데다 국내에서 사용 사례가 많지 않아서 Heroku에 서비스를 배치하는 것에 주제를 맞추지 않고, 프로젝트를 배치하고 배포하는 과정을 이해하는 데 맞추었다. 즉, Heroku가 자동으로 처리해주는 부분은 무엇이고, Amazon Web Service 등을 이용할 경우 어느 부분까지 사람이 해야 하며, 어떻게 하는 것이 좋은 지 설명하였다.&lt;/p&gt;

&lt;h4&gt;우여곡절&lt;/h4&gt;

&lt;p&gt;초반 3주는 무척 힘든 시간을 보냈다. 강의 자료와 교재를 전면 재작성 하다보니 매주 시간에 쫓겼고, 회사 업무도 마감에 임박한 상황이라 정신 없는 나날이었다. 무엇보다도 내가 과의욕 상태이다보니 난이도나 분량을 조절하지 못하여 스트레스를 자초한 탓이 가장 컸다.&lt;/p&gt;

&lt;p&gt;개인 사정으로 수업을 목요일과 토요일로 잡은 것도 좋지 않았다. 수업 간격이 좁다보니 수강자는 복습할 시간 여력이 없었고, 매 수업마다 100여 장이 넘는 교재를 작성하는 나 역시 수업 자료를 만들 시간이 부족했다. 특히 초반 2주는 주말에도 내 수업이 잡혀있다 보니 밤샘하기 일쑤였다.&lt;/p&gt;

&lt;p&gt;실습 환경을 맞추어 예외 상황을 피하려는 목적으로 VirtualBox에 Ubuntu를 가상으로 설치한 건 득보다는 실이 컸다. 대다수가 VirtualBox에 Ubuntu를 설치하는 것에서부터 난관에 부딪혔고, 너무 느리게 동작하여 답답했다. 또, 시간이 부족하여 Linux 사용법에 대해서는 전혀 다루지 않다보니 디렉터리 이동과 같은 쉘 사용 기초를 어려워하는 수강자도 있었다. 그에 반해 한 수강자는 끝까지 Windows에서 개발과 실습을 했는데, 자잘한 문제에 부딪혔지만 그래도 실습 전 과정을 무사히 치러내 다행스러우면서도 다소 허무하기도 했다. 난 Debian 계열 Linux를 좋아하지만, 실제로는 개발은 Mac OS X에서 하고 실 서비스는 Redhat 계열 Linux에서 하다보니 나 조차도 강의 진행에 시행착오를 겪기도 했다.&lt;/p&gt;

&lt;p&gt;강의에 대해서도 고민이 많았다. 나는 &lt;a href=&quot;http://www.slideshare.net/yongho&quot;&gt;하용호&lt;/a&gt;님의 발표나 강의를 좋아하여 그의 강의 방식을 분석하고 좇으려 했지만, 교재 작성하는 데 시간에 쫓겨서 흉내조차 내지 못 했다. “교재라도 남기자”로 강의 계획을 변경한 요인엔 내 강의 운영이 부족한 탓도 있다.&lt;/p&gt;

&lt;p&gt;수강자들마다 프로그래밍 소양이나 수준이 상당히 다르다보니 수강자가 할 만한 질문이나 겪을만한 오류 상황을 최대한 폭넓게 예측하고 준비하는 것도 힘들었다. 그런 강의 준비 과정에서 &lt;a href=&quot;https://github.com/django/django/compare/master...hannal:ticket_24181&quot;&gt;number format의 구분자 문자열이 뒤집히는 Django의 버그&lt;/a&gt;를 발견해 Django 프로젝트에 소스를 제출하는 즐거운 경험을 했지만&lt;sup id=&quot;fnref3&quot;&gt;&lt;a href=&quot;#fn3&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;, 강의 준비 자체는 무척 고되었다. 실제로 준비한 강의 자료 대부분은 수업 시간이 부족하기도 하고 수강자가 질문하지 않아서 활용되지 못하였다.&lt;/p&gt;

&lt;h4&gt;정리&lt;/h4&gt;

&lt;p&gt;초반 혼란기를 극복한 60% 수강자는 마지막 수업까지 남아 함께 했다. VirtualBox에 Ubuntu Linux를 설치하면서 Linux를 제대로 접한 한 수강자는 아예 자신의 랩탑에 Linux를 설치하여 다루었고, 굉장히 사소한 오타나 실수로 Python 인터프리터 오류를 일으켜 어쩔 줄 몰라하던 수강자는 내가 힌트를 주는 것만으로도 문제 원인을 파악해 스스로 해결할만큼 성장했다. 놀랍고 기뻤다.&lt;/p&gt;

&lt;p&gt;잔존율 50%를 목표로 두었는데 예상보다 높은 잔존율을 달성한 점도, 질문 수준이 나날이 높아진 점도 보람찼다. 질문과 답변이 왕성하게 오간 교육 과정이라는 패스트캠퍼스측 피드백도 기분 좋았다. 누군가 성장하는 데 기여하는 건 정말 뿌듯하다. 그리고, 다른 이가 성장하도록 돕는 과정에서 나 역시 성장하는 것도 좋은 경험이다.&lt;/p&gt;

&lt;p&gt;곧 &lt;a href=&quot;http://www.fastcampus.co.kr/camp_wpa/&quot;&gt;웹 서비스 개발 2기&lt;/a&gt;를 시작한다. 1기 때 구축한 수업 자료도 있고 내 강의량을 좀 줄였기에 1기 때에 비해 좀 더 수월하길 바라본다.&lt;/p&gt;

&lt;p&gt;아참, 애초 강의의 목적이었던 집필에 대해 조금 언급하자면, 목차 작업을 얼추 마쳐가고 있다. :)&lt;/p&gt;

&lt;hr&gt;

&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;

&lt;li id=&quot;fn1&quot;&gt;
&lt;p&gt;이 말은 연재 중인 강좌에 필요한 기반 마련은 진작 끝냈다는 뜻이다. 단지 너무 바빠서 강좌 글 자체를 작성하지 못하고 있다.&amp;nbsp;&lt;a href=&quot;#fnref1&quot; rev=&quot;footnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn2&quot;&gt;
&lt;p&gt;당시 우리 회사 CTO이자 공동창업자인 Spike^ekipS님이 도입했는데, IPython을 비롯해 내가 접한 개발 도구나 라이브러리, 기술 상당 수는 그가 알려준 것이며, 코드도 그에게서 영향을 받았다. 개발자로서 내게 영향을 준 사람은 두 명(Spike^ekipS, cpascal)인데, 두 사람 모두 뛰어난 해커이다.&amp;nbsp;&lt;a href=&quot;#fnref2&quot; rev=&quot;footnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;li id=&quot;fn3&quot;&gt;
&lt;p&gt;Django 1.8판에 반영되었다.&amp;nbsp;&lt;a href=&quot;#fnref3&quot; rev=&quot;footnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;

&lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 09 Mar 2015 04:33:40 +0900</pubDate>
        <link>http://blog.hannal.com//2015/03/devlife-s1-04/</link>
        <guid isPermaLink="true">http://blog.hannal.com//2015/03/devlife-s1-04/</guid>
        
        <category>Python</category>
        
        <category>SMTP</category>
        
        <category>Jinja2</category>
        
        <category>Celery</category>
        
        <category>Mailjet</category>
        
        <category>Sentry</category>
        
        <category>Upstart</category>
        
        
        <category>devlife</category>
        
      </item>
    
      <item>
        <title>개발 생활 - 3</title>
        <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-01/&quot;&gt;개발 생활 - 1&lt;/a&gt; : PDF 문서 생성 서버&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;개발 생활 - 2&lt;/a&gt; : 연산된 데이터 수집 작업자&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-03/&quot;&gt;&lt;code&gt;개발 생활 - 3&lt;/code&gt;&lt;/a&gt; : 전자우편 알림 서버&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;개발 생활 - 4&lt;/a&gt; : Python과 Django 강의&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-05/&quot;&gt;개발 생활 - 5&lt;/a&gt; : 공부 자료&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-06/&quot;&gt;개발 생활 - 6&lt;/a&gt; : 앞으로 계획&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;2. 개발 프로젝트&lt;/h3&gt;

&lt;h4&gt;2-3. 전자우편 알림 서버&lt;/h4&gt;

&lt;h5&gt;개요&lt;/h5&gt;

&lt;p&gt;전자우편 알림 서버는 특정 사건(event)이 발생하면 관련된 사람에게 그 사건에 대해 알리는 역할을 한다. 가령, K와 C영업인이 한날이라는 고객을 담당하고 있는데, C담당자가 고객과 영업 관련 일정을 잡을 경우, K담당자에게도 이에 대한 내용을 전자우편으로 안내하는 것이다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;요구사항

&lt;ol&gt;
&lt;li&gt;사건이나 상황(event)이 발생하면, 이와 관련된 담당자나 팀에 즉시 전자우편으로 그 내용을 보낸다.&lt;/li&gt;
&lt;li&gt;비밀번호 찾기 등 고객 홈페이지에서 발생하는 안내나 통지 행위도 처리한다.&lt;/li&gt;
&lt;li&gt;여러 상황에 처한 고객에게 상황에 맞는 전자우편을 자동으로 보낸다.

&lt;ul&gt;
&lt;li&gt;예) 특정 기간 이상 접속하지 않은 고객에게 서비스 이용 안내와 매물을 추천&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;내가 정한 추가 목표치

&lt;ul&gt;
&lt;li&gt;Python 3로 작성한다.&lt;/li&gt;
&lt;li&gt;프로그래밍 언어나 라이브러리, 프레임워크를 이전(migration)할 가능성을 염두에 두고 구조를 짠다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/&quot;&gt;PEP 8&lt;/a&gt;을 최대한 지킨다.&lt;/li&gt;
&lt;li&gt;병렬로 작업(알림 처리)을 수행한다.&lt;/li&gt;
&lt;li&gt;Unittest를 작성한다.&lt;/li&gt;
&lt;li&gt;오류 내역을 효율성 있게 관리한다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;개발 환경&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;언어 : Python 3.4, Go 1.3&lt;/li&gt;
&lt;li&gt;사용 라이브러리, 프레임워크

&lt;ul&gt;
&lt;li&gt;ORM : &lt;a href=&quot;http://www.sqlalchemy.org/&quot;&gt;SQLAlchemy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;반복 예약과 분산 처리 : &lt;a href=&quot;http://www.celeryproject.org/&quot;&gt;Celery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;템플릿 : &lt;a href=&quot;http://jinja.pocoo.org/&quot;&gt;Jinja2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;오류 내역 관리 : &lt;a href=&quot;http://www.getsentry.com&quot;&gt;Sentry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PEP 8 검사 : &lt;a href=&quot;https://pypi.python.org/pypi/flake8&quot;&gt;Flake 8&lt;/a&gt;, &lt;a href=&quot;https://github.com/SublimeLinter/SublimeLinter3&quot;&gt;SublimeLinter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;HTTP 처리 : &lt;a href=&quot;http://docs.python-requests.org/en/latest/&quot;&gt;Requests&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;개발 과정&lt;/h5&gt;

&lt;p&gt;먼저 이름부터 붙였다. Mailer라는 비공식 이름이 통용되었지만 좀 더 일상과 대중에 친숙한 단어인 postman이라 프로젝트 이름을 붙였다. 보이지 않는 곳에서 나대지 않고 조용히 일하는 느낌이 들도록 머릿글자도 소문자로 표기했다.&lt;/p&gt;

&lt;p&gt;작동 흐름은 간단했다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;알림 전자우편

&lt;ol&gt;
&lt;li&gt;전자우편 발송 요청(request)을 API Server가 받으면 각 요청을 발송 대기함에 쌓음.&lt;/li&gt;
&lt;li&gt;발송 작업자(worker)가 대기함에 있는 발송 대상을 가지고 와서 전자우편 발송 서비스에 전달.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;개인 또는 그룹을 대상으로 하는 소식지(newsletter)

&lt;ol&gt;
&lt;li&gt;일정 주기 마다 소식지 주제 별 수신자를 수집(build).

&lt;ul&gt;
&lt;li&gt;예) 가입 후 일정 기간 동안 로그인을 안 한 이용자들에게 서비스 안내 전자우편 발송.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;수신자 그룹을 전자우편 발송 서비스에 생성.&lt;/li&gt;
&lt;li&gt;생성한 수신자 그룹으로 전자우편 발송.&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SMTP 서버를 직접 구축하진 않기로 했다. 개발팀에서 프로그래머는 개발과 운영, 관리를 수행하고 있는데다 여러 개 제품이 이미 운영되고 있었기 때문에 되도록 관리할 대상을 줄여야 했기 때문이다. 그래서 전자우편 발송 서비스를 이용하기로 하고, 몇 개 업체를 검토한 끝에 &lt;a href=&quot;https://www.mailjet.com&quot;&gt;Mailjet&lt;/a&gt;을 이용하기로 결정했다. API도 잘 만들어져 있고, SMTP를 제공하며, 이미 쓰고 있는 지인이 소개해주어 무료 서비스를 사용해봤는데 기대만큼 만족스러웠다.&lt;/p&gt;

&lt;p&gt;또한, 고객 지원도 아주 빠르고 친절했다. 예를 들어, 무료 서비스는 한 달에 발송 가능한 전자우편 개수가 무척 적게 제한되어 있는데, 이 개수를 모르던 나는 몇 백 개째부터는 전자우편이 발송이 안 되고 대기 상태에 머물러있자 이것 저것 설정을 변경하며 방황하고 있었다. 그러자 놀랍게도 몇 십 분 후에 대시보드 페이지에 도움이 필요하느냐는 안내 버튼이 출력되었고, 이 버튼을 눌러 실시간 대화를 나누어 문제를 파악하고 처리할 수 있었다. 그때가 한국 시간으로 14~15시 경이었기에 꽤 놀랐다. 비용도 한 달에 30,000건 발송하는 정도는 한 달에 약 9 USD이면 되는 수준이라 바로 유료 전환했다.&lt;/p&gt;

&lt;p&gt;postman 프로젝트는 여러 차례 구조를 세웠다 무너뜨리며 설계를 되풀이했다. 그렇다고 해서 처음부터 크게 구조를 잡은 건 아니고, 1차 버전은 특정 상황(event)이 발생하면 담당자에게 이에 대해 개별 전자우편을 보내어 알리는 기능만 개발하는 범위여서 확장하거나 변경될 여지를 두고 구조를 잡았다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;발송부(sender)

&lt;ul&gt;
&lt;li&gt;발송 서버에 연결하는 API&lt;/li&gt;
&lt;li&gt;일정 시간 마다 발송 대기함에서 대기 작업물 처리자(periodic worker)&lt;/li&gt;
&lt;li&gt;각 전자우편에 지정된 템플릿으로 전자우편 제목과 본문을 만드는 서식부&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;발송 대기함에 쌓는 기능부&lt;/li&gt;
&lt;li&gt;수신자 구성부(builder)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mailjet에서 &lt;code&gt;REST API&lt;/code&gt;로 개별 전자우편을 발송하는 API를 제공했지만, 발송 서버에 연결하는 부분은 SMTP로 처리하였다. 이 방식이 HTTP로 연결하여 요청하는 것보다 좀 더 빨랐다. 쌓인 전자우편을 여러 개 보내야 하는 경우가 생기는데, HTTP/1.x는 매 요청마다 Mailjet 서버에 연결하고 끊기를 되풀이한다. 그에 반해 SMTP는 연결을 유지한다.&lt;/p&gt;

&lt;p&gt;Python으로 SMTP는 &lt;code&gt;smtplib&lt;/code&gt; 모듈을 이용하여 간단하게 다룬다. 다만, 웹에 있는 대부분 예제는 Python 2용이어서 Python 3.4에서는 문제가 발생하는데, 원인은 패키지나 모듈 배치가 바뀐 탓이다. 다행히 Python 공식 문서에 &lt;a href=&quot;https://docs.python.org/3/library/email-examples.html&quot;&gt;email: Examples&lt;/a&gt;라는 문서에 아주 자세한 예제가 나와있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;편의점 프로젝트&lt;/a&gt;과는 달리 postman 프로젝트는 &lt;code&gt;Celery&lt;/code&gt;를 이용하여 일정 시간마다 지정한 작업이 진행되도록 하였다. &lt;a href=&quot;http://celery.readthedocs.org/en/latest/userguide/periodic-tasks.html&quot;&gt;Periodic Tasks&lt;/a&gt;를 이용했는데, &lt;code&gt;periodic_task&lt;/code&gt;라는 장식자(&lt;code&gt;decorator&lt;/code&gt;)를 사용했다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from datetime import timedelta

from celery.decorators import periodic_task

notify_staff_settings = {
    &amp;#39;notify_staff&amp;#39;: {
        &amp;#39;run_every&amp;#39;: timedelta(minutes=1),
    },
}

@periodic_task(**notify_staff_settings)
def notify_staff():
    pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;템플릿 엔진인 &lt;code&gt;Jinja2&lt;/code&gt;는 &lt;a href=&quot;http://www.djangoproject.com&quot;&gt;Django&lt;/a&gt;의 템플릿 문법과 유사하고, &lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-01/&quot;&gt;제안서를 PDF로 만드는 문서 서버&lt;/a&gt;를 만들면서 다뤄서 친숙했다. 다만, 템플릿 전체가 아니라 블록 단위로 내용을 가져오려고 하는 부분은 문서에 예제가 자세히 나오지 않아서 조금 애먹었다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;{% block subject %}
[공실] {{ building.name }}에 새로운 공실
{% endblock %}

{% block body %}
  {{ building.id }} - {{ product.id }}
  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이런 템플릿이 있는 경우, 전자우편 제목은 &lt;code&gt;subject&lt;/code&gt; 블록에 있는 내용을, 본문은 &lt;code&gt;body&lt;/code&gt; 블로에 있는 내용을 사용하는 것이다. 템플릿에서 전자우편 제목과 본문을 만들면 알림 전자우편 제목이나 본문 형식(format)이 바뀌어도 Python 애플리케이션 코드는 변동되지 않으므로 애플리케이션 서버를 재가동하지 않아도 되고, 템플릿이 읽히는 다음 작업 시기에 곧바로 변동 내역이 반영된다는 장점이 있다.&lt;/p&gt;

&lt;p&gt;Jinja에서 템플릿을 렌더링하면 템플릿 컨텍스트(변수나 필터 등)가 반영된 최종 결과물 문자열이 반환된다. 나는 이걸 &lt;code&gt;subject&lt;/code&gt; 블록 따로, &lt;code&gt;body&lt;/code&gt; 블록 따로 다루고 싶었고, 당연히(?) Jinja로 이런 처리가 가능하다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from jinja2 import (
    Environment,
    FileSystemLoader,
)

_template_engine = Environment(
    loader=FileSystemLoader(settings.TEMPLATE_PATH),
    trim_blocks=True,
)

_template = _template_engine.get_template(&amp;#39;test.html&amp;#39;)
_context = _template.new_context({
    &amp;#39;title&amp;#39;: &amp;#39;Hello world&amp;#39;,
})

email_subject = &amp;#39;&amp;#39;.join(_template.blocks[&amp;#39;subject&amp;#39;](_context))
email_body = &amp;#39;&amp;#39;.join(_template.blocks[&amp;#39;body&amp;#39;](_context))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;오류 내역은 벼르고 별렀던 &lt;code&gt;Sentry&lt;/code&gt;를 도입하여 관리했다. 그동안은 로그를 쌓거나 출력하여 문제를 추적했는데, 로그가 쌓이면 문제를 추적하기 불편했고, &lt;code&gt;traceback&lt;/code&gt; 정보가 제대로 나오지 않아 문제 파악도 힘들었다. Sentry 역시 전자우편 발송 서버와 마찬가지로 실 서버는 Sentry 회사가 제공하는 서비스를 이용하고, 개발 중에는 내 작업 PC에 직접 설치하여 관리했다. 사용법도 간단하다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from raven import Client as RavenClient

raven_client = RavenClient(SENTRY_APIKEY)

@raven_client.capture_exceptions
def notify_staff():
    pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;우여곡절&lt;/h5&gt;

&lt;p&gt;Mailjet에서 제공하는 &lt;code&gt;REST API&lt;/code&gt;로 개별 전자우편을 발송하는 과정에서 적지않은 시행착오를 겪었다. REST API를 다루려고 &lt;code&gt;Requests&lt;/code&gt; 라이브러리를 사용했는데 자꾸 요청이 Mailjet 서버로부터 거절되었다. &lt;code&gt;Curl&lt;/code&gt;을 이용하면 잘 작동하였다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;curl -X POST --user &amp;quot;$MJ_APIKEY_PUBLIC:$MJ_APIKEY_PRIVATE&amp;quot; \
    https://api.mailjet.com/v3/send/message \
    -F from=&amp;#39;Miss Mailjet &amp;lt;ms.mailjet@example.com&amp;gt;&amp;#39; \
    -F to=mr.mailjet@example.com \
    -F subject=&amp;#39;Hello World!&amp;#39; \
    -F text=&amp;#39;Greetings from Mailjet.&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이는 HTTP에서 &lt;code&gt;Post&lt;/code&gt; 방식으로 데이터를 보낼 때 컨텐트 타입을 &lt;code&gt;multipart/form-data&lt;/code&gt;로 보내는 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2388.txt&quot;&gt;RFC 2388&lt;/a&gt;를 따르는 것이며, 이를 Requests 라이브러리를 이용하여 다음과 같이 처리한다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;_res = requests.post(
    &amp;#39;https://api.mailjet.com/v3/send/message&amp;#39;,
    auth=(
        &amp;#39;$MJ_APIKEY_PUBLIC&amp;#39;,
        &amp;#39;$MJ_APIKEY_PRIVATE&amp;#39;
    ),
    data={
        &amp;#39;from&amp;#39;: &amp;#39;Miss Mailjet &amp;lt;ms.mailjet@example.com&amp;gt;&amp;#39;,
        &amp;#39;to&amp;#39;: &amp;#39;mr.mailjet@example.com&amp;#39;,
        &amp;#39;subject&amp;#39;: &amp;#39;Hello World!&amp;#39;,
        &amp;#39;text&amp;#39;: &amp;#39;Greetings from Mailjet.&amp;#39;,
    },
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;하지만, 무슨 이유에서인지 Mailjet쪽에서 발송을 거절했다. &lt;a href=&quot;http://www.getpostman.com/&quot;&gt;Postman&lt;/a&gt;이라는 HTTP 클라이언트로 보내도 잘 작동했는데, 유독 Requests로는 실패했다. 그래서 HTTP Header를 하나씩 까보니 Requests는 파일을 첨부하면 Curl 등 다른 소프트웨어와는 미묘하게 다른 HTTP Header를 만든다는 걸 발견했고, Mailjet은 이런 요청은 거부하는 민감한 동작을 했다. 어차피 SMTP를 이용해 보낼 계획이어서 SMTP로 직접 발송하여 문제는 해결했지만, 찝찝한 마음이 남았다. 현재는(2015년 3월 기준) 문제없이 발송된다.&lt;/p&gt;

&lt;p&gt;Celery를 사용하는 인터페이스 부분을 추상화하는 과정도 뜻대로 되지 않은 부분이 많았다. 언제든지 Celery를 걷어내고 다른 라이브러리를 사용해도 문제가 없도록 패키지와 모듈 구성을 구성하였는데, 문제가 발생했을 때 문제를 추적하기 불편하였고 추상화 한 것에 비해 실제 Celery를 사용하는 부분 인터페이스가 많지 않았다. 결국은 Celery 인터페이스 이름만 바꾼 것에 가까운 반쪽짜리 추상화가 되고 말았다. 어설픈 추상화는 안 하느니만 못 하다.&lt;/p&gt;

&lt;p&gt;Python 3를 사용하는 데엔 별다른 시행착오를 겪지 않았다. Python 3 기능을 그다지 깊게 사용하지 않기도 했지만, 지난 프로젝트부터 Python 3를 대비하고 준비한 게 도움이 됐다. 그리고, postman 프로젝트에 사용한 외부 라이브러리도 모두 Python 3를 지원했다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://spoqa.github.io/2012/08/03/about-python-coding-convention.html&quot;&gt;PEP 8&lt;/a&gt;을 도입하는 것도 무난했다. PEP 8 검사에 사용한 Flake8의 Sublime Text용 부가기능(plugin)이 Sublime Text 2에서 잘 작동하지 않아 엉겁결에 Sublime Text 3로 이전한 것 빼고는 별달리 어렵거나 힘든 상황은 맞이하지 않았다. &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/#maximum-line-length&quot;&gt;한 줄을 80열 미만으로 코드를 작성하는 것&lt;/a&gt;을 제외하면.&lt;/p&gt;

&lt;p&gt;Unittest는 만족스럽게 사용하진 못 했다. 딸 출산이 임박한 시기에 이르자 마음이 급해져 다시 원래 개발하던 방식으로 돌아가고 말았던 것이다. 결국 Unittest를 쓰지 않아 겪는 불편을 개발 막바지에 그대로 다시 겪었다.&lt;/p&gt;

&lt;p&gt;Linux에서 프로세스를 관리하는 &lt;code&gt;upstart&lt;/code&gt;용 프로세스 구동 스크립트를 작성하는 데 꽤 고생했다. 그동안 Linux의 init을 쓰거나 Python용 프로세스 관리 도구인 &lt;a href=&quot;http://supervisord.org/&quot;&gt;Supervisor&lt;/a&gt;를 써왔는데, &lt;a href=&quot;http://www.codeok.net/%EC%84%9C%EB%B2%84%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC%20%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94%20%EC%98%AC%EB%B0%94%EB%A5%B8%20%EB%B0%A9%EB%B2%95&quot;&gt;서버 프로세스를 관리하는 올바른 방법&lt;/a&gt;에 대한 글을 읽고 upstart를 사용하기로 했다. 그런데 AWS AMI에서 돌아가는 upstart는 상당히 오래된 버전이어서 웹에서 참고한 자료가 별 도움이 되지 않았다. 가령, &lt;code&gt;uid&lt;/code&gt;나 &lt;code&gt;gid&lt;/code&gt;, &lt;code&gt;chdir&lt;/code&gt; 같은 명령어가 동작하지 않았다. 워낙 간단한 스크립트여서 무작정 시도했는데, 동작하지 않아 결국 로그를 찍으며 문제를 해결했다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;script
  exec &amp;gt;/tmp/postman_sender.log 2&amp;gt;&amp;amp;1
  exec sudo -u ec2-user /bin/sh -c &amp;quot;/.../postman_run.sh&amp;quot;
end script
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;정리&lt;/h5&gt;

&lt;p&gt;postman 프로젝트는 코딩보다는 설계와 추상화, 그리고 외부 도구 연계에 시간을 많이 썼다. 그동안 Celery나 SQLAlchemy 등 도구의 단편만 다뤘는데, 이번 프로젝트를 진행하면서 좀 더 깊게 들여다보고 시험해 보았다.&lt;/p&gt;

&lt;p&gt;이번 프로젝트는 여러 모로 무척 바빠서 공부를 많이 하지 못 했다. 이 프로젝트에 사용한 기술의 하부 영역을 더 이해하려고 리눅스 시스템 프로그래밍(C언어)과 Python twisted를 공부하였지만, 다소 지지부진하게 진도가 나갔다.&lt;/p&gt;

&lt;p&gt;Go 언어로 작성한 코드는 Go 언어에 좀 더 친숙해진 정도 성과를 거두었다. 워낙 간단한 코드이기 때문이다. 나중에 시간을 내어 발송할 전자우편을 구성(build)하는 부분과 발송 부분을 분리하여 발송 부분을 Go 언어로 재작성하면 좋을 것 같다.&lt;/p&gt;
</description>
        <pubDate>Wed, 04 Mar 2015 22:05:40 +0900</pubDate>
        <link>http://blog.hannal.com//2015/03/devlife-s1-03/</link>
        <guid isPermaLink="true">http://blog.hannal.com//2015/03/devlife-s1-03/</guid>
        
        <category>Python</category>
        
        <category>SMTP</category>
        
        <category>Jinja2</category>
        
        <category>Celery</category>
        
        <category>Mailjet</category>
        
        <category>Sentry</category>
        
        <category>Upstart</category>
        
        
        <category>devlife</category>
        
      </item>
    
      <item>
        <title>개발 생활 - 2</title>
        <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-01/&quot;&gt;개발 생활 - 1&lt;/a&gt; : PDF 문서 생성 서버&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;&lt;code&gt;개발 생활 - 2&lt;/code&gt;&lt;/a&gt; : 연산된 데이터 수집 작업자&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-03/&quot;&gt;개발 생활 - 3&lt;/a&gt; : 전자우편 알림 서버&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;개발 생활 - 4&lt;/a&gt; : Python과 Django 강의&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-05/&quot;&gt;개발 생활 - 5&lt;/a&gt; : 공부 자료&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-06/&quot;&gt;개발 생활 - 6&lt;/a&gt; : 앞으로 계획&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;2. 개발 프로젝트&lt;/h3&gt;

&lt;h4&gt;2-2. 연산된 데이터 수집 작업자&lt;/h4&gt;

&lt;h5&gt;개요&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;http://www.rsquare.co.kr&quot;&gt;부동산 다이렉트&lt;/a&gt;의 데이터베이스엔 사무실이나 건물 정보가 많이 등록되어 있다. 각 사무실과 건물을 구성하는 속성도 세세하게 등록되고 관리되어, 많은 검색 조건을 조합해 고객이 원할만한 매물을 검색한다.&lt;/p&gt;

&lt;p&gt;그런데 검색 조건 중에는 별도 연산이 필요한 조건이 있다. 예를 들어, 300평짜리 사무실을 찾는다고 했을 때, 면적만 놓고 보면 다음과 같은 경우가 가능하다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;단일층 : 단일층이 300평인 경우.&lt;/li&gt;
&lt;li&gt;연층 또는 연속층 : 층이 분할되어도 되지만 층은 연속되어야 하는 경우.&lt;/li&gt;
&lt;li&gt;복수층 : 여러 층이어도 되고 층이 꼭 연속되지 않아도 되는 경우.&lt;/li&gt;
&lt;li&gt;분할층 : 한 층을 여러 사무실로 분할하였고, 이 중 1개 이상 사무실이 다른 층과 연속되는 경우.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;복수층이나 연층, 분할층인 경우, 몇 개 층까지 분할이어도 되는지, 즉 2~3개인데 연속층으로 총 300평인 사무실을 찾는 검색 조합도 가능하다.&lt;/p&gt;

&lt;p&gt;내가 두 번째로 맡은 프로젝트는 바로 연층이나 복수층을 빠르고 정확하게 검색하는 기능을 구현하는 것이었다. 이런 검색 기능은 SQL Query만으로 처리하기에는 연산 비용이 크다. 나는 SQL Query만으로 이런 검색을 아주 빠르게 처리하는 방법을 모른다.&lt;/p&gt;

&lt;h5&gt;개발 환경&lt;/h5&gt;

&lt;p&gt;내가 이 프로젝트를 맡겠다고 한 이유는 특정 검색을 위해 미리 계산된 데이터를 구축하고 이 구축한 데이터 안에서 검색하면 쉽고 빠르겠다는 생각이 떠올랐고, 이를 직접 실현하고 싶었기 때문이다. 결자해지.&lt;/p&gt;

&lt;p&gt;사무실이나 빌딩은 분야 특성상 데이터가 생성되거나 수정되는 빈도가 높진 않다. 더구나 부동산 다이렉트는 사람이 일일이 사무실이나 건물을 확인하여 허위 매물을 걸러내기 때문에 데이터 변화 빈도가 아주 높진 않다. 빈도가 높지 않다라는 말은 초 단위로 데이터가 수 백 수 천 개가 쌓이거나 변경되진 않는다는 뜻이다.&lt;/p&gt;

&lt;p&gt;이런 이유로 애초에 개발 언어는 Python으로 결정했다. DBMS 외 부분에서 연산을 Python이 하더라도 충분히 빠르고, 개발 생산성이 좋고, 무엇보다 내게 익숙한 언어이기 때문이다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;언어 : Python 2.7&lt;/li&gt;
&lt;li&gt;사용 라이브러리, 프레임워크

&lt;ul&gt;
&lt;li&gt;ORM : &lt;a href=&quot;http://www.sqlalchemy.org/&quot;&gt;SQLAlchemy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;반복 예약 처리 : &lt;a href=&quot;https://pypi.python.org/pypi/schedule&quot;&gt;schedule&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;schedule&lt;/code&gt;은 Linux나 Unix의 &lt;code&gt;crontab&lt;/code&gt; 역할을 하는 라이브러리이다. &lt;a href=&quot;http://www.celeryproject.org/&quot;&gt;Celery&lt;/a&gt;의 &lt;a href=&quot;http://celery.readthedocs.org/en/latest/userguide/periodic-tasks.html&quot;&gt;Periodic Tasks&lt;/a&gt; 기능을 채택할 지 고민하기도 했지만 일정 주기로 작업자를(worker) 호출해 정해진 작업(task)을 수행하는 정도에 쓰기엔 거창하다 생각했다. 직접 구현하기에도 간단한 기능이지만, 많은 사람이 이미 사용하여 검증된 &lt;code&gt;schedule&lt;/code&gt; 라이브러리를 도입했다.&lt;/p&gt;

&lt;h5&gt;개발 과정&lt;/h5&gt;

&lt;p&gt;이 프로젝트는 시작부터 확장성과 이전성(migration)을 고려했다. 이전 가능성은 Python 3로 이전하는 걸 염두에 두는 것이고, 확장성은 연층 검색 뿐만 아니라 다른 검색 조건에 대응하는 작업(task) 처리 구조로 만드는 것이다.&lt;/p&gt;

&lt;p&gt;프로젝트는 검색 편의를 돕는 역할이어서 편의점(convenient store)이라고 이름지었다. 그리고 각 구성물도 편의점과 연관된 용어를 썼다. 로직을 상상할 때 실제 사람이 매장에서 일하는 모습이 떠올라 재밌어서 지루하지도 않고 개념을 다루기에도 좋았다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;매장 : 검색 조건과 관련된 작업을 정의한 모듈(module).

&lt;ul&gt;
&lt;li&gt;점원 : 검색 데이터를 수집하고 연산하는 작업자(controller).&lt;/li&gt;
&lt;li&gt;창고 : DB 관련 작업을 처리하는 모델(model).&lt;/li&gt;
&lt;li&gt;본사 직원 : 검색용 데이터를 쌓은 테이블에서 데이터를 검색하는 SQL Query 인터페이스. API Server용이며 Go 언어로 작성.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;매장 관리자 : 신규 매장이 등록되면 가동하고, 기존 매장이 변동되면 그 내용을 반영하여 재가동하는 프로세스 관리자.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;난 연층 검색을 위한 데이터를 다루는 첫 번째 매장을 만드는 셈인데, 구조도 정해놓은 규칙으로 클래스와 설정 파일 등을 만들어 창고, 본사 직원으로 구성하고, 이 Python 패키지를 매장(&lt;code&gt;store&lt;/code&gt;) 디렉터리에 넣는다. 매장 관리자는 곧 이를 감지하여 메모리에 적재하여 매장을 개장하고 영업을 개시한다. 그래서 코드가 변경되더라도 편의점 프로세서는 중단되지 않고 계속 작업을 처리한다. 즉, 검색봇을 쉽게 추가하고 변경하면서도 무중단 서비스가 가능한 설계를 구상했다.&lt;/p&gt;

&lt;p&gt;이는 반만 구현해냈는데, 병렬 처리를 위한 구조로 만들지 않았기 때문이다. 게다가 신규 매장을 만드는 일 자체가 그 이후 없었기 때문에 결국 필요없는 작업을 하느라 일주일을 써버린 셈이 되었다. 소득이라면 연결과 분리(pluggable) 가능한 모듈을 어떻게 작성하고 구조를 잡아야 하는 지 고민하고 경험하여 다음 프로젝트에 도움이 됐다는 점이다.&lt;/p&gt;

&lt;p&gt;여러 층을 조합하여 면적을 산출하여 DB 테이블에 데이터를 넣는다면, 어떤 조합까지 연산하여 DB에 넣을 것인지 고민해야 한다. 연층은 기본이다. A건물에 3, 4, 6, 8, 9, 10층 사무실이 공실인 경우,&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3,4층&lt;/li&gt;
&lt;li&gt;8, 9층&lt;/li&gt;
&lt;li&gt;9, 10층&lt;/li&gt;
&lt;li&gt;8, 9, 10층&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 조합을 뽑아내어 면적 등을 합해야 한다. 하지만, 연속되지 않은 복수층은 난감했다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3, 6층, 3, 8층, 3, 9층, 3, 10층&lt;/li&gt;
&lt;li&gt;3, 4, 6층, 3, 4, 8층, 3, 4, 9층, 3, 4, 10층, ...&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;연속되지 않은 복수층은 이와 같이 조합 가능한 경우의 수가 무척 많다. 건물에 사무실이 많은 큰 건물인 경우 수 억 가지 조합이 발생했다. 회사에 등록된 전체 건물을 대상으로 계산해보니 수십 억 건이 넘는 조합이 나왔다. 각 조합이 DB의 항목(&lt;code&gt;row&lt;/code&gt;)이므로 “오, 나도 좀 큰 데이터 좀 다루는 건가!?”하는 시덥잖은 생각이 들기도 했다.&lt;/p&gt;

&lt;p&gt;실제로 갓 완공되어 20여 개 층이 임대 가능한 건물이 있었는데, 이 건물의 20개 사무실에 대해 조합 가능한 경우의 수는 263,644,104가지이다. 그리고, 공실이 30개 이상인 건물도 몇 개 있었다. 이런 경우(case)는 양이 너무 많아 시간이 오래 걸렸다. 느려서 Go언어나 C언어로 짜서 시간을 몇 십배 줄여봤지만, 수에는 어쩔 도리가 없었다. 결국, 연속되지 않은 복수층은 사전에 연산하여(pre-operated) 데이터 테이블에 넣는 방법 대신 매 질의(query) 때마다 연산하기로 했다.&lt;/p&gt;

&lt;p&gt;건물이나 사무실에 변동이 생기면 이를 감지하는 건 &lt;a href=&quot;http://www.mysqltutorial.org/mysql-triggers.aspx&quot;&gt;DBMS의 Trigger&lt;/a&gt; 기능으로 구현하려 했다. 지정한 이벤트가 일어나면 관련 내용을 트럭에 쌓아두고, 점원이 트럭에 쌓인 작업물을 꺼내어 연산하는 식이다. 여기서 트럭이란 Task queue를 의미한다. 하지만, &lt;a href=&quot;http://aws.amazon.com/ko/rds/&quot;&gt;AWS RDS&lt;/a&gt;에서 운영 중인 DB에서는 Trigger가 동작하지 않았다. &lt;a href=&quot;https://techtavern.wordpress.com/2013/06/17/mysql-triggers-and-amazon-rds/&quot;&gt;MySQL, Triggers and Amazon RDS&lt;/a&gt; 글에 따르면 가능하긴 한데, 내키진 않았다. 마침 그 시기에 데이터베이스와 관련된 문제, 다분히 사람의 실수로 큰 문제가 생길 뻔한 상황을 겪어서 운영 중인 데이터베이스에 안전한 설정이라도 변화를 주기 부담스러웠다.&lt;/p&gt;

&lt;p&gt;그래서 일정 시간마다 정보가 변경된 사무실을 검색하고, 있으면 그 사무실이 속한 건물의 검색 대상인 사무실들을 모두 가져와 연층을 연산하는 방식으로 구현 방법을 바꿨다. 건물에 속한 검색 대상 사무실을 모두 가져오는 이유는, 기존엔 연층 조합인 사무실인데 이 사무실이 계약되어 더이상 공실이 아닌 경우, 이 사무실과 연층으로 연결된 조합을 끊어야 하기 때문이다. 만약, 3, 4, 5층, 4, 5층 조합이 있는데 4층이 빠지면, 이 두 조합은 더이상 유효하지 않다.&lt;/p&gt;

&lt;p&gt;조합을 찾는 알고리즘은 Python에 이미 내장되어 있다. &lt;code&gt;itertools&lt;/code&gt; 모듈에 여러 함수가 있는데, 그 중에서 &lt;a href=&quot;https://docs.python.org/2/library/itertools.html#itertools.combinations&quot;&gt;combinations&lt;/a&gt;를 사용하면 건물에 속한 사무실을 조합 가능한 모든 경우를 한 줄로 산출해낸다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from itertools import combinations

_combinated = combinations((&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;,), 2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 코드를 수행하면 &lt;code&gt;_combinated&lt;/code&gt;엔 &lt;code&gt;[(&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;), (&amp;#39;a&amp;#39;, &amp;#39;c&amp;#39;), (&amp;#39;a&amp;#39;, &amp;#39;d&amp;#39;), (&amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;), (&amp;#39;b&amp;#39;, &amp;#39;d&amp;#39;), (&amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;)]&lt;/code&gt;이 이터레이션 객체로 할당된다. 편하긴 했는데, 같은 기능을 하는 코드를 Go언어와 C언어로 짤 때엔 알고리즘을 직접 구현해야 했다. 재밌긴 했지만, 알고리즘 문제(issue)는 어딘가 알고리즘스러운(?) 코드로 짜고 싶은 욕심이 생겨서 스트레스를 받게 된다. 왜냐하면 알고리즘 자체가 모든 걸 해결해주는 은총알이 아니기 때문이다.&lt;/p&gt;

&lt;p&gt;이 조합(&lt;code&gt;combinations&lt;/code&gt;)은 연속 여부와는 관계없이 조합하는 경우이다. 즉, 연층과 연속하지 않은 복수층 모두를 포함한다. 여기에서 연속층 조합은 따로 연산해야 한다. 그리고, 사무실이 언제나 한 층에 하나만 있진 않아서 다음과 같은 조합도 염두에 둬야 한다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;3층 전체&lt;/li&gt;
&lt;li&gt;401호, 402호, 403호, 405호&lt;/li&gt;
&lt;li&gt;501호&lt;/li&gt;
&lt;li&gt;6층 전체&lt;/li&gt;
&lt;li&gt;8층 전체&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 경우, 단순히 4, 5, 6층이 아니라 401호, 5, 6층이나 401, 402호, 5층과 같은 조합도 연층으로 연산해야 한다. 그리고, 지하는 층 숫자가 -1, -2와 같이 음수로 입력이 되어 있어서, 지하 1층, 1층, 2층과 같은 연속층은 층 숫자만으로는 연속되지 않는다. -1, 1, 2가 되기 때문이다.&lt;/p&gt;

&lt;p&gt;이런 저런 예외 상황을 고려하니 기존에 알려진 &lt;a href=&quot;http://ghebook.blogspot.kr/2010/10/permutation-combination.html&quot;&gt;순열(順列, permutation)과 조합(組合, combination)&lt;/a&gt; 알고리즘으로는 내게 필요한 조합을 도출할 수 없었다. 촌철살인 같은 알고리즘으로 멋지게 문제를 해결하고 싶었지만 결국 2중 for문으로 일일이 조합을 연산하여 해결했다.&lt;/p&gt;

&lt;p&gt;Python으로 검색용 사전 연산된 데이터를 탐색하고 구축하는 기능을 구현한 후, Go 언어로 작성된 API Server가 해당 DB 테이블에서 데이터를 질의(query)하는, 실제 검색하는 코드를 작성하는 단계로 넘어갔다. 수행은 다음 단계로 진행한다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;연층 데이터 테이블에서 요청받은 연층 조건에 해당하는 건물을 찾는다.&lt;/li&gt;
&lt;li&gt;이 건물 목록을 대상으로 다른 검색 조건으로 검색한다. (예 : 보증금, 임대료, 24시간 개방 여부 등)&lt;/li&gt;
&lt;li&gt;클라이언트에게 반환할 건물 항목마다 해당 건물의 연층 데이터를 추가한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JSON&lt;/code&gt;으로 반환한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;연층, 즉 사무실 연속 연결 관계를 미리 연산하여 각 조합을 DB 테이블에 넣어두었으니 당연히 1번 과정은 빠르게 처리돼서(평균 0.01 이하) 기존 검색 수행 속도에 별 영향을 주지 않았다. 만족스러웠다.&lt;/p&gt;

&lt;p&gt;약 한 달 동안 개발했다. 1주일은 분석하고 조사하는 데, 1주일은 Python으로 개발하는 데, 10여일은 테이블 구조를 변경하고 재구축하는 삽질하는 데, 나머지 며칠은 Go 코드 작성하는 데 썼다. 이후 한 차례 정도 고생하고, 자잘하게 손 보는 일은 있었지만, 대체로 사고없이 동작하고 있다.&lt;/p&gt;

&lt;h5&gt;우여곡절&lt;/h5&gt;

&lt;p&gt;미리 연산한 데이터를 구축하는 기능을 만들다보니 데이터 집합을 재구성하는 데 시간이 많이 소요되는 문제가 몇 번 있었다. 조합 하나를 처리하는 데 0.5초가 소요되는데, 순수 연산 시간 자체는 얼마 안 걸리고 대부분 DB I/O에 시간이 소요된다. 사무실이나 건물에 변동이 생겨서 해당 건에 대해서만 연층 정보를 DB에 반영하는 건 양이 많지 않아서 몇 초에서 몇 분 안에 처리가 끝나지만, 전체 연층 조합을 처음 구성하는 초기화 또는 전체 재구성을 하는 경우엔 시간이 너무 오래 걸렸다. 실제로 사소한 산술 오류가 생기거나 테이블 구조가 변경되어 전체 데이터를 재구성하는 경우가 몇 번 있었는데, 그때마다 몇 시간씩 재구성이 끝날 때까지 기다려야 했다.&lt;/p&gt;

&lt;p&gt;DB Commit 시기를 조정해보며 어떡해서든 DB I/O 시간을 줄이려 했지만, 병렬 처리를 하지 않는 이상 어쩔 수 없었다. 더도 말고 CPU Core 수만큼만 병렬 처리해도 시간은 크게 단축됐다. 하지만, 이번에도 나는 코드를 병렬 수행을 염두에 두지 않고 작성했다. 정확한 계산을 하려고 각 연산 과정을 잠가서(locked) 수행했고, SQLAlchemy도 처음 사용하다보니 세션이 꼬여서 DB 연결에 문제가 발생하기도 했다. 이 일을 계기로 동시성과 병렬성 문제를 직접 체험하였고, 이론으로 접하던 상황이나 해결책을 좀 더 이해하게 되었다. 역시 게임 규칙에 걸려서 얻어 맞으면 곧바로 게임 규칙을, 적어도 내게 고통을 야기하는 게임 규칙만큼은 빠르게 이해하는 법이다.&lt;/p&gt;

&lt;p&gt;연속되지 않은 복수층을 검색하는 기능은 예상보다 힘들고 어려웠다. DB에 모든 조합을 넣기엔 양이 너무 많아서 그때 그때 연산을 하려 했는데,&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;산술 연산이 생각보다 까다롭고&lt;/li&gt;
&lt;li&gt;이 산술 연산을 SQL Query문으로 표현하는 것이 어려웠다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;예를 들어, 두 개에서 여덟 개 층으로 250~400평에 해당하는 건물을 찾는다고 가정해보자. 32평씩 여덟 개 층 조합도 조건을 만족하고, 200평 두 개 층도 조건을 만족한다. 즉, 최소, 최대 층 개수와 최소, 최대 면적을 이용하면 된다.&lt;/p&gt;

&lt;p&gt;문제는 여기에 다른 조건이 추가되는 것이다. 이 조건에서 월 고정비가 2,000~3,500만원을 추가하면 연산이 복잡해진다. 실제로는 여기에 그치지 않고 보증금 조건도 추가된다. 조합이 다(many) 대 다(many) 대 다(many)로 연결되는데, 각 요소가 교집합(AND)이 아니라 차집합 연산도 필요하다. 교집합으로만 연산하면 검색 결과가 아주 적어지는데, 최대면적/최소층개수, 최소면적/최대층개수 등 그룹 중 어느 하나라도 조건을 만족하지 않으면 연관된 조건 전체가 성립되지 않기 때문이다. 즉, A건물이 32평씩 여덟 개 층이 있고 200평 두 개는 없으면 이 건물은 검색 대상이 돼야 하는데, 모든 조건을 교집합으로 연산하면 A건물은 검색 대상에서 빠지는 것이다. 그렇다고 이 둘을 합집합(OR)으로 연산해서도 안 된다. 보증금이나 월 고정비와 같은 다른 조건식과 조합할 때 조합 경우의 수가 너무 많아져서 연산하는 데 시간이 오래(몇 배에서 몇 십 배) 걸린다.&lt;/p&gt;

&lt;p&gt;이를 의사(pseudo) 코드로 작성했을 땐 비교적 간단하게 답을 찾았다. 문제는 SQL Query로 표현하는 것이었다. 몇 시간을 끙끙댔지만 결국 제대로 동작하는 Query문을 작성하지 못했다. 다행히 동료 개발자가 한 시간도 안 되어 문제를 해결해 주었다. &lt;code&gt;Union&lt;/code&gt;을 사용했는데, 생각보다 빠르게 수행되었다.&lt;/p&gt;

&lt;p&gt;여러 검색 조건이 조합된 복수층 검색을 구현할 때 겪은 어려움 중 하나는 검색 결과가 유효한 것인지를 판단하기 어렵다는 점이었다. SQL Query문을 조금 고치자 검색된 데이터가 달라졌는데, 매번 일일이 제대로 검색된 것인지 데이터를 확인할 수는 없었다. 하지만, 제대로 된 테스트 케이스를 만들지 않아서 “할 수는 없는” 그 일을 실제로 해야만 했다. 면적 조건은 만족하고 보증금 조건도 만족하고 월 고정비도 만족하는 것 같은데, 자세히 살펴보니 월 고정비에서 몇 만원 차이로 조건을 만족시키지 않는 경우가 있다. 이는 암산으로 유효한 결과인지 검증해서는 안 된다는 걸 뜻한다. 그렇다고 하나 하나 계산기를 두드리기엔 사람은 너무 느리다.&lt;/p&gt;

&lt;p&gt;검색된 결과에서 조건에 해당하지 않는 데이터를 찾는 건 그래도 낫다. 검색 결과에 포함되지 않는 수많은 데이터는 막막하다. 검색 결과에 포함돼야 하는데, 포함되지 않은 경우 대체 어떻게 이 사실을 알아내야 할까? 테스트 시나리오를 만들어서 검색될 수 밖에 없는 데이터를 대상으로 검색 조건을 돌리는 것이다.&lt;/p&gt;

&lt;p&gt;테스트 케이스를 작성하지 않아 고통이 증폭되고, 도저히 견딜 수 없겠다 싶은 시점 직전에 모든 문제를 해결했다. 아마 느리디 느리고 부정확한 사람의 연산 능력으로 검색 결과 데이터를 검증하는 일을 몇 번 더 했더라면 진행하던 일을 중단하고 테스트 케이스부터 작성했을 것이다.&lt;/p&gt;

&lt;h5&gt;정리&lt;/h5&gt;

&lt;p&gt;목표치는 모두 달성했다. 이 프로젝트 이후 나는 Python 3에 정착하였고, Python 2.7용으로 작성한 소스도 비교적 간단히 Python 3용 코드로 전환된다. 불필요한 사양이 좀 있긴 하지만, 어쨌든 확장성과 유연성이 있는 설계와 구조로 동작한다.&lt;/p&gt;

&lt;p&gt;이번 프로젝트를 진행하면서 전업 프로그래머가 된 이래 비로소 내가 하고 싶은 일과 만들고 싶은 일을 어떻게 해야할 지 방향을 잡았다. 이 프로젝트를 마치고 나는 곧바로 수학 공부를 중등 과정부터 다시 시작했으며, 알고리즘과 데이터 구조, 프로그램 구조 공부를 시작했다. 비동기와 병렬성, 그리고 데이터 처리도 물론 내가 공부할 분야이지만, 일단은 좀 더 여유를 두고 파기로 했다.&lt;/p&gt;

&lt;p&gt;기능에 대한 유닛 테스트가 필요하다는 건 생각만 했지 실제로는 잘 실천하지 않았는데, 데이터를 다루면서 유닛 테스트가 반드시 필요하다는 걸 절실히 느꼈다. 데이터 연산에 사소한 연산 변화를 주더라도 예측을 크게 벗어나는 경우가 많았고, 이를 사람이 직관으로 검증하는 건 효율이 대단히 떨어진다.&lt;/p&gt;

&lt;p&gt;기계가 할 일을 사람이 해서는 안 된다. 기계가 할 일은 기계가 잘 하도록 맡겨 두고, 사람은 사람이 잘하는 일에 집중해야 한다.&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Feb 2015 21:00:00 +0900</pubDate>
        <link>http://blog.hannal.com//2015/02/devlife-s1-02/</link>
        <guid isPermaLink="true">http://blog.hannal.com//2015/02/devlife-s1-02/</guid>
        
        <category>Python</category>
        
        <category>데이터 처리</category>
        
        <category>SQLAlchemy</category>
        
        <category>AWS RDS</category>
        
        <category>병렬 처리</category>
        
        <category>유닛 테스트</category>
        
        <category>검색</category>
        
        <category>선처리 데이터</category>
        
        
        <category>devlife</category>
        
      </item>
    
      <item>
        <title>개발 생활 - 1</title>
        <description>&lt;p&gt;지난 8월 중순부터 취미로 하던 프로그래밍을 전업으로 하고 있다. 그동안 세 개 제품을 투입(release)했고, 하나는 비공개 시험 운영 중이며, 약 두 달 동안 강의를 하기도 했다. 지난 6개월을 돌이켜 본다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-01/&quot;&gt;&lt;code&gt;개발 생활 - 1&lt;/code&gt;&lt;/a&gt; : PDF 문서 생성 서버&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;개발 생활 - 2&lt;/a&gt; : 연산된 데이터 수집 작업자&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-03/&quot;&gt;개발 생활 - 3&lt;/a&gt; : 전자우편 알림 서버&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;개발 생활 - 4&lt;/a&gt; : Python과 Django 강의&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-05/&quot;&gt;개발 생활 - 5&lt;/a&gt; : 공부 자료&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-06/&quot;&gt;개발 생활 - 6&lt;/a&gt; : 앞으로 계획&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;1. 전업 결심&lt;/h3&gt;

&lt;p&gt;2014년 7월에 프로그래머로 전직을 결심했지만 막막하기만 했다. 여러 언어와 도구, 분야를 검토한 끝에 Python을 주 프로그래밍 언어로, 관심을 두고 꾸준히 다룰 언어로는 Go 언어를 정했다. 기준은 내가 하고 싶고 만들고 싶은 것에 필요하고 내 취향이나 성향에 맞는 지 여부이며, 급여 등은 판단 기준에 넣지 않았다.&lt;/p&gt;

&lt;p&gt;그러다 8월 중순에 &lt;a href=&quot;http://www.rsquare.co.kr&quot;&gt;부동산 다이렉트&lt;/a&gt;라는 회사에 서버 프로그래머로 합류했다.&lt;/p&gt;

&lt;h3&gt;2. 개발 프로젝트&lt;/h3&gt;

&lt;h4&gt;2-1. PDF 문서 생성 서버&lt;/h4&gt;

&lt;h5&gt;개요&lt;/h5&gt;

&lt;p&gt;이 프로젝트는 서버에 저장된 데이터를 제안서로 만들고, 이 제안서를 PDF 문서로 생성하는 기능을 만드는 것이었다. 기존에 Go 언어로 만들어 사용하는 서버가 있었는데 다음 요구사항을 구현해야 했고, 이 기능 구현을 내가 맡은 것이다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;요구사항

&lt;ul&gt;
&lt;li&gt;여러 제안서를(PDF 파일) 하나로 묶어서 PDF 파일 하나로 만든다.&lt;/li&gt;
&lt;li&gt;DB에서 직접 데이터를 가져오던 기존 방식 대신 API Server에서 REST API로 데이터를 가져온다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;내가 정한 추가 목표치

&lt;ul&gt;
&lt;li&gt;웹 페이지에서 PDF 생성 버튼을 누르면 응답 화면을 먼저 보여주고, PDF 생성이 완료되면 따로 알려주어 사용성을 높인다.&lt;/li&gt;
&lt;li&gt;유연하고 빠르게 제안서 양식에 변화를 주어 생산성을 높인다.&lt;/li&gt;
&lt;li&gt;3주 안에 개발을 끝낸다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;개발 환경&lt;/h5&gt;

&lt;p&gt;제안서는 꽤 복잡한 구조(layout)였고 Google Map API도 사용해서 Javascript를 처리해야 했다. &lt;a href=&quot;http://wkhtmltopdf.org/&quot;&gt;wkhtmltopdf&lt;/a&gt;는 이런 복잡한 HTML를 PDF로 변환하는 데 가장 적합한 도구이다. Webkit 렌더러를 이용하여 웹브라우저가 HTML를 렌더링하는 방식으로 HTML 문서를 출력하고 이 문서를 PDF로 변환하기 때문에 우리에게 필요한 기능을 모두 제공했고, 이미 개발팀에서 사용하고 있기도 했다.&lt;/p&gt;

&lt;p&gt;하지만, wkhtmltopdf엔 PDF 파일들을 하나로 합치는 기능이 없다. 여러 도구를 살펴봤는데 &lt;a href=&quot;http://www.python.org&quot;&gt;Python&lt;/a&gt;용 라이브러리인 PyPDF 2가 적합했다. 그리고 내가 정한 추가 목표치를 달성하는 데에도 Python이 가장 적합했다. 그래서 PDF 문서 생성 서버는 Python을 이용해 새로 만들기로 결정했다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;언어 : Python 2.7&lt;/li&gt;
&lt;li&gt;사용 라이브러리, 프레임워크

&lt;ul&gt;
&lt;li&gt;웹 프레임워크 : &lt;a href=&quot;http://flask.pocoo.org/&quot;&gt;Flask&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PDF 병합 : &lt;a href=&quot;http://mstamy2.github.io/PyPDF2/&quot;&gt;PyPDF 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;백그라운드 처리 : &lt;a href=&quot;http://www.celeryproject.org/&quot;&gt;Celery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;웹 소켓 : &lt;a href=&quot;http://www.gevent.org/&quot;&gt;gevent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5&gt;개발 과정&lt;/h5&gt;

&lt;p&gt;막상 개발에 착수하자 시작부터 문제에 봉착했다. PyPDF 2는 wkhtmltopdf로 만든 PDF를 두 개 이상 병합하려 하면 &lt;code&gt;__WKANCHOR__&lt;/code&gt; 관련 오류가 발생하였다. wkhtmltopdf로 만든 PDF에 형성한 앵커의 ID가 PDF 마다 동일하게 만들어져서 이를 합칠 때 중복되어서(고유하지 않아서) 발생하는 문제 같다. wkhtmltopdf나 PyPDF 2 소스를 고쳐서 문제를 해결하려 했으나 시간이 여의치 않았다. 나는 여러 제안서를 HTML 문서 하나로 합치고, 이 합친 HTML 문서를 PDF로 변환하기로 했다. wkhtmltopdf에 여러 HTML 문서를 PDF 문서 하나로 병합해 생성하는 기능이 있긴 했으나, 결과물인 PDF 외양(layout)이 깨지는 문제가 발생하였다. 그리고, 백 개가 넘는 제안서를 하나로 합치는 상황을 터미널 콘솔에서 테스트하기 번거로웠다. 그래서 아예 하나로 합쳐진 HTML을 만드는 방법을 골랐다.&lt;/p&gt;

&lt;p&gt;API Server에서 제공하는 REST API로 데이터를 가져오는 건 &lt;a href=&quot;https://github.com/jcgregorio/httplib2&quot;&gt;httplib2&lt;/a&gt;를 이용했다. 대세인 HTTP 라이브러리인 &lt;a href=&quot;http://docs.python-requests.org/&quot;&gt;Requests&lt;/a&gt;를 사용하려 했으나 &lt;code&gt;HTTPS&lt;/code&gt; 통신이 잘 되질 않았다. 구현을 마친 나중에 안 사실이지만 이 문제는 HTTPS 인증서를 내가 잘못 사용해서 발생한 문제였다.&lt;/p&gt;

&lt;p&gt;API Server에서 가져온 데이터를 어떻게 구조화 할까 고민하다 &lt;a href=&quot;https://www.djangoproject.com/&quot;&gt;Django&lt;/a&gt;의 ORM을 흉내 내기로 했다. Django의 Model은 다음과 같이 데이터를 데이터베이스에서 가져온다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;building = Building.objects.get(id=3, status=&amp;#39;open&amp;#39;)

print building.name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;내가 만든 건 이런 모양이다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;building = Building.filter(id=3, {&amp;#39;status&amp;#39;: &amp;#39;open&amp;#39;})

print building.name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;데이터베이스를 사용하지 않고 오직 REST API로 데이터를 가져오기 때문에 굳이 ORM처럼 만들 필요는 없었다. 데이터 모델 스키마는 API Server의 문서에 잘 나와 있기 때문에 문서 서버에서 모델을 정의하지 않아도 무방했다. Django ORM을 분석하면서 많이 배우긴 했지만 프로젝트 관리 관점에서 보면 초과 사양으로 보였다. 하지만, 자잘한 수정 사항이 매우 빈번하게 발생하자 그 나름대로 기준과 일관성이 있는 인터페이스 덕에 유연하게 대응할 수 있었다.&lt;/p&gt;

&lt;p&gt;1차 요구사항을 구현하고 나서 사용성을 높이는 단계로 넘어갔다. PDF 생성은 적지 않은 시간이 소요되기 때문에 이용자가 웹 페이지에서 PDF 생성 버튼을 누르면 한참 기다려야 했다. 만약 100장짜리 제안서를 PDF로 생성하는 경우 30~40분을 기다려야 하며, HTTP/1.x 특성상 연결이 끊기거나(Timeout) 연결에 문제가 생길 가능성이 높아진다. 그래서 PDF 생성은 백그라운드에서 별도 작업자가 처리하고, 생성이 완료되면 푸시로 이용자에게 알려주는 기능을 구현하기로 했다.&lt;/p&gt;

&lt;p&gt;Celery를 이용해 백그라운드로 처리하는 기능은 구현하긴 쉬웠다. 하지만, PyPDF 2의 PDF 병합 문제로 병합할 개별 PDF 문서를 분산해서 처리하지 않았기 때문에 비동기로 백그라운드에서 PDF 를 생성하는 역할로만 활용했다.&lt;/p&gt;

&lt;p&gt;웹 브라우저가 웹 소켓을 열어 웹 소켓 서버와 연결을 유지하고, PDF 생성이 완료되면 서버가 클라이언트인 웹 브라우저로 푸시 알림으 보내는 기능도 간단히 구현했다. gevent 라이브러리를 사용하는 &lt;a href=&quot;https://pypi.python.org/pypi/gevent-websocket/&quot;&gt;gevent-websocket&lt;/a&gt; 라이브러리를 이용하여 웹 소켓 서버를 만들었다. 처음엔 직접 구현하고 있었는데 때마침 열린 &lt;a href=&quot;http://www.pycon.kr/2014&quot;&gt;PYCON Korea 2014&lt;/a&gt;에서 정민영님이 발표한 &lt;a href=&quot;http://www.pycon.kr/2014/program/3&quot;&gt;제약을 넘어 : Gevent&lt;/a&gt;를 듣고 gevent와 gevent-websocket을 도입했다. 무척 간단했다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;from gevent import monkey
monkey.patch_all()

from geventwebsocket import (
    WebSocketServer,
    WebSocketApplication,
    Resource,
)

class TaskChecker(WebSocketApplication):
    # 작업 class
    pass

notifier_host = &amp;#39;localhost&amp;#39;
notifier_port = 9999

WebSocketServer(
    (notifier_host, notifier_port),
    Resource({&amp;#39;/&amp;#39;: TaskChecker})
).serve_forever()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;서버가 백그라운드에서 PDF를 생성하는 긴긴 시간 동안 이용자는 자신이 받을 제안서 PDF를 웹 화면으로 먼저 접하게 된다. 미리보기(preview) 역할을 하는 셈이다. 이용자에겐 별다른 기능이 없지만, 실제로는 제안서 HTML을 만드는 중요 역할을 한다. 이 웹 서버는 Flask를 이용해 만들었다. 내겐 Django가 더 익숙했지만, 경량 프레임워크이면서도 문서 서버의 웹 서버에 필요한 기능은 충분히 포함하고 있었고, Flask에 기본 탑재된 템플릿 엔진인 &lt;code&gt;jinja2&lt;/code&gt;의 문법이 Django의 템플릿 문법과 거의 동일해서 금방 적응했다.&lt;/p&gt;

&lt;p&gt;Flask는 참 좋은 프레임워크이다. PDF 생성과 병합하는 기능을 분석하고 구현하는 데 예상보다 많은 시간을 써서 시간에 쫓기는 상황이다보니 Flask 문서를 거의 읽지 않고 &lt;a href=&quot;http://www.stackoverflow.com&quot;&gt;Stackoverflow&lt;/a&gt;를 전전하며 개발했는데, 대부분 코드에서 기대하는 바가 의도하는 대로, 그리고 예상하는 대로 동작하였다. 구조도 명료해서 Flask 내부를 들여다 보기에도 좋았다.&lt;/p&gt;

&lt;h5&gt;우여곡절&lt;/h5&gt;

&lt;p&gt;이용자가 웹 브라우저에서 웹 소켓으로 푸시 알림 서버에 연결하면 이 알림 서버는 Redis 서버에 접속하여 Celery가 진행하고 있는 작업 상태를 추적한다. 작업이 끝나면(&lt;code&gt;celery.AsyncResult(id=task_id).status == &amp;#39;SUCCESS&amp;#39;&lt;/code&gt;) 푸시 알림 서버는 해당 작업(PDF 생성)에 대한 알림을 요청한 클라이언트들에게 생성된 PDF 파일을 내려 받는 URL을 반환한다. 웹 브라우저는 이 URL을 받으면 화면에 PDF 다운로드 버튼을 출력하고, 이용자는 이 버튼을 눌러 제안서 PDF를 받는 것이다.&lt;/p&gt;

&lt;p&gt;그래서 백그라운드 작업 처리 부분과 푸시 알림 서버를 연계해야 했는데, 테스트가 까다로웠다. 동시성이나 병렬성에 익숙하지 않다보니 지극히 직렬성 사고를 하여 코드나 로직을 직렬성을 전제로 작성했는데, 동기식 직렬성을 전제로 작성한 코드로 비동기 상황을 테스트 하려다 보니 상황을 재현하고 발생한 문제를 추적하기 용이하지 않았다. 작은 코드 변화만으로 작동 순서가 달라져 문제가 발생하기도 했다.&lt;/p&gt;

&lt;p&gt;wkhtmltopdf가 만든 PDF가 HTML 문서와 다르게 만들어지는 문제도 해결하기 참 까다로웠다. wkhtmltopdf이 Webkit을 사용하긴 하지만, Webkit을 사용하는 구글 크롬이나 애플 사파리과는 다르게 작동하는 부분이 꽤 많았다. 렌더러 버전 차이도 있고, 웹 브라우저 벤더마다 따로 맞춘 설정(customized)이 문제였다.&lt;/p&gt;

&lt;p&gt;글자 간격이나 틀(layout)이 틀어지는 건 그나마 간단했다. &lt;a href=&quot;http://blog.hannal.com/2014/9/letter_overlap_problem_on_wkhtmltopdf/&quot;&gt;HTML DOM 요소들이 미쳐 날뛰듯이 뒤엉키는 문제&lt;/a&gt;는 해결하기 무척 힘들고 어려웠다. 이 문제가 오직 wkhtmltopdf로 생성한 PDF에서만 발생했고, HTML 문서와는 달리 PDF 문서는 요소를 검사(inspect)할 마땅한 방법이 없었기 때문이다. HTML과 CSS의 여러 속성과 항목을 하나하나 고치고 wkhtmltopdf로 PDF를 생성해 결과 화면을 보며 문제 원인을 추적해야 했다. 디버깅 할 때 중단점(breaking point)을 찍고선 진행 과정을 한 단계씩 추적하듯이, wkhtmltopdf가 PDF 문서를 생성하는 과정을 하나 하나 추적할 수 있었다면 얼마나 좋았을까. 또 다른 어려운 점은 이런 문제는 구글링을 해도 딱히 자료가 없다는 점이다.&lt;/p&gt;

&lt;p&gt;몇 몇 문제는 도저히 재현되지도 파악되지도 않아서 wkhtmltopdf 컴파일 설정을 바꿔서 wkhtmltopdf를 다르게 빌드해보기도 했다. 몇 가지 문제는 &lt;a href=&quot;http://natepinchot.com/2014/01/31/building-static-wkhtmltopdf/&quot;&gt;wkhtmltopdf에 QT 패치&lt;/a&gt;를 해서 해결하기도 했다. wkhtmltopdf는 상당히 덩치가 큰 소프트웨어여서 컴파일하고 빌드하는 데 시간이 많이 든다. 인텔 i5 (2.2GHz quad core), 램 8기가, SSD 사양인 맥북 프로에서도 Clean build를 마치는 데 40여 분이 소요됐고, 이보다 훨씬 사양이 낮은 실 서비스 서버에서는 네 시간에서 다섯 시간이 소요됐다. 개발 중이어서 서비스 서버 사양을 &lt;a href=&quot;http://aws.amazon.com/ko/ec2/instance-types/#t2&quot;&gt;AWS t2.micro&lt;/a&gt;로 낮게 설정했기 때문이다. 힘들게 개발 환경인 Mac OS X에서 wkhtmltopdf 컴파일 설정을 맞췄는데, Redhat 계열 Linux인 AMI에서는 다르게 동작해서 다시 컴파일을 하기도 했다.&lt;/p&gt;

&lt;p&gt;마지막으로 고생했던 점은 Go로 작성된 기존 문서 서버 코드를 분석하며 새 버전을 만든 점이다. 당시 개발팀은 중요 일정을 맞추려고 밤낮으로 고생하고 있었다. 그에 비해 나는 비교적 일정과 구현에 대해 배려받고 있었고, 기능만 놓고 보면 내가 맡은 부분은 중요도가 높진 않았다. 그래서, 가능한 한 다른 개발자를 방해하지 않고 기존 코드를 보며 알아서 해결하려 노력했다. 이미 운영 중인 문서 서버의 Go 소스 코드를 몇 번이고 읽으며 의도를 이해하려 했지만, 기존 문서 서버는 DB에 직접 연결하여 데이터를 다루는 등 동작 방식이 전혀 다른데다 객체 지향 언어가 아닌 Go로 작성된 코드여서 Python으로 코드를 작성하는 데 혼란을 야기했다. 즉, 맥락 전환(context switching)에 비용이 많이 든 것인데, 당시엔 전혀 염두에 두지 않았던 상황이다.&lt;/p&gt;

&lt;p&gt;코드로는 의도나 목적을 이해하여 초기 구현은 빨리 마쳤다. 기존 것과 동일하게 동작하면 됐기 때문이다. 하지만, 나는 새로 만드는 버전을 맡은 것이고, 새 버전의 제안서는 기존 제안서와 꽤 달랐다. 이런 문제들은 출시(release)하고나서 운영할 때 유지보수에 혼란을 일으키는 요소가 된다. 정확한 기능의 의도와 목적을 이해하지 않은 상태에서 구조와 설계를 잡고 구현했기 때문이다. 다행히 초과 사양으로 구현하느라 일정 초기에 고생스러웠던 추상화 부분들, 그리고 기획자의 꼼꼼한 지원 덕에 서비스 적용(release) 후 유지보수에 큰 난관이 일어나진 않았다.&lt;/p&gt;

&lt;h5&gt;정리&lt;/h5&gt;

&lt;p&gt;목표로 했던 것보다 2주 더 걸린 5주 만에 개발을 마쳤다. Python 2.7을 사용한 걸 제외하면, 사용한 라이브러리나 프레임워크 등 대부분을 처음 사용하는 경우였다. 도구 뿐만 아니라 개발 메카니즘이나 구성도 생소했다. 이용자가 실제로 접하는 기능과 동작은 단순하기 그지 없는데, 실제 구현은 까다로운 부분도 많았다.&lt;/p&gt;

&lt;p&gt;당시엔 밤엔 공부하고 실험하고 출근하면 밤에 쌓은 자산을 적용하여 구현하는, 말 그대로 주경야독 시기를 혹독하게 보냈다. 과의욕 상태에서 불필요한 설계를 하거나 구현하여 고생을 자초하기도 했다.&lt;/p&gt;

&lt;p&gt;많이 학습하고 부족한 부분을 찾은 과정이었다.&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Feb 2015 16:50:49 +0900</pubDate>
        <link>http://blog.hannal.com//2015/02/devlife-s1-01/</link>
        <guid isPermaLink="true">http://blog.hannal.com//2015/02/devlife-s1-01/</guid>
        
        <category>전직</category>
        
        <category>프로그래밍</category>
        
        <category>서버 개발</category>
        
        <category>Python</category>
        
        <category>Go</category>
        
        <category>Django</category>
        
        <category>Flask</category>
        
        <category>Celery</category>
        
        <category>Redis</category>
        
        <category>AWS</category>
        
        <category>Restful API</category>
        
        
        <category>devlife</category>
        
      </item>
    
      <item>
        <title>원격근무를 시작하다. 일주일 중간 소감.</title>
        <description>&lt;p&gt;출산을 앞두고 지난 월요일부터 집에서 원격으로 일하고 있다. 팀이나 아내는 어떤지 모르겠지만, 난 무척 만족스럽다. 가능하다면 앞으로도 원격으로 집에서 일하고 싶다.&lt;/p&gt;

&lt;h3&gt;1. 환경&lt;/h3&gt;

&lt;p&gt;몇 몇 환경 요소는 집보다 사무실에 있는 것이 더 좋다. 하지만, 대부분은 내 작업방이나 서재가 훨씬 좋은 환경으로 꾸려져 있다. 천 여 권 정도 되는 책과 넓은 책상, 넉넉한 모니터, 쾌적한 네트워크, 휴식에 좋은 널부러질 공간과 여러 장난감, 애교 넘치는 강아지와 만삭인데도 날 챙겨주는 아내가 있다. 몸에 뭔가를 걸치는 걸 싫어하는데, 집에서는 아무래도 간편하게 입어도 되어서 좋다.&lt;/p&gt;

&lt;p&gt;사무실 근처엔 괜찮은 커피를 파는 곳이 없다. 내가 단골로 다니는 까페는 왕복 1km 거리에 있다. 집에서는 Nuova Simonelli Oscar라는 괜찮은 가정용 에스프레소 기기와 좋은 원두로 커피를 내리거나 제법 솜씨 좋은 아내가 핸드드립으로 내려주는데, 어지간한 까페보다 낫다. 양 조절하느라 하루에 한 잔만 마시려 애쓰는데, 맛없는 커피를 마시는 데 내 &lt;a href=&quot;http://blog.hannal.com/2014/10/the_time_that_remains/&quot;&gt;유한한 기회&lt;/a&gt;를 낭비하고 싶지 않다.&lt;/p&gt;

&lt;h3&gt;2. 집중&lt;/h3&gt;

&lt;p&gt;신경쓰지 않으면 집에서 일에 집중하기 안좋다는 조언(?)을 여러 번 들었다. 맞다. 집에서 집중하기 안좋은 상황이 종종 벌어진다. 소파에 파묻혀 한창 일하는데 강아지가 품으로 파고 들어와 허벅지를 차지하기도 하고, 아내의 (정당한) 일상 생활 활동이 방해가 되기도 한다.&lt;/p&gt;

&lt;p&gt;그러나 집중을 방해하는 상황은 사무실에서도 매우 빈번하게 일어난다. 여러 사람과 한 공간에 있어서 발생하는 상황이기 때문에 어찌할 도리가 마땅찮다.&lt;/p&gt;

&lt;p&gt;집에서 일하면 대처 가능한 방법이 있다. 밤에 일하는 것이다. 그래서 낮이나 저녁엔 손으로 해치우는 일을 주로 치르고, 밤, 대략 23시 경부터 3~4시 경까지는 머리로 해치우는 일을 주로 치른다. 사무실에 있으면 사람들이 퇴근하면서 슬슬 집중하기 좋은 여건이 만들어질 때쯤엔 나도 퇴근해야 한다. 버스나 지하철이 끊기기 때문이다.&lt;/p&gt;

&lt;h3&gt;3. 소통&lt;/h3&gt;

&lt;p&gt;소통은 &lt;a href=&quot;https://slack.com/&quot;&gt;Slack&lt;/a&gt;과 전자우편으로 나눈다. 작업물은 git과 redmine 같은 도구로 관리한다. 현재 진행하고 있는 업무가 긴밀하게 동기식 소통을 나눠야 하지 않아도 되는 단계여서 협업하기 불편하지는 않다. 적어도 나는.&lt;/p&gt;

&lt;p&gt;제대로 원격근무를 한 지는 아직 일주일 밖에 되지 않아서 소통에 대해서는 우려하는 일은 생기지 않았다.&lt;/p&gt;

&lt;h3&gt;4. 안좋은 점&lt;/h3&gt;

&lt;p&gt;생활과 일이 섞여서 좋은 경우도 있지만 안좋을 때도 있다. 자동차 공유 서비스를 이용해 몇 시간 차를 빌려 만삭인 아내와 장을 보는 건 좋다. 장보는 것 자체는 지루하고 재미없고 피곤한 일이지만, 아내를 돕는 몇 가지 안 되는 일이어서 좋다. 다만, 이런 생활 활동이 누적되면 정작 저녁이나 밤에 일에 집중하지 못하는 경우가 생긴다.&lt;/p&gt;

&lt;p&gt;일을 하지 않고 자꾸 딴짓하거나 노는 경우는 별로 없다. 어차피 원격근무를 하지 않을 때에도 집에서 일하는 경우가 많았어서 그 정도 자기 관리는 해왔다. 오히려 일을 끊어내지 않고 계속 이어가는 경우가 더 잦아서 다음 날 생활에 지장을 주는 경우가 문제이다. 출근하면 대중교통 시간에 맞추어 일을 끊어내기라도 하지만, 집에서 내복만 입고 소파에 앉아 일하다 문득 오줌보가 터질듯이 가득 차서 화장실 가며 시계를 보면 새벽 4~6시인 경우가 잦다. 잦은 정도가 아니라 일주일 중 6일은 그랬다.&lt;/p&gt;

&lt;p&gt;아직 우리 집이 내가 원격근무하는 데 준비가 되어 있지 않아서 원격근무에 안좋은 일이 생기곤 한다. 그래서 차라리 팀이 활동하는 시간대와 내가 활동하는 시간대가 달라서 시차가 발생하면 낫겠다는 생각도 든다.&lt;/p&gt;

&lt;h3&gt;5. 직업&lt;/h3&gt;

&lt;p&gt;내가 원격근무를 할 수 있는 요인은 크게 다음과 같이 분류된다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;환경의 배려와 지원

&lt;ul&gt;
&lt;li&gt;회사의 배려와 지원&lt;/li&gt;
&lt;li&gt;가정의 배려와 지원&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;직업 소양과 환경

&lt;ul&gt;
&lt;li&gt;서버 프로그래머&lt;/li&gt;
&lt;li&gt;혼자 진행하는 업무 진행&lt;/li&gt;
&lt;li&gt;원격으로 작업 가능한 작업 인프라와 경험&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;여러 여건이 어우러져 원격근무가 가능한 것이며, 이 중 하나라도 빠져도 원격근무가 어렵거나 힘들 것 같다. 가령, 기획자로 일할 때엔 업무 특성상 사무실에서 동기화 된 소통과 업무를 진행해야 했다. 프로그래밍을 한다고 해서 원격근무가 항상 가능한 것은 아니지만, 기획 업무에 비해서는 더 융퉁성 있게 대응 가능하다.&lt;/p&gt;

&lt;h3&gt;6. 중간 평가&lt;/h3&gt;

&lt;p&gt;아주 만족한다. 가정에서 식구와 오랜 시간을 보내서 좋다. 같이 있다고 해서 특별한 경험이 있는 것도 아니다. 그냥 언제든 아내와 강아지 존재를 느끼는 것 뿐이다. 아기가 태어나서 낮과 밤 모두가 사라지는 상황이 오면 어떨지 모르겠지만, 어쨌든 지금은 가정에 머무르는 시간이 좋다.&lt;/p&gt;

&lt;p&gt;일이 더 잘되는 것도 좋다. 긴밀한 소통이 필요한 경우도 분명 오겠지만, 그런 상황 대부분은 내 역량이 부족해서 일어난다고 예상하고 있다. 그동안 해온 동기화 된 소통은 최소화 할 여지가 많아 보인다.&lt;/p&gt;

&lt;p&gt;급여를 열 배 정도 더 받는 게 아닌 이상, 집에서 원격으로 일하는 게 좋을 것 같다. 앞으로 약 한 달 동안 원격근무를 해보고나서 진지하게 그 이후를 고민해봐야 겠다.&lt;/p&gt;
</description>
        <pubDate>Sun, 08 Feb 2015 13:50:49 +0900</pubDate>
        <link>http://blog.hannal.com//2015/02/working_remotely/</link>
        <guid isPermaLink="true">http://blog.hannal.com//2015/02/working_remotely/</guid>
        
        <category>원격근무</category>
        
        <category>재택근무</category>
        
        <category>리모트</category>
        
        
        <category>essay</category>
        
      </item>
    
      <item>
        <title>2015년을 맞이하며</title>
        <description>&lt;p&gt;삶에 방향이 있다면, 위가 아래로 아래가 위로 자리를 옮기기도 하고 흐르는 방향이 바뀌기도 하고 겉과 속이 뒤집히기도 한 2014년을 보냈습니다. &lt;/p&gt;

&lt;p&gt;2009년 창업한 이래 기고, 걷고, 달리고, 넘어지고, 다시 일어나며 사업을 해오다 배가 뒤집힌 사고를, 그리고 그 사고가 사건으로 변하는 모습을 지켜보며 여정을 중단하였습니다. 그때쯤 5번 디스크가 척추에서 탈출하려는 시도를 벌여 몇 달 고생하였고, 여전히 치료를 받고 있긴 하지만 그래도 건강한 몸이 참 소중하다며 지난 시간을 돌이킬 여유가 생겼습니다. 그리고, 또 그때쯤 우아를 잉태하였는데, 잘 안 움직이는 저와 아내와는 달리 아주 활달하게 태동하여 한 달여 남은 출산을 기대하고 있습니다.&lt;/p&gt;

&lt;p&gt;앞으로 뭘 할 지 고민하는데 자꾸 도피성, 회피성 계획만 잡길래 다 집어치우고, 한두 달 정도 쉬면서 게임도 하고, 멍 때리기도 하고, 이런 저런 장난감을 갖고 놀기도 하고, 공부도 했습니다. 큰 방향으로 가닥을 잡을 때쯤, 주변에서 많이 챙겨주시고 도와주셔서 여름부터는 조직에 합류하여 프로그래머로 일하고 있습니다. 주로 Python을 쓰며 Go도 다루고 있는데, 데이터를 다루는 일과 하드웨어를 다루는 일에 관심을 두고 공부하고 일하며 앞으로 뭘 할 지에 대해 조금 더 세세하게 가닥을 다듬어가고 있습니다.&lt;/p&gt;

&lt;p&gt;그동안 도와주셔서 고맙습니다. 저는 그동안 살아온 삶과 다른 삶을 열어 새로이 여정을 나아가고 있습니다. 정말 힘들고 어려운 전환기에 도와주신 분들이 계셔서 전환할 수 있었습니다. 고맙습니다. 이 인연에 감사하며 소중히 이어가겠습니다.&lt;/p&gt;
</description>
        <pubDate>Thu, 01 Jan 2015 00:30:49 +0900</pubDate>
        <link>http://blog.hannal.com//2015/01/hello_2015/</link>
        <guid isPermaLink="true">http://blog.hannal.com//2015/01/hello_2015/</guid>
        
        <category>2015년</category>
        
        <category>결산</category>
        
        
        <category>essay</category>
        
      </item>
    
      <item>
        <title>5. url에 view 함수 연결해서 사진 출력하기</title>
        <description>&lt;ul&gt;
&lt;li&gt;마지막 갱신일시 : 2014년 11월 10일 4시 31분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이번 편에서는 인터넷 주소에 접속하여 Photo 모델로 올린 사진 데이터를 가져와서 View 기능을 이용하여 웹 브라우저에 관련 내용을 출력해보겠습니다.&lt;/p&gt;

&lt;h3&gt;1. URL에 Photo View 연결&lt;/h3&gt;

&lt;h4&gt;(1) URL Resolver&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2014/11/05-urls_and_views.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;이용자가(client) 인터넷 주소(URL : Uniform resource locator, 이하 URL)로 접속하면 웹 서버는 접속한 주소에 해당하는 내용물을 보여줍니다. Django로 운용되는 서비스도 마찬가지여서, 이용자가 URL로 접근하여 뭔가를 요청하면 그 URL에 대한 정보를 &lt;code&gt;urls.py&lt;/code&gt;로 대표되는 URL dispatch에서 찾아서 연결된 구현부를 실행합니다. 구현부는 데이터를(Model) 가져와 출력물을 바로(?) 출력하기도 하고 Template을 거쳐서 출력물을 만들어낸 후 출력하기도 합니다. 이렇게 URL과 구현부을 연결해주는 역할을 Django의 View 영역인 &lt;code&gt;views.py&lt;/code&gt;가 합니다. 지난 &lt;a href=&quot;http://blog.hannal.net/start_with_django_webframework_03/&quot;&gt;3회 강좌&lt;/a&gt;에서 설명한 MTV 개념인데, View에서 URL로 요청받은 걸 이런저런 방법으로 처리하여 결과(출력물)를 내보낸다고 보면 됩니다.&lt;/p&gt;

&lt;p&gt;Django에서는 URL Resolver(&lt;code&gt;urlresolver&lt;/code&gt;)라는 모듈이 URL Dispatch 역할을 하며, &lt;code&gt;django/core/urlresolvers.py&lt;/code&gt;에 있습니다. 이 &lt;code&gt;urlresolvers&lt;/code&gt; 모듈에 있는 &lt;code&gt;RegexURLResolver&lt;/code&gt; 클래스가 요청받은 URL을 되부를 함수(callback function) 덩어리로 바꿔줍니다. 이 덩어리는 View 함수와 함수 인자로 된 tuple 자료형이며, HTTP Handler가 받아서 View 함수를 실행하고 그 결과를 응답(response)합니다. HTTP Handler는 &lt;code&gt;django/core/handlers/base.py&lt;/code&gt; 모듈에 있는 &lt;code&gt;BaseHandler&lt;/code&gt; 클래스를 뜻합니다. 정리하면 다음과 같이 진행됩니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;BaseHandler&lt;/code&gt; 클래스가 URL로 요청(request) 받음&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RegexURLResolver&lt;/code&gt;로 URL을 보냄&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RegexURLResolver&lt;/code&gt;가 URL에 연결된 View를 찾아서 callback 함수와 인자 등을 &lt;code&gt;BaseHandler&lt;/code&gt;로 반환&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BaseHandler&lt;/code&gt;에서 이 함수를 실행하여 결과값인 출력물을 받음.&lt;/li&gt;
&lt;li&gt;출력&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;중간 중간에 middleware 등과 같은 과정이 있지만 큰 흐름은 이러합니다.&lt;/p&gt;

&lt;p&gt;위 내용은 몰라도 Django를 다루는 데 아무 지장 없습니다. 저는 다음 두 문장을 쓰기 위해 위 설명을 쓴 겁니다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Model이나 View에 기능을 구현&lt;/li&gt;
&lt;li&gt;이용자가 서버에 있는 자원에 접근하는 경로인 URL을 URL Dispatch 처리 모듈인 &lt;code&gt;urls.py&lt;/code&gt;에 등록하고 그 URL에 구현부를 연결&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;우리는 앞으로 이런 흐름으로 기능을 구현합니다.&lt;/p&gt;

&lt;h4&gt;(2) 개별 사진 보기 View - 1&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;photo&lt;/code&gt; 앱, 그러니까 &lt;code&gt;photo&lt;/code&gt; 디렉터리 안에 있는 views.py 파일을 엽니다. 별 내용은 없습니다. 세상에 인사하는 View부터 구현해보겠습니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;# coding: utf-8&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.shortcuts&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.http&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpResponse&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;single_photo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;3번...3번 사진을 보여 드릴게요.&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이번엔 &lt;code&gt;urls.py&lt;/code&gt; 파일이 있는 &lt;code&gt;pystagram&lt;/code&gt; 디렉터리에서 &lt;code&gt;urls.py&lt;/code&gt; 파일을 열어서 &lt;code&gt;url(r&amp;#39;^photo/$&amp;#39;, &amp;#39;photo.views.single_photo&amp;#39;, name=&amp;#39;view_single_photo&amp;#39;),&lt;/code&gt; 이 줄을 추가합니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;urlpatterns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;patterns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views.single_photo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;view_single_photo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^admin/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;site&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;urls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;끝났습니다. 웹브라우저에서 &lt;code&gt;http://127.0.0.1:8000/photo/&lt;/code&gt;로 접속하면 &lt;code&gt;HttpResponse&lt;/code&gt;로 넘긴 문장이 출력되는 걸 보실 겁니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2014/11/05-hello_world_by_views.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h4&gt;(3) urls.py&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;urls.py&lt;/code&gt;에는 Django의 &lt;code&gt;urls&lt;/code&gt; 모듈에 있는 &lt;code&gt;url&lt;/code&gt; 함수를 이용하여 URL 연결자를 만들어서 &lt;code&gt;urlpatterns&lt;/code&gt;에 넣습니다. &lt;code&gt;urlpatterns&lt;/code&gt;는 url 함수로 만든 객체를 담은 객체이며 그냥 &lt;code&gt;list&lt;/code&gt; 자료형입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;patterns&lt;/code&gt; 함수는 두 종류 인자를 받습니다. 하나는 &lt;code&gt;prefix&lt;/code&gt;인데, 맨 앞에 있는 아무 내용이 없는 문자형 자료(객체)인 &lt;code&gt;&amp;#39;&amp;#39;&lt;/code&gt;가 &lt;code&gt;prefix&lt;/code&gt;입니다. &lt;code&gt;prefix&lt;/code&gt;는 따로 설명하겠습니다. &lt;code&gt;prefix&lt;/code&gt; 뒤에 나오는 부분은 &lt;code&gt;url&lt;/code&gt; 함수로 만든 URL 연결자들입니다. 그냥 쭈욱 나열한 것 뿐입니다.&lt;/p&gt;

&lt;p&gt;그럼 주소 연결자를 만드는 &lt;code&gt;url&lt;/code&gt; 함수 부분을 보겠습니다. 이 함수는 총 다섯 개 인자를 받습니다. &lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;regex : 주소 패턴 (정규표현식)&lt;/li&gt;
&lt;li&gt;view : 연결할 View&lt;/li&gt;
&lt;li&gt;prefix : 연결할 View 이름에 대한 접두사&lt;/li&gt;
&lt;li&gt;name : 주소 연결자 이름&lt;/li&gt;
&lt;li&gt;kwargs : &lt;code&gt;urls&lt;/code&gt;에서 View로 전달할 &lt;code&gt;dict&lt;/code&gt;형(사전형) 인자&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;regex&lt;/code&gt;와 &lt;code&gt;view&lt;/code&gt;는 필수 인자이고, 나머지는 생략해도 됩니다. 우리가 &lt;code&gt;urls.py&lt;/code&gt;에 추가한 &lt;code&gt;url(r&amp;#39;^photo/$&amp;#39;, &amp;#39;photo.views.single_photo&amp;#39;, name=&amp;#39;view_single_photo&amp;#39;),&lt;/code&gt;를 기준으로 놓고 보면 이러합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;regex : &lt;code&gt;r&amp;#39;^photo/$&amp;#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;view : &lt;code&gt;&amp;#39;photo.views.single_photo&amp;#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;name : &lt;code&gt;name=&amp;#39;view_single_photo&amp;#39;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;name&lt;/code&gt; 인자는 생략해도 된다고 했으니, 한 번 생략해서 &lt;code&gt;urls.py&lt;/code&gt;를 저장한 후 웹브라우저에서 &lt;code&gt;/photo/&lt;/code&gt;로 접속해보세요. 아무 이상 없을 겁니다. 이 &lt;code&gt;name&lt;/code&gt; 인자는 템플릿에서 URL 연결자 이름으로 주소를 출력하는 등 몇 가지 편의에 쓰이며 유용합니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;view&lt;/code&gt; 인자엔 실행할 함수의 이름경로를 문자열을 지정합니다. &lt;code&gt;photo.views.single_photo&lt;/code&gt;란 &lt;code&gt;photo&lt;/code&gt; 앱(패키지, 디렉터리) 안에 있는 &lt;code&gt;views&lt;/code&gt; 모듈(&lt;code&gt;views.py&lt;/code&gt;)의 &lt;code&gt;single_photo&lt;/code&gt; 함수를 뜻합니다. &lt;code&gt;single_photo&lt;/code&gt; 함수는 &lt;code&gt;views.py&lt;/code&gt;에서 “3번...3번 사진을 보여 드릴게요”라는 문자열을 반환하는 함수지요. 앞서 “4. &lt;code&gt;BaseHandler&lt;/code&gt;에서 이 함수를 실행하여 결과값인 출력물을 받음.”라고 설명한 부분이 바로 이 부분입니다. View 함수는 “3번...” 문자열을 반환하는데(&lt;code&gt;return&lt;/code&gt;) 그 반환받는 주체가 바로 &lt;code&gt;BaseHandler&lt;/code&gt;입니다. 물론 이 View 함수를 실행하는 주체이기도 하고요.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;prefix&lt;/code&gt;는 &lt;code&gt;view&lt;/code&gt; 인자에 문자열로 지정하는 View 경로를 간결하게 줄여주는 편의 요소입니다. &lt;code&gt;photo&lt;/code&gt; 앱의 &lt;code&gt;views&lt;/code&gt; 모듈에 있는 여러 함수를 URL에 연결한다면 &lt;code&gt;urls.py&lt;/code&gt;가 이런 모양이 될 겁니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;urlpatterns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;patterns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views.single_photo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/2$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views.single_photo2&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/3$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views.single_photo3&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/4$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views.single_photo4&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/5$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views.single_photo5&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/6$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views.single_photo6&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/7$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views.single_photo7&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/8$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views.single_photo8&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;어우, 기계가 할 일을 사람이 하고 있는 광경이네요. &lt;code&gt;prefix&lt;/code&gt;를 이용해서 View 명기되는 이름경로를 줄여보겠습니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;urlpatterns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;patterns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/2$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo2&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/3$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo3&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/4$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo4&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/5$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo5&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/6$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo6&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/7$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo7&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/8$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo8&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;매번 &lt;code&gt;photo.views&lt;/code&gt;를 &lt;code&gt;prefix&lt;/code&gt;에 명기하고 이후에 붙는 URL 연결자의 View 지정 부분에선 생략했습니다. Django 내부에서도 이 &lt;code&gt;prefix&lt;/code&gt;는 되게 단순하게 처리합니다. (&lt;code&gt;django/conf/urls/__init__.py&lt;/code&gt; 참조)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;.&amp;#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;view&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;즉, &lt;code&gt;prefix&lt;/code&gt;가(가령, &lt;code&gt;&amp;#39;photo.view&amp;#39;&lt;/code&gt;) 있으면 &lt;code&gt;view&lt;/code&gt; 이름(가령, &lt;code&gt;&amp;#39;single_photo&amp;#39;&lt;/code&gt;) 앞에 덧붙이는 거지요. 그냥 덧붙이면 &lt;code&gt;&amp;#39;photo.viewsingle_photo&amp;#39;&lt;/code&gt;처럼 돼버리니 접두사와 이름 사이에 &lt;code&gt;.&lt;/code&gt;을 추가한 것이고요.&lt;/p&gt;

&lt;p&gt;그런데 &lt;code&gt;url&lt;/code&gt; 함수의 인자로 들어가는 &lt;code&gt;prefix&lt;/code&gt; 인자인데 &lt;code&gt;patterns&lt;/code&gt; 함수의 &lt;code&gt;prefix&lt;/code&gt; 인자에 접두사를 넣었네요? 실제로 우리에게 의미있게 쓰이는 &lt;code&gt;prefix&lt;/code&gt;는 &lt;code&gt;patterns&lt;/code&gt; 함수의 &lt;code&gt;prefix&lt;/code&gt;입니다. &lt;code&gt;patterns&lt;/code&gt; 함수로 &lt;code&gt;prefix&lt;/code&gt;를 지정하면, 이후에 지정된 URL 연결자인 &lt;code&gt;url&lt;/code&gt; 함수로 &lt;code&gt;prefix&lt;/code&gt;를 넘겨줍니다. 다시말해, &lt;code&gt;url&lt;/code&gt; 함수의 &lt;code&gt;prefix&lt;/code&gt;는 우리가 직접 쓰기 보다는 Django가 쓰는 데 필요한 겁니다.&lt;/p&gt;

&lt;p&gt;주의할 점은 &lt;code&gt;patterns&lt;/code&gt; 함수의 &lt;code&gt;prefix&lt;/code&gt;는 이 함수가 실행되면서 넘겨받는 URL연결자들 모두에 적용이 된다는 점입니다. 예를 들어, &lt;code&gt;single_photo5&lt;/code&gt;부터 &lt;code&gt;single_photo8&lt;/code&gt;은 &lt;code&gt;image&lt;/code&gt; 앱의 &lt;code&gt;views&lt;/code&gt;에 있는 함수라고 가정하지요. 이럴 경우 &lt;code&gt;prefix&lt;/code&gt;를 다시 지정해야 합니다. 어떻게 해야 할까요? 힌트는 &lt;code&gt;patterns&lt;/code&gt; 함수의 결과값을 담는 &lt;code&gt;urlpatterns&lt;/code&gt;가 그냥 &lt;code&gt;list&lt;/code&gt; 자료형이라는 점입니다. 힌트가 아니라 답이군요.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;urlpatterns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;patterns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/2$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo2&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/3$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo3&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/4$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo4&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;urlpatterns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;patterns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;image.views&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/5$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo5&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/6$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo6&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/7$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo7&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/8$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo8&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;다른 &lt;code&gt;prefix&lt;/code&gt;를 지정한 &lt;code&gt;patterns&lt;/code&gt; 함수를 실행하고, 그 결과값을 &lt;code&gt;urlpatterns&lt;/code&gt;에 덧이으면 됩니다. &lt;code&gt;urlpatterns&lt;/code&gt;가 &lt;code&gt;list&lt;/code&gt; 자료형이니 &lt;code&gt;urlpatterns.extend( ... )&lt;/code&gt; 이렇게 추가해도 됩니다.&lt;/p&gt;

&lt;p&gt;기왕 기계가 할 일을 사람이 하지 않고 기계가 하도록 한 김에 좀 더 간결히 줄여보겠습니다. &lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;urlpatterns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;patterns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/(?P&amp;lt;photo_id&amp;gt;\d+)$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;single_photo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;/photo/&lt;/code&gt; URL 뒤에 붙는 숫자를 정규표현식으로 패턴화하여 지정한 겁니다. &lt;code&gt;\d+&lt;/code&gt; 부분이 바로 숫자(Decimal)가 하나 이상 있다는 걸 뜻하며, URL이 이 패턴에 해당되면 &lt;code&gt;single_photo&lt;/code&gt; 함수로 연결됩니다. Pystagram 기획 내용에 따르면 개별 사진을 보는 URL은 &lt;code&gt;/photo/&amp;lt;사진 ID&amp;gt;/&lt;/code&gt;이니 &lt;code&gt;urls.py&lt;/code&gt;도 위 내용으로 정하겠습니다. 아참, &lt;code&gt;name&lt;/code&gt; 인자까지 덧붙이겠습니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.conf.urls&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;patterns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.contrib&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;urlpatterns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;patterns&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/(?P&amp;lt;photo_id&amp;gt;\d+)$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views.single_photo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;view_single_photo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^admin/&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;admin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;site&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;urls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 정도로 Django의 URL Dispatch 기능의 작동법과 사용법 설명을 마치고, 추가 기능은 필요하면 그때 그때 설명하겠습니다. 아참, &lt;code&gt;url&lt;/code&gt; 함수가 받는 마지막 인자인 &lt;code&gt;kwargs&lt;/code&gt;는 부록에서 설명하겠습니다. &lt;/p&gt;

&lt;h4&gt;(4) 개별 사진 보기 View - 2&lt;/h4&gt;

&lt;p&gt;웹브라우저에서 &lt;code&gt;/photo/&amp;lt;사진 ID&amp;gt;/&lt;/code&gt;, 예를 들어 &lt;code&gt;/photo/3&lt;/code&gt;으로 접근하면 “TypeError at /photo/3”이라는 오류가 뜹니다. 내용은 
“single&lt;em&gt;photo() got an unexpected keyword argument &amp;#39;photo&lt;/em&gt;id&amp;#39;”이고요. &lt;code&gt;single_photo&lt;/code&gt; 함수로 &lt;code&gt;photo_id&lt;/code&gt;라는 인자를 넘길려는데 &lt;code&gt;single_photo&lt;/code&gt; 함수가 받지 않아서 그렇습니다. &lt;code&gt;photo_id&lt;/code&gt;는 &lt;code&gt;urls.py&lt;/code&gt;에서 &lt;code&gt;(?P&amp;lt;photo_id&amp;gt;\d+)&lt;/code&gt; 바로 이 부분입니다. 정규표현식 패턴에 해당되는 문자열이 &lt;code&gt;?P&amp;lt;이름&amp;gt;&lt;/code&gt;에 지정된 &lt;code&gt;이름&lt;/code&gt;에 저장되어 View 함수의 인자로 넘겨집니다. &lt;code&gt;/photo/숫자&lt;/code&gt; URL에서 숫자가 &lt;code&gt;photo_id&lt;/code&gt;라는 이름을 갖는 인자에 저장되어 &lt;code&gt;single_photo&lt;/code&gt; 함수로 전달됩니다. 그래서 &lt;code&gt;single_photo&lt;/code&gt; 함수가 이 인자를 받도록 해야 합니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;single_photo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;photo_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;{0}번...{0}번 사진을 보여 드릴게요.&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;photo_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;첫 번째로 받는 인자인 &lt;code&gt;request&lt;/code&gt;는 View 함수가 받는 기본 인자입니다. 요청(request)과 관련된 여러 정보와 기능을 수행합니다. 많은 일을 수행하는 객체이니 앞으로 그때 그때 설명하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;urls.py&lt;/code&gt;에서 View 함수로 넘길 인자 이름을 지정하지 않아도 별 문제는 없습니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;url(r&amp;#39;^photo/(\d+)$&amp;#39;, &amp;#39;photo.views.single_photo&amp;#39;, name=&amp;#39;view_single_photo&amp;#39;),
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;urls.py&lt;/code&gt;에서 위와 같이 &lt;code&gt;?P&amp;lt;photo_id&amp;gt;&lt;/code&gt;을 빼서 인자 이름을 없애면, 인자는 이름없이 배열 형태로 View 함수로 넘겨집니다. 인자를 받는 View 함수에서는 &lt;code&gt;*args&lt;/code&gt; 인자로 받으면 됩니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;single_photo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;{0}번...{0}번 사진을 보여 드릴게요.&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;인자가 여러 개라면 넘겨받은 순서대로 &lt;code&gt;args&lt;/code&gt;에 인자들이 &lt;code&gt;args[0]&lt;/code&gt;, &lt;code&gt;args[1]&lt;/code&gt;, &lt;code&gt;args[2]&lt;/code&gt;, ... 이런 식으로 담깁니다. 하지만 코드를 알아보기 안 좋으니 어지간히 변수 이름 짓는 게 고통스러운 게 아니라면 인자 이름을 지정하길 권합니다.&lt;/p&gt;

&lt;p&gt;자, 넘겨받은 &lt;code&gt;photo_id&lt;/code&gt; 인자를 Python의 문자형 객체의 포맷 메서드를 이용해 출력하고 있으니, 웹브라우저에서 &lt;code&gt;/photo/&lt;/code&gt; 뒤에 여러가지 &lt;strong&gt;숫자&lt;/strong&gt;를 넣어서 접근해보세요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2014/11/05-view_with_photo_id.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;숫자없이 &lt;code&gt;/photo/&lt;/code&gt;로 또는 숫자가 아닌 문자가 포함된 주소(가령 &lt;code&gt;/photo/3-1023&lt;/code&gt;이나 &lt;code&gt;/photo/3번/&lt;/code&gt;)로도 접근해보세요. “Page not found (404)” 오류가 출력됩니다. &lt;code&gt;urls.py&lt;/code&gt;에 지정한 URL 패턴에 해당되는 게 없으면 &lt;code&gt;404&lt;/code&gt; 오류가 발생합니다. &lt;code&gt;urlresolver&lt;/code&gt;에서 일으키지요.&lt;/p&gt;

&lt;h3&gt;2. Photo 모델에서 사진 정보를 가져와 출력하기&lt;/h3&gt;

&lt;h4&gt;(1) Photo 모델로 객체 찾기(lookup)&lt;/h4&gt;

&lt;p&gt;코드부터 보겠습니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;.models&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Photo&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;single_photo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;photo_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;photo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Photo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;photo_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;response_text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;p&amp;gt;{photo_id}번...{photo_id}번 사진을 보여 드릴게요.&amp;lt;/p&amp;gt;&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;response_text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;p&amp;gt;{photo_url}&amp;lt;/p&amp;gt;&amp;#39;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response_text&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;photo_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;photo_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;photo_url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;photo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;먼저 &lt;code&gt;from .models import Photo&lt;/code&gt;문으로 &lt;code&gt;photo&lt;/code&gt; 앱에 있는 &lt;code&gt;models&lt;/code&gt; 모듈에서 &lt;code&gt;Photo&lt;/code&gt; 모델을 가져옵니다. &lt;code&gt;.models&lt;/code&gt;는 &lt;code&gt;photo.models&lt;/code&gt;와 같은 내용인데, &lt;code&gt;views.py&lt;/code&gt; 파일과 같은 디렉터리(경로)에 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;그 다음에 &lt;code&gt;Photo&lt;/code&gt; 모델의 &lt;code&gt;objects&lt;/code&gt; 객체의 &lt;code&gt;get&lt;/code&gt; 메서드를 이용해 &lt;code&gt;photo_id&lt;/code&gt;에 해당하는 사진 데이터(Photo 모델의 객체(instance)) 가져와서 &lt;code&gt;photo&lt;/code&gt;라는 변수에 담습니다. &lt;code&gt;Photo&lt;/code&gt; 모델에 있는 &lt;code&gt;image_file&lt;/code&gt;이라는 필드에 접근해서 &lt;code&gt;url&lt;/code&gt; 속성(property)를 이용해 지정한 사진의 URL을 출력합니다.&lt;/p&gt;

&lt;p&gt;모델을 다루는 건 나중에 자세히 다루니, 이번 편에서는 모델을 이용해 데이터를 가져오는 것만 다뤘습니다.&lt;/p&gt;

&lt;h4&gt;(2) 찾는 객체가 없으면 404 오류 출력&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;/photo/숫자&lt;/code&gt; URL 중 숫자를 되게 큰 값, 예를 들어 1023을 넣어보세요. “DoesNotExist at /photo/1023”라는 오류가 출력됩니다. 사진 ID 중 1023번인 자료가 없어서 모델 영역에서 발생한 오류입니다. 이 오류 대신 “사진이 없다”는 안내를 하려면 이 오류에 대한 예외(exception) 처리를 해야 합니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;    &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;photo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Photo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objects&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;photo_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;except&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Photo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DoesNotExist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;사진이 없습니다.&amp;quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;DoesNotExist&lt;/code&gt;라는 &lt;code&gt;Exception&lt;/code&gt;이 발생하면 이를 try/except 문으로 잡아내서 예외처리를 한 겁니다. 그런데 &lt;code&gt;Photo&lt;/code&gt; 모델로 사진 데이터를 가져오려는데 데이터가 없는 상황은 “없는 페이지”라고 봐도 됩니다. 그래서 이런 상황에선 &lt;code&gt;404&lt;/code&gt; 오류를 일으키고 &lt;code&gt;404&lt;/code&gt; 오류 안내 페이지를 따로 만들어 제공하는 게 낫습니다. 이걸 간편하게 해주는 것이 &lt;code&gt;get_object_or_404&lt;/code&gt; 함수입니다. 이 함수는 &lt;code&gt;django.shortcuts&lt;/code&gt; 모듈에 있습니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.shortcuts&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_object_or_404&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;single_photo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;photo_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;photo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_object_or_404&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Photo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;photo_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이런 식으로 사용하면 됩니다. 첫 번째 인자로 모델을 넣고, 그 뒤로는 탐색 키워드 인자를 넣습니다. 탐색 키워드 인자란 &lt;code&gt;pk=photo_id&lt;/code&gt;와 같이 모델에서 객체를 찾는 데 쓰이는 내용을 뜻합니다.&lt;/p&gt;

&lt;p&gt;내용을 변경한 전체 코드를 보겠습니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;# coding: utf-8&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.shortcuts&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;render&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_object_or_404&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.http&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpResponse&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;.models&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Photo&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;single_photo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;photo_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;photo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_object_or_404&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Photo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;photo_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;response_text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;p&amp;gt;{photo_id}번...{photo_id}번 사진을 보여 드릴게요.&amp;lt;/p&amp;gt;&amp;#39;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;response_text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;p&amp;gt;{photo_url}&amp;lt;/p&amp;gt;&amp;#39;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;response_text&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;photo_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;photo_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;photo_url&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;photo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;image_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/uploads/2014/11/05-view_data_from_model.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;photo&lt;/code&gt; 모델을 이용해 사진 데이터를 가져와 관련 정보를 웹 브라우저에 출력까지 했습니다. 관련 정보를 출력한다고 했지 사진을 출력한다고는 안 했습니다. ^^ 하지만, 이대로 끝마치기엔 서운하니 사진 출력까지만 하고 설명은 다른 편에서 다루겠습니다.&lt;/p&gt;

&lt;h4&gt;(3) 업로드한 파일을 URL로 접근하기&lt;/h4&gt;

&lt;p&gt;먼저 화면에 출력된 사진 파일 URL로 이미지를 출력하도록 HTML 태그를 출력할 내용에 추가하겠습니다. &lt;code&gt;img&lt;/code&gt; 태그를 쓰는 것이지요.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;    &lt;span class=&quot;n&quot;&gt;response_text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;&amp;lt;p&amp;gt;&amp;lt;img src=&amp;quot;{photo_url}&amp;quot; /&amp;gt;&amp;lt;/p&amp;gt;&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이 줄을 기존 &lt;code&gt;response_text&lt;/code&gt; 변수가 있는 줄 아래에 추가합니다. 그런 뒤 웹브라우저에서 접속해보세요. 이미지가 출력되지 않습니다. 화면에 출력된 이미지 파일 URL을 서버 호스트 내용과 합쳐서, 그러니까 &lt;code&gt;http://localhost:8000/static_files/...&lt;/code&gt; 이렇게 만들어서 웹브라우저로 접근해보세요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2014/11/05-404_without_media_url.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;404&lt;/code&gt; 오류가 발생합니다.&lt;/p&gt;

&lt;p&gt;Django는 이용자가 업로드한 파일은 &lt;code&gt;MEDIA_URL&lt;/code&gt;과 &lt;code&gt;MEDIA_ROOT&lt;/code&gt;라는 설정값을 참조하여 제공(serve)합니다. 모델의 &lt;code&gt;FileField&lt;/code&gt; 필드 클래스나 &lt;code&gt;ImageField&lt;/code&gt; 필드 클래스로 지정하는 &lt;code&gt;upload_to&lt;/code&gt; 인자는 &lt;code&gt;MEDIA_URL&lt;/code&gt;과 &lt;code&gt;MEDIA_ROOT&lt;/code&gt; 경로 아래에 위치합니다. 이 두 설정값을 무시하는 것도 가능하지만 운영하는 데 번거롭고 보안에도 좋진 않습니다.&lt;/p&gt;

&lt;p&gt;자, 그럼 &lt;code&gt;MEDIA_URL&lt;/code&gt;과 &lt;code&gt;MEDIA_ROOT&lt;/code&gt;를 설정하겠습니다. &lt;code&gt;pystagram&lt;/code&gt; 패키지(디렉터리) 안에 있는 &lt;code&gt;settings.py&lt;/code&gt; 파일을 열고 맨 아래에 다음 두 줄을 추가합니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;n&quot;&gt;MEDIA_URL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MEDIA_ROOT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BASE_DIR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;static_files&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;업로드된 파일은 &lt;code&gt;static_files&lt;/code&gt; 라는 URL을 따르므로 &lt;code&gt;urls.py&lt;/code&gt;에도 이와 관련된 내용을 등록해야 합니다. 원리는 이렇습니다. &lt;code&gt;static_files&lt;/code&gt; 뒤에 나오는 경로를 받은 뒤 지정된 경로에 있는 이미지 파일을 읽어온 후 웹브라우저에 보내는 겁니다. 경로에 없으면 &lt;code&gt;404&lt;/code&gt; 오류를 일으키고요. 아, 생각만 해도 귀찮습니다. 다행히 Django엔 이런 걸 처리해주는 기능이 이미 있습니다. &lt;code&gt;django.conf.urls.static&lt;/code&gt; 모듈에 있는 &lt;code&gt;static&lt;/code&gt; 함수지요. &lt;code&gt;urls.py&lt;/code&gt; 맨 아래에 다음 줄을 추가해보세요.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;django.conf&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;settings&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;urlpatterns&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;static&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;static_files&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;document_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;settings&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MEDIA_ROOT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;자, 끝났습니다. 이제 다시 웹브라우저에서 개별 사진 URL로 접근해보세요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2014/11/05-view_photo_successfully.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;실은 업로드한 파일의 URL에 들어가는 &lt;code&gt;static_files&lt;/code&gt;은 모델에서 지정하지 않고 &lt;code&gt;settings.py&lt;/code&gt;에서 지정해야 합니다. 강좌 진행을 위해 &lt;code&gt;photo&lt;/code&gt; 모델의 &lt;code&gt;image_file&lt;/code&gt;과 &lt;code&gt;filtered_image_file&lt;/code&gt; 필드에 &lt;code&gt;static_files&lt;/code&gt; 경로를 넣은 것이지요. 나중에 이와 관련된 내용을 자세히 다루면서 손보도록 하겠습니다. :)&lt;/p&gt;

&lt;h3&gt;3. 부록&lt;/h3&gt;

&lt;h4&gt;(1) url 함수의 kwargs 역할&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;url&lt;/code&gt; 함수에 사용되는 인자인 &lt;code&gt;kwargs&lt;/code&gt;는 View 함수로 임의 인자를 건내는 데 사용됩니다. View 함수는 URL 패턴에서 지정된 값을 인자로 건내받는데, URL에는 어떤 상태나 정보를 나타내지 않으면서 상황에 따라 View 함수에 넘기는 값을 따로 지정하려면 &lt;code&gt;kwargs&lt;/code&gt; 인자를 활용해야 합니다. 예를 들어, 개별 사진을 &lt;code&gt;/photo/&amp;lt;숫자ID&amp;gt;/&lt;/code&gt;이나 &lt;code&gt;/hidden_photo/&amp;lt;숫자ID&amp;gt;/&lt;/code&gt; URL로 접근할 수 있고, 두 URL 모두 &lt;code&gt;single_photo&lt;/code&gt; 함수가 대응한다고 가정하겠습니다. 어떤 URL로 접근했는지 &lt;code&gt;single_photo&lt;/code&gt; 함수에서 알려면 접근한 URL을 분석해도 되지만, URL엔 보이지 않는 정보를 &lt;code&gt;single_photo&lt;/code&gt; 함수에 인자로 보내면 좀 더 편할 겁니다. 이 인자를 &lt;code&gt;hidden&lt;/code&gt;이라고 하겠습니다. 먼저 &lt;code&gt;urls.py&lt;/code&gt;에 &lt;code&gt;kwargs&lt;/code&gt; 인자를 정의합니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^photo/(?P&amp;lt;photo_id&amp;gt;\d+)$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views.single_photo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;view_single_photo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;r&amp;#39;^hidden_photo/(?P&amp;lt;photo_id&amp;gt;\d+)$&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;#39;photo.views.single_photo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;view_hidden_single_photo&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;#39;hidden&amp;#39;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}),&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;이번엔 &lt;code&gt;single_photo&lt;/code&gt; View 함수가 &lt;code&gt;hidden&lt;/code&gt; 인자를 받을 차례입니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;single_photo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;photo_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hidden&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hidden&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;# todo: 뭔가 은밀한 작업을 합시다&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;pass&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;single_photo&lt;/code&gt; 함수는 따로 &lt;code&gt;hidden&lt;/code&gt; 인자를 넘기지 않으면 &lt;code&gt;False&lt;/code&gt; 값으로 &lt;code&gt;hidden&lt;/code&gt; 인자를 받습니다. 즉, &lt;code&gt;/photo/&amp;lt;숫자ID&amp;gt;/&lt;/code&gt;로 접근하는 경우입니다. 하지만, &lt;code&gt;/hidden_photo/&amp;lt;숫자ID&amp;gt;/&lt;/code&gt;로 접근하면 &lt;code&gt;hidden&lt;/code&gt; 인자는 &lt;code&gt;True&lt;/code&gt;로 &lt;code&gt;single_photo&lt;/code&gt; 함수에 넘겨집니다. &lt;code&gt;/hidden_photo/&amp;lt;숫자ID&amp;gt;/&lt;/code&gt; URL을 아는 사람만 &lt;code&gt;hidden&lt;/code&gt;이 &lt;code&gt;True&lt;/code&gt;인 상황을 만끽하게 되겠지요.&lt;/p&gt;

&lt;h4&gt;(2) render와 HttpResponse&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;views.py&lt;/code&gt;를 처음 열면 맨 위에 &lt;code&gt;from django.shortcuts import render&lt;/code&gt;라는 부분이 있습니다. 그런데 우리는 이 &lt;code&gt;render&lt;/code&gt; 함수를 한 번도 쓰지 않고, &lt;code&gt;HttpResponse&lt;/code&gt;를 따로 불러들여서 이를 이용해 화면에 뭔가를 출력했습니다. 이 둘의 차이는 뭘까요?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HttpResponse&lt;/code&gt;는 Django의 View가 HTTP handler로 보내는 출력물의 가장 기본 형태인 객체를 만드는 클래스입니다. HTTP handler가 건내받는 출력물의 가장 기본형이지요. 그래서 &lt;code&gt;HttpResponse&lt;/code&gt; 자체는 템플릿을 같은 걸 처리하는 기능을 담고 있지 않습니다. 그래서 템플릿을 따로 처리하여 그려낸(rendered) 출력물을 문자열 그 자체(plain text)로 받아서 출력해야 합니다. 이런 처리에 필요한 코드는 꽤 반복되므로 반복되는 부분을 별도 함수로 만들어서 편하게 템플릿으로 그려낸 출력물을 &lt;code&gt;HttpResponse&lt;/code&gt;로 보내는 함수가 바로 &lt;code&gt;render&lt;/code&gt;입니다. &lt;code&gt;render&lt;/code&gt; 함수를 보면 반환하는 최종 값도 결국은 &lt;code&gt;HttpResponse&lt;/code&gt; 클래스로 만든 객체입니다.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HttpResponse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;render_to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;httpresponse_kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;(3) 소스 파일에 한글을 입력하니 오류가 떠요!&lt;/h4&gt;

&lt;p&gt;혹시 &lt;code&gt;views.py&lt;/code&gt; 파일 맨 위에 &lt;code&gt;# coding: utf-8&lt;/code&gt; 내용을 넣지 않은 채 &lt;code&gt;views.py&lt;/code&gt; 파일 안에 한글을 직접 입력했다면 &lt;code&gt;SyntaxError&lt;/code&gt; 오류가 발생합니다. 오류 내용은 &lt;code&gt;Non-ASCII character &amp;#39;무엇&amp;#39; in file&lt;/code&gt;인데, 파일에 ascii 문자가 아닌 문자가 있다는 뜻입니다. Python 버전 2대를 쓰는 입문자라면 영원히(?) 고통 받는 상황입니다.&lt;/p&gt;

&lt;p&gt;이 문제는 Python 모듈(파일)에 ascii 문자의 표현 범위를 벗어나는 한글이나 한자 같은 문자가 포함되면 Python 인터프리터가 “어?! 이 문자 뭐임? 몰라, 무서워. 뱉어”라며 Syntax 예외를 일으켜서 발생합니다. 이 문제를 예방하려면 소스 파일에 ascii 문자만 입력하거나 &lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0263/&quot;&gt;소스 파일이 어떤 문자형(charset)으로 작성됐는지 Python 인터프리터에게 알려줘야 합니다&lt;/a&gt;. 그 알려주는 방법이 소스 파일 상단에 &lt;code&gt;# coding: utf-8&lt;/code&gt;를 명기한 것이지요. Emacs 같은 편집기를 위해 &lt;code&gt;# -*- coding: utf-8 -*-&lt;/code&gt; 라고 명기하기도 합니다. &lt;/p&gt;

&lt;p&gt;Python 2의 기본 문자형(charset)이 ascii이기 때문에 Python 2를 쓰는 이상 유니코드와 관련된 고통은 감수해야 합니다. :) 아, 이런 문제는 Python 3에선 발생하지 않습니다.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;이것으로 강좌 5편을 마칩니다. 이번에도 늦어서 죄송합니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hannal/start_with_django_webframework/tree/05-fullsource/pystagram&quot;&gt;5편까지 진행한 전체 소스 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 11 Nov 2014 12:00:49 +0900</pubDate>
        <link>http://blog.hannal.com//2014/11/start_with_django_webframework_05/</link>
        <guid isPermaLink="true">http://blog.hannal.com//2014/11/start_with_django_webframework_05/</guid>
        
        <category>django</category>
        
        <category>view</category>
        
        <category>url dispatch</category>
        
        
        <category>start_with_django_webframework</category>
        
      </item>
    
  </channel>
</rss>
