<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kay on the rails</title>
    <description>Kay as known as Hannal walks on the rails
</description>
    <link>http://localhost:4000//</link>
    <atom:link href="http://localhost:4000//feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 07 Jan 2018 03:49:47 +0900</pubDate>
    <lastBuildDate>Sun, 07 Jan 2018 03:49:47 +0900</lastBuildDate>
    <generator>Jekyll v3.7.0</generator>
    
      <item>
        <title>일하는 방식 고민.</title>
        <description>&lt;p&gt;난 하루에 집중해서 6~8시간, 일주일에 3~4일만 일하는 게 좋을 것 같다.&lt;/p&gt;

&lt;p&gt;딴짓하지 않고 자신을 몽땅 짜낼만큼 높은 집중력을 내면서 항상성을 유지할 수 있는 하루 최대 근무 시간은 6시간이 최대치인 것 같다. 8시간도 큰 부담은 없는데, 사람이 언제나 전력 질주하듯 집중력을 발휘할 수 있는 건 아니니 기준은 하루 6시간 집중하는 데 맞추고 좀 여유를 내고 싶은 날은 8시간 일하면 될 것 같다.&lt;/p&gt;

&lt;p&gt;자신을 짜내듯 일하면 업무 탈진한다. 탈진했다고 퇴사해서 충전하는 건 업무 맥락, 팀웍 구축 비용이 너무 아깝다. 그러므로 평소에(?) 일하듯이 평소에 공부하고 경험하며 충전해야 한다. 나는 느리고 시간을 많이 투입해야 해서 하루에 3시간은 학습에 쓰고, 일주일에 하루 정도는 온전히 경험성 활동에 써야 하는 것 같다. 이것도 멍하니 읽고 감상하는 게 아니라 의식하고 의도한 활동으로 해야 한다. 안 그러면 남는 게 없는 것 같다.&lt;/p&gt;

&lt;p&gt;주 중에 일과 학습에 집중해서 달리려면 그 주를 회고하고 다음 주를 계획하는 데 하루 정도는 써야 한다. 물론 노는 것도 포함해서. 그리고 온전히 쉬는 날은 최소 하루 보장하고.&lt;/p&gt;

&lt;p&gt;이렇게 해서 먹고 살 수 있을까? 일주일에 100시간씩 일해야 성공할 기회가 생긴다고 한다. 성공하거나 시간과 자본에서 어느 정도 자유를 얻은 지인을 보면 그런 것 같다. 물론 죽도록 일해서 결국 죽거나 동력을 잃거나 실패하는 사람은 있다. 그런데 느슨하게(?) 일해서 성공한 경우는 적어도 내 주변엔 없고, 사회에 알려진 사례도 못본 것 같다.&lt;/p&gt;

&lt;p&gt;실은 나 혼자라면 그런 삶에 곧 도달할 것 같다. 문제는 언제까지 지속할 수 있느냐이다. 1~2년이 아니라 5년, 10년, 20년 이후에도 이렇게 일해서 먹고 살 수 있을까? 자본 소득이 뒷받쳐주지 않는 현 상황에서는 낙관하지 못한다.&lt;/p&gt;

&lt;p&gt;나 혼자가 아니라 팀이라면 장기 지속할 가능성이 클 것 같다. 한 사람이 하는 일을 두 사람이 하면 된다. 팀 복잡도가 올라가서 발생하는 누수를 감안하면 두 사람이 소화하는 것보다 한 사람이 하는 게 더 나을지도 모른다. 하지만 예측 가능한 일정과 높은 질을 꾸준하게 내려면 하루 6~8시간, 주 3~4일 근무를 해야 가능할 것 같다. 물론 팀원의 프로 의식과 그런 문화를 지키고 발전시키려는 태도와 마음을 서로 강하게 믿어야 가능하다. 결국 누구와 함께 하느냐가 가장 중요한 문제이다.&lt;/p&gt;

&lt;p&gt;그렇다고 같은 일을 많은 사람이 한 팀으로 모이는 건 아니다. 오히려 일을 쪼개고 쪼갠 일에 대해 온전히 위임하고 권한을 발휘하도록 하여 개개인 간 의존성을 낮춰야 한다. 팀은 다른 조직에 비해 오히려 큰데 일은 다른 조직보다 더 원자화 되어 동작하는 그런 조직을 어떻게 만들어야 할 지 아직은 잘 모르겠다.&lt;/p&gt;
</description>
        <pubDate>Sat, 06 Jan 2018 10:00:00 +0900</pubDate>
        <link>http://localhost:4000//2018/01/thinking-of-how-to-work/</link>
        <guid isPermaLink="true">http://localhost:4000//2018/01/thinking-of-how-to-work/</guid>
        
        <category>조직</category>
        
        <category>일</category>
        
        <category>팀</category>
        
        
        <category>devlife</category>
        
      </item>
    
      <item>
        <title>Django 템플릿에서 VariableDoesNotExist 예외 오류 대응하기</title>
        <description>&lt;p&gt;한 줄 요약 : Django 템플릿 엔진은 템플릿 필터에 대해서 항상 조용한 실패 처리(silent failure)를 하진 않는다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Django Template은 없는 템플릿 변수나 템플릿 변수의 속성, 키, 색인이 없어도 오류 상황을 일으키지 않고 조용히 오류 상황을 잠재운다. 일명 Silent failure 동작이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{{ lorem.ipsum.hello.world }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lorem&lt;/code&gt;이라는 템플릿 변수가 없든 &lt;code class=&quot;highlighter-rouge&quot;&gt;lorem&lt;/code&gt; 템플릿 변수는 있는데 이 객체에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ipsum&lt;/code&gt;이라는 키나 속성이 없다고 가정하자. 최종 템플릿 맥락이 출력(치환)이면 Django는 변수나 키, 속성이 없다는 오류 상황을 일으키지 않으며, 저 템플릿 변수 위치엔 아무것도 출력되지 않는다. 템플릿 변수를 출력(render)하거나 템플릿 태그에서 사용할 때는 이처럼 Silent failure로 동작한다.&lt;/p&gt;

&lt;p&gt;하지만 템플릿 필터를 거치는 경우엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;VariableDoesNotExist&lt;/code&gt; 예외(exception)가 발생한다. 예외 이름에서 드러나듯이 템플릿 변수가 없다는 뜻이다.&lt;/p&gt;

&lt;p&gt;예를 들어, 존재하지 않는 템플릿 변수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;not_exist_var&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;divisibleby&lt;/code&gt; 템플릿 필터에 사용하면 예외 오류가 발생한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{{ '1234'|divisibleby:not_exist_var }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이에 대해 Django 공식 문서에서는 다음과 같이 설명한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thus, filter functions should avoid raising exceptions if there is a reasonable fallback value to return. In case of input that represents a clear bug in a template, raising an exception may still be better than silent failure which hides the bug. ( 출처 : &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/howto/custom-template-tags/#writing-custom-template-filters&quot;&gt;custom-template-tags - writing-custom-template-filter&lt;/a&gt; )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;간단히 말해서 템플릿 필터 함수에서는 버그를 숨기는 Silent failure 보다는 예외를 일으키는 게 낫다고 한다. 실제로 Django 내장 템플릿 필터를 보면 대체물을 대신 반환해도 될 만한 경우엔 Exception 처리를 잡아내서 오류 상황을 피하지만, 그 외의 경우엔 Exception이 발생하게 냅둔다. 문제는 그 정책이 예상을 벗어나는 경우에 발생한다. 난 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 템플릿 필터에서 조용한 실패 처리를 하지 않는 상황을 만났다. &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 템플릿 필터는 대개 다음과 같이 사용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{{ empty_var|default:'비었수다' }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;나도 비슷하게 사용했다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{{ apple.attr3|default:lemon.attrdict.color }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django 템플릿 엔진 동작에 익숙하다면 다음과 같이 동작하길 기대(예상)한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;apple.attr3&lt;/code&gt;가 없으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;lemon.attrdict['color']&lt;/code&gt;를 대신 출력&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lemon.attrdict&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;color&lt;/code&gt; 키가 없으면 결국 아무것도 출력하지 않고 Silent failure.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;딱히 Exception이 발생할만한 로직이 아니고, &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 필터 함수를 봐도 인자 두 개 받아서 &lt;code class=&quot;highlighter-rouge&quot;&gt;return value or arg&lt;/code&gt;로 동작하는 것 뿐이다. 다시 말해 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 템플릿 필터인 Python 함수는 두 개 인자를 받는데, 첫 번째 인자로 받는 &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 앞에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;apple.attr3&lt;/code&gt;가 있으면 해당 객체를 반환하고, 없으면 두 번째 인자로 받는 &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt; 뒤에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;lemon.attrdict.color&lt;/code&gt;를 반환한다.&lt;/p&gt;

&lt;p&gt;하지만 실제로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;VariableDoesNotExist&lt;/code&gt; 예외 오류가 발생한다. 이 예외는 &lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt; 템플릿 태그로 해결하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://gist.github.com/hannal/9de33b54a749457d7f29c5f30c5e9136&quot;&gt;with 템플릿 태그로 VariableDoesNotExist 예방&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt; 템플릿 태그는 Silent failure 처리를 해주니 &lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt; 템플릿 태그로 만든 임시 템플릿 변수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;colour&lt;/code&gt;엔 출력할(render) 게 없는 빈 객체가 할당이 된다. &lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt; 템플릿 태그를 안 쓴 경우엔 Silent failure를 해주는 놈이 없다보니 Exception이 그대로 나버린 것이다. 이 문제가 까다로운 이유는 Django 디버깅 화면에서는 문제가 있는 템플릿 줄(line)을 가리키지 않고 Exception이 발생한 Django 소스를 보여주는 데 있다. 평범한 속성명이나 키 이름을 쓰다가는 고생하기 십상이다.&lt;/p&gt;

&lt;p&gt;흔히 겪는 상황은 아닐 것 같다. 나는 모델에 &lt;code class=&quot;highlighter-rouge&quot;&gt;JSONField&lt;/code&gt;를 썼고, 이 모델필드의 &lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt; 객체에 특정 키(위 예제 기준으로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;colour&lt;/code&gt;키)가 없어서 발생한 거였다. 뷰 함수에서 넘겨주는 템플릿 변수 이름대로라면 금방 발견했을 것 같다.&lt;/p&gt;

&lt;p&gt;삼천포 요약 : 변수 네이밍을 괴랄하게 하면 디버깅에 도움이 된다.&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Jun 2017 00:00:00 +0900</pubDate>
        <link>http://localhost:4000//2017/06/django-template-variabledoesnotexist-exception/</link>
        <guid isPermaLink="true">http://localhost:4000//2017/06/django-template-variabledoesnotexist-exception/</guid>
        
        <category>django</category>
        
        <category>template</category>
        
        <category>템플릿</category>
        
        
        <category>devlife</category>
        
      </item>
    
      <item>
        <title>시트로엥 C4 칵투스 두 달 소감.</title>
        <description>&lt;p&gt;올해 한국에 출시한 시트로엥 C4 칵투스를 샀다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;운행 기간 : 두 달&lt;/li&gt;
  &lt;li&gt;운행 거리 : 약 1,600km&lt;/li&gt;
  &lt;li&gt;평균 연비 : 리터 당 18~19km&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;총평&quot;&gt;총평&lt;/h3&gt;

&lt;p&gt;재밌는 차다. 개성이 강해서 호불호가 극명하게 갈릴 것 같다. 난 선호에 가깝다. 점수를 매기자면 5점 만점에 4점. 30대 3~4인 가정에 추천한다.&lt;/p&gt;

&lt;h3 id=&quot;특성&quot;&gt;특성&lt;/h3&gt;

&lt;h4 id=&quot;1-연비&quot;&gt;1. 연비&lt;/h4&gt;

&lt;p&gt;도심 내 평속 40~60km 정도일 때 연비는 리터 당 17~18km정도로 측정된다. 고속도로 타서 평속 80~90km로 달리면 연비는 22~25km까지 찍는다. 2016년 11월 기준으로 서울 시내 버스 요금이 기본 요금 1,200원에 10km 초과 시 5km 마다 100원씩 가산되고 경유가 리터 당 대략 1,200~1,300원이니까 연비만 놓고 보면 버스 요금보다 저렴하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2016/11/c4-cactus-fuel-efficient.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연비 효율을 높이려는 노력이 곳곳에서 보인다. 먼저 차가 멈추면 엔진을 껐다가 출발할 때 다시 켜는 기능을 들 수 있다. 차량 동작을 완전히 끈 게 아니라 엔진만 끄고, 제동 페달에 발을 떼는 순간 빠르게 다시 시동을 건다. 반응성이 좋아서 불편하진 않다. 하루에 두세 시간 정도 운전하면 에코 유지 시간이 몇 십 분 정도 된다. 몇 십 분 주행을 안 한 셈이니 꽤 연류를 아낀 것이다.&lt;/p&gt;

&lt;h4 id=&quot;2-디자인&quot;&gt;2. 디자인&lt;/h4&gt;

&lt;p&gt;눈에 띄는 디자인이다. 선이 또렷하고 야무지게 생겼다. 특히 얼굴이 재밌게 생겨서 사람들이 흘깃 눈길 한 번씩은 보낸다. (｀^´) 이렇게 생겼달까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2016/11/c4-cactus-front.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자동차 외관에 플라스틱류 소재가 이렇게 많이 사용된 건 처음 본다. 그 유명한(?) 옆면 에어범퍼도 그렇고, 차 전면부나 후면부 곳곳에도 다소 말랑한 플라스틱 소재가 붙어 있다. 좋고 나쁘고를 떠나서 특이하긴 하다. 색깔도 다양하고 강렬한데, 외형이 워낙 특이해서 난 무난하게 흰색을 골랐다. 흰색이 예쁘다.&lt;/p&gt;

&lt;p&gt;내부 인테리어도 아늑하고 귀여운 편이다.&lt;/p&gt;

&lt;h4 id=&quot;3-공간-크기&quot;&gt;3. 공간, 크기&lt;/h4&gt;

&lt;p&gt;차체는 작은 편이다. 키나 덩치가 큰 사람에겐 다소 좁게 느껴질 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2016/11/c4-cactus-size.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 안쪽 공간은 생각보다 여유롭다. 넓다기 보다는 여유감이 있어 답답하지 않다는 뜻이다. 앞좌석은 자잘한 조작 장치를 버튼식으로 바꾸고 대시보드 디스플레이에 몰아 넣어서 변속 레버 부근 공간이 여유롭다. 보조석은 에어백을 상단으로 옮기고, 앞쪽 가방식 수납 공간에 소지품을 넣을 수 있다.&lt;/p&gt;

&lt;p&gt;뒷좌석은 다소 좁게 느껴질 여지가 있는데, 자잘한 장치를 쳐내서 공간이 깔끔하고(휑하고) 전방과 상향 시야가 탁 트여서 심리상 편안함을 준다. 하지만 키가 큰 사람이 앉기엔 좁은 건 어쩔 수 없다. 뒷좌석엔 isofix 방식인 유아 카시트를 두 대 장착할 수 있으며, 고리 구멍이 표시되어 있어 연결하기 쉽다. 카시트 두 개 놓으면 뒷좌석은 사실상 공간이 남지 않는다.&lt;/p&gt;

&lt;p&gt;트렁크는 생활 물품을 담고 다니기 괜찮은 정도이며 넓은 편은 아니다. 나는 유모차, 자동차 용품 등을 넣고 다니는데, 장 본 물품을 상자 하나에 담아서 트렁크에 담을 정도는 된다. 유모차를 넣고 다니기엔 괜찮지만, 유모차를 싣고 장을 많이 본 날엔 좁다.&lt;/p&gt;

&lt;p&gt;뒷좌석 창문은 바깥쪽으로 살짝 열린다. 싫어하는 사람이 꽤 있을 것 같은데, 난 오히려 마음에 든다. 뒷좌석엔 유아 카시트 장착하고 꼬맹이를 앉히기 때문에 아예 꼬맹이가 활짝 열지 못하는 게 마음 편하다. 아이가 타지 않을 때에는 대부분 나 혼자 차를 타거나 동승자 한 명이 보조석에 앉기 때문에 뒷좌석 창문 열 일이 없다. 뒷좌석 창문이 아래로 열리지 않아서 뒷좌석 문짝 안쪽의 수납 공간이 넓다. 어느 정도로 넓냐면 하루 외출하는 데 쓸 아이 기저귀, 소형 우유팩, 간식통을 담을 수 있다. 아이가 용변을 봐서 돌돌 만 기저귀 서너 개는 넉넉히 들어간다.&lt;/p&gt;

&lt;h4 id=&quot;4-에어범퍼&quot;&gt;4. 에어범퍼&lt;/h4&gt;

&lt;p&gt;예쁜 외관에 눈에 띄게 전혀 다른 재질로 된 에어범퍼가 차 옆면에 꽤 넓게 자리잡고 있다. 내 차는 흰색이고 에어범퍼는 검정색인데, 흰색 몸체는 유광이고 에어범퍼는 무광이라 더 이질감이 크다. 딱 문콕 당할 위치에 에어범퍼가 있어서 문콕 스트레스가 거의 사라진다. 실제로 문콕을 몇 번 당한 것 같은데, 에어범퍼와 바퀴 부근 플라스틱류 소재에 찍힌 자국이 생겼더라. 차체 철판 면은 깨끗하고.&lt;/p&gt;

&lt;p&gt;차 옆면이 어딘가에 닿을 때 가장 먼저 에어범퍼가 닿아서 차체 흠집에 대응할 여지가 있다. 좁은 공간을 우회전하며 들어가다 차 오른쪽 부위가 입구 기둥에 닿는 사고(?)가 발생한 적이 있다. 차체가 뭔가에 닿는 느낌이 들자마자 더 진입하지 않고 후진해서 차를 뺐는데, 에어범퍼가 닿아서 차체엔 아무런 흠집이 생기지 않았다. 에어범퍼가 없었다면 흠집이 생겼거나 최악의 경우 찌그러졌을 것이다.&lt;/p&gt;

&lt;h4 id=&quot;5-편의-기능&quot;&gt;5. 편의 기능&lt;/h4&gt;

&lt;p&gt;크루즈 기능을 처음 써봤는데 설명으로 들었을 때보다 편했다. 일정 속도로 꾸준히 달리는 장거리 이동 중에 무척 유용했지만, 피곤한 운전 상황은 도심 운전인데 도심 안에서는 쓸모가 없어서 아쉬웠다. 크루즈 기능을 쓰면서 자동운전 기능을 더 기대하게 됐다. 다음 차는 자동운전 기능이 있는 걸로 사야겠다.&lt;/p&gt;

&lt;p&gt;주유구는 차 열쇠로 열어야 한다. 실내에서 원격으로 열지 못한다. 이건 호불호가 갈리지 않을 것 같다. 매우 불편하다. 열쇠를 빼서 주유원에게 주면 시동이 꺼졌으므로 창문을 닫지 못한다. 그래서 직접 주유하는 셀프 주유소를 이용하는 편인데, 그래도 싫다.&lt;/p&gt;

&lt;p&gt;하드웨어 조작 장치가 몇 개 없다. 대부분 대시보드에 터치 방식으로 옮겨 넣었다. 그래서 공간이 여유로운데, 날씨가 추워지면 터치를 제대로 인식 못하는 경우가 있다. 운전 중엔 가능한 다른 조작을 해서는 안 되긴 하지만 그래도 운전 중에 냉난방을 조절하는 등 뭔가를 조작하는 경우가 왕왕 있는데, 화면 터치로 해야해서 불편한 경우가 생기곤 한다.&lt;/p&gt;

&lt;p&gt;변속 관련 하드웨어 조작 장치도 마찬가지여서 변속 막대가 아예 없다. 대신 운전(D), 후진(R), 정차(N) 변속 제어를 큼직한 버튼 세 개가 맡는다. 발렛 파킹하는 사람들이 당황하곤 한다.&lt;/p&gt;

&lt;p&gt;벤치식 좌석과 패브릭 시트(?)가 꽤 편안하다. 몸이 푹 잠기는 편안함은 아니고 배기는 부위 없이 안정된 편안함이다.&lt;/p&gt;

&lt;p&gt;창문을 세척할 때 분무액은 와이퍼에서 직접 분사하는 방식인데, 세척액이 시야를 가리는 시간이 매우 짧다. 처음엔 세척액이 제대로 분무되지 않은 줄 알 정도이다.&lt;/p&gt;

&lt;p&gt;Apple Carplay 기능이나 Android Auto 기능을 지원하지 않는다. 아쉽다.&lt;/p&gt;

&lt;h4 id=&quot;6-주행&quot;&gt;6. 주행&lt;/h4&gt;

&lt;p&gt;내가 좋아하는 소리를 내진 않는다. 난 조용하고 얌전한 차를 좋아하며, 다소 묵직한 운전감을 선호한다. 이 차는 가볍다. 차체가 가벼운 편이기도 하지만, 엔진 소리나 운전감이 좋게 말하면 경쾌하고 나쁘게 말하면 가볍다. 차가 가볍다보니 고속 주행 시 바닥에서 올라오는 진동과 소리가 크다. 더욱이 정차 시 에코 상태로 전환되어 엔진이 꺼져서 아주 조용한 상황을 경험하게 되기 때문에 더 비교된다.&lt;/p&gt;

&lt;p&gt;완전 자동 변속 장치가 아니고, 수동 변속을 기반으로 자동 변속을 해주는 변속 방식이다. 연비는 좋은데, 변속될 때 차가 꿀렁거리는 수동 변속의 단점을 안고 있다. 잘 운전하면(?) 꿀렁거림을 줄일 수 있지만, 변속 중 꿀렁거리는 상황을 피하기 힘든 경우도 있다. 1단으로 오르막길 오르는데 RPM이 상승해서 2단으로 바뀌면 순간 꿀렁, 그런데 곧 힘이 부쳐서 다시 1단으로 바뀌면 또 꿀렁. 고속도로에서 6단으로 달리던 중 추월하려고 가속 페달을 밟으면 RPM이 부족해서 5단으로 변속되어 꿀렁, 근데 평지라서 금방 RPM이 진정되면 다시 6단으로 바뀌어서 또 꿀렁. 수동 변속 차량을 오래 운전해서 수동 변속을 좋아하는데도 이 변속 패턴은 짜증나곤 한다.&lt;/p&gt;

&lt;p&gt;보기보다 힘이 괜찮다. 수동 변속 특유의 RPM 장난질로 튀어나가는 힘도 제법이고, 시속 130km까지는 뻗어나가는 힘도 괜찮다. 근데 고속 주행에 적합한 차는 아니긴 하다.&lt;/p&gt;

&lt;p&gt;방향 전환과 제동하는 느낌도 묵직해서 밀리지 않아 안전감 있다. 급곡선을 돌 때는 차 중안 부근이, 급제동을 걸 때는 차 엉덩이 부근이 땅으로 꾹 눌리는 느낌이 든달까? 주행감은 상당히 가벼워서 과속 방지턱도 퉁퉁 튀듯 넘는 기분이 드는데, 방향 전환과 제동은 묵직해서 비교되어 재밌다. 상대적으로 묵직한 게 아니라 정말 묵직하다. 새 차라 그런가? 마음에 든다.&lt;/p&gt;

&lt;p&gt;사람은 자신의 몸이 움직이는 공간을 인지하고 있다. 부딪히지 않고 좁은 틈을 지나갈 수 있는지, 줄넘기를 하는 저 사람과 어느 정도 떨어져야 안전한지 무의식 중에 파악한다. 운전석에 앉으면 자신의 몸을 기준으로 인식된 개인 공간이 차체만큼 확장된다. 마치 차체가 내 몸이 된 것처럼. 이 인지와 실제 차체와 동기화되는 비율이 높을수록 마음이 편하고 안정되는데, 동기화 수준을 떨어뜨리는 요소가 몇 가지 있다. 운전석 기준으로 사각, 후사경에서 인식되는 차 뒷쪽 공간과 실제 차 엉덩이 위치의 위치 차이, 운전석에서 보이는 후드(보닛) 거리와 실제 후드 길이 차이 등이다. 이 차는 내 체형에 잘 맞아서 시야가 좋다. 차체가 SUV에 비해선 낮고, 세단보다는 아주 조금 더 높아서 운전석 높이가 적당하다. 그리고 사각(죽은 시야각)이 거의 없다.&lt;/p&gt;
</description>
        <pubDate>Mon, 28 Nov 2016 11:00:00 +0900</pubDate>
        <link>http://localhost:4000//2016/11/citroen-c4-cactus/</link>
        <guid isPermaLink="true">http://localhost:4000//2016/11/citroen-c4-cactus/</guid>
        
        <category>citroen</category>
        
        <category>시트로엥</category>
        
        <category>칵투스</category>
        
        <category>cactus</category>
        
        
        <category>essay</category>
        
      </item>
    
      <item>
        <title>책, Flask 기반의 파이썬 웹 프로그래밍 소감</title>
        <description>&lt;p&gt;Flask 입문서가 국내 집필서로 나왔다. &lt;a href=&quot;http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=83637353&quot;&gt;Flask 기반의 파이썬 웹 프로그래밍&lt;/a&gt;인데 국내 집필서로는 처음으로 보인다.&lt;/p&gt;

&lt;p&gt;Flask는 경량 웹 프레임웍이다. 경량이라지만 꼭 필요한 건 갖춰져 있어서 바퀴 재발명하는 재미(?)를 만끽하기에도 좋고, 유연해서 확장하기도 좋다. 나도 애용하는데, 한 가지 아쉬운 점이 있고 한 가지 궁금한 점이 있다.&lt;/p&gt;

&lt;p&gt;아쉬운 점은 공식 문서가 불친절하다는 것이다. 방향 제시 수준으로만 설명하고 나머지는 알아서 하라는 식이다. 그래서 종종 flask 소스 코드를 까보곤 하며, 내가 VIM이나 Sublime text를 쓰다가 PyCharm을 쓰게 된 것도 구현체 이동 기능으로 Flask 소스 코드를 편하게 까보기 위해서이다. 문서 보다 Flask 소스 코드 보는 경우가 더 많다. 그래서 Python으로 웹 프로그래밍에 입문하려는 사람에겐 Django를 추천한다. 도구 자체를 익히기엔 Flask가 간결해서 좋지만, 입문자가 독학하는 데 도움이 될 만한 친절한 문서가 많지 않다.&lt;/p&gt;

&lt;p&gt;궁금한 점은 다른 사람은 어떻게 구조를 잡고 쓰고 있는가 이다. 자기 입맛대로 쓰면 그만인 웹 프레임웍이긴 하지만, 그래도 궁금하긴 하다. &lt;a href=&quot;https://github.com/teampopong/pokr.kr&quot;&gt;팀 포퐁의 pokr 소스 코드&lt;/a&gt;를 본 뒤로는 더 궁금해졌다. Django는 구조가 그래도 고만고만한 경향이 있는데, Flask는 정말 다양하겠다는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;이 책은 두 가지 중 하나는 꽤 충족시켜 준다. 공식 문서보다 친절한데 그렇다고 막 장황하지도 않다. 공식 문서를 보고 “설명이 이게 끝?”이라 생각이 든다면, 이 책은 거기서 한 수준 정도 더 설명한다. 설명을 하는 기반 코드가 대체로 공식 문서에 나온 예제이고 거의 동일한데, 그래서 좋은 점은 공식 문서를 볼 때 좀 더 친근하게 느낄 것이고 정석(?) 활용을 학습한다는 점이다. 아쉬운 점은 내가 궁금해하는 걸 해소하진 않는다는 점이다.&lt;/p&gt;

&lt;p&gt;Flask이든 Django이든 잘 활용하려면 각 도구가 지향하는 철학이나 방향을 공감하고 이해해야 한다고 본다. 이 책은 그런 공감을 일으키기엔 얕지만, 얕아서 편하게 읽기에 좋다. 자취생을 위한 간편 요리법을 다루는 책 같다. 입문자를 위한 책인지는 잘 모르겠고, 웹 프로그래밍을 해본 사람이 Flask에 얼른 입문해서 써먹을 때 더 유용해 보인다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이 책은 출판사 &lt;a href=&quot;http://www.jpub.kr&quot;&gt;제이펍&lt;/a&gt;에서 내게 증정해준 것이다. 내게 리뷰 같은 걸 요구하지 않고 보내준 것이지만, 국내에 Flask를 다루는 국내 집필서가 없어서 반가운 마음에 나 스스로 쓴 비대가성 글이다.&lt;/p&gt;
</description>
        <pubDate>Fri, 08 Jul 2016 01:00:00 +0900</pubDate>
        <link>http://localhost:4000//2016/07/book-python-web-programming-with-flask/</link>
        <guid isPermaLink="true">http://localhost:4000//2016/07/book-python-web-programming-with-flask/</guid>
        
        <category>python</category>
        
        <category>flask</category>
        
        <category>책리뷰</category>
        
        
        <category>essay</category>
        
      </item>
    
      <item>
        <title>프로그램 짜는 세탁소집 첫째 아들.</title>
        <description>&lt;p&gt;오프라인 영역에서 이뤄지던 세차, 세탁, 주차, 배달 등 다양한 서비스가 O2O(online to offline) 서비스로 등장하고 있다. 창업자나 창업팀을 보면 자신이 하던 오프라인 직업에 IT 기술을 접목하거나 창업자가 IT 분야 개발자인데 특정 오프라인 분야의 덕후인 경우가 많다. 온라인과 오프라인을 함께 이해하고 활용할 줄 알고 접목하기 때문에 기존 온라인에서만 혹은 오프라인에서만 일을 하던 사람과 다른 접근을 하거나 좀 더 빠른 실행이 가능한 것이라 본다.&lt;/p&gt;

&lt;p&gt;스스로 판과 규칙을 짜는 주도성을 갖는 경향이 강한 온라인 분야와는 달리 오프라인 영역은 오랜 세월 쌓인 사용자 경험칙이 강하다. 오프라인 특유의 사용자 경험칙은 대를 이어온 손맛과 비슷하다. 감성 영역이란 얘기다. 그 감성은 세대나 정서 차이로 취향에 안 맞기도 하지만, 요는 기계가 엄청나게 많은 차원으로 학습해도 파악하기 어려운 미세한 감성 영역을 이해하고 접근한다는 데 있다.&lt;/p&gt;

&lt;p&gt;그래서 나는 다음 세대 O2O 서비스는 세탁소집 아들, 자동차 정비소 딸, 미용실 둘째 아들이 일으키는 모습을 기대한다. 단, 조건이 있다. 이들은 소프트웨어를 이해하고 당연히 활용한다는 사고 체계를 갖춰야 한다. 무선인 전화기, 터치 인터페이스, 사회 관계는 온라인에서도 지속된다는 당연한 인식이 기본으로 깔려 있으며, 기계가 할 일을 쉽게 시키는 사고 방식과 체계를 갖춘 세대. 세탁소에서 바삐 움직이는 &lt;strong&gt;콤퓨타&lt;/strong&gt; 세탁기를 보며 콤퓨타와 세탁 너머를 상상할 수 있는 세대.&lt;/p&gt;
</description>
        <pubDate>Mon, 06 Jun 2016 07:00:00 +0900</pubDate>
        <link>http://localhost:4000//2016/06/who-starts-up-o2o-service/</link>
        <guid isPermaLink="true">http://localhost:4000//2016/06/who-starts-up-o2o-service/</guid>
        
        <category>경험</category>
        
        <category>가업</category>
        
        <category>startup</category>
        
        <category>o2o</category>
        
        
        <category>essay</category>
        
      </item>
    
      <item>
        <title>프로그래밍 입문자를 위한 몇 가지 조언</title>
        <description>&lt;p&gt;2014년 11월 4일부터 &lt;a href=&quot;http://www.fastcampus.co.kr/&quot;&gt;패스트캠퍼스&lt;/a&gt;에서 웹 서비스 개발을 주제로 강의하여 얼마 전에 네 번째 기수를 마쳤다. Python과 Django를 이용해 웹 서비스 개발 공정을 겪는 것이 커리큘럼 주제인데, 1기에 대한 이야기는 &lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;Python과 Django 강의&lt;/a&gt;라는 글로 작성했다. 이번 글에선 어떻게 Python과 Django를 공부하면 좋을 지 1년 간 강의하며 고민했고 몇 가지 원리에 대해서는 정리되어 공유해 본다. 내가 강의한 주제가 Python과 Django, 그리고 웹 프로그래밍이어서 그렇지, 프로그래밍에 대한 공부 방법이라고 해도 무방하다고 생각한다.&lt;/p&gt;

&lt;h3 id=&quot;강의-개요&quot;&gt;강의 개요&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;이름 : &lt;a href=&quot;http://www.fastcampus.co.kr/dev_camp_wsd/&quot;&gt;웹 서비스 개발 캠프&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;주제
    &lt;ul&gt;
      &lt;li&gt;Python과 Django를 강사의 경험을 담아 심도있게 다룬다.&lt;/li&gt;
      &lt;li&gt;웹 서비스를 개발하는 공정을 Back-end 중심으로 경험하며 웹 프로그램을 개발하여 배치(deployment)한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수강 대상자
    &lt;ul&gt;
      &lt;li&gt;다른 언어나 프레임워크를 써봤고, Django에 입문하려는 사람&lt;/li&gt;
      &lt;li&gt;Python이나 웹 프로그래밍 중급 과정에 진입하려는 사람&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;강의 시간
    &lt;ul&gt;
      &lt;li&gt;1기 : 90시간&lt;/li&gt;
      &lt;li&gt;2기 : 64시간&lt;/li&gt;
      &lt;li&gt;3기 : 48시간&lt;/li&gt;
      &lt;li&gt;4기 : 40시간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;손으로-반복-반복-그리고-또-반복&quot;&gt;손으로 반복, 반복, 그리고 또 반복&lt;/h3&gt;

&lt;p&gt;뭔가 만들려 하면 막막해서 시작을 떼지 못하겠다는 입문자가 무척 많다.&lt;/p&gt;

&lt;p&gt;책을 보거나 강의를 듣는 중엔 다 안다. 물어보면 대답도 한다. 근데 막상 코드를 짜라고 하면 힘겨워한다. 질문하며 코드 흐름을 자연스레 유도하면 대답은 하는데, 그 대답을 코드로 옮기질 못하기도 한다. 커리큘럼 초반엔 잘 따라오는데, 중반에 접어들어 학습하는 주제와 범위가 늘면 눈에 띄게 힘들고 어려워 하는 경우도 있다.&lt;/p&gt;

&lt;p&gt;그에 반해 빈 파일에 코드를 채워넣는 걸 주저하지 않는 사람도 있다. 원래 다른 분야에서 프로그래밍을 했거나 다른 언어로 웹 프로그래밍을 한 사람이야 그렇다 쳐도, 사실상 입문자여서 이 강의를 듣기엔 다소 무리하는 수강자인데도 곧잘 코드를 작성한다. 입문자여서 프로그래밍이나 Python, Django에 대한 지식과 경험이 부족하여 이론을 설명하면 이해는 못하는데 코드는 어쨌든 작성해 간다. 심지어 자신이 무슨 코드를 짰는지 이해하지 못하면서도 말이다.&lt;/p&gt;

&lt;p&gt;이런 차이는 반복량에 있다. 눈으로는 코드와 이론을 알지만, 손은 모른다. 프로그래밍 언어도 언어의 한 종류이다. 아무리 영어 단어나 문법을 외워도 말을 하지 않고 글을 쓰지 않으면 표현하기 어렵다. 마찬가지로 눈으로 이론을 공부하고 코드를 읽어도 손으로 코드를 짜지 않으면 코딩은 되지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://scienceon.hani.co.kr/34106&quot;&gt;시시하고 아는 코드라도 직접 손으로 쳐야 한다. 한 번 쳐보고 넘어가지 말고, 다양하게 응용하며 여러 번 쳐봐야 한다&lt;/a&gt;. 손에도 코드를 새겨야 한다. 코드를 손에 새기는 가장 쉽고 좋은 방법은 딱 세 개이다. 반복, 반복, 그리고 또 반복하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;복습&quot;&gt;복습&lt;/h3&gt;

&lt;p&gt;학습한 건 가능한 빨리 복습해야 학습 효과가 크다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;우선 배운 걸 그대로 따라하는 복습을,&lt;/li&gt;
  &lt;li&gt;시간이 있다면 응용하는 복습을&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하는 게 좋다. 나는 첫 번째 복습 방법을 교재에 반영하여 수강자가 수업 내용을 떠올리도록 유도한다. 큰 주제 별로 교재를 구성하되, 작은 주제는 강의 흐름에 맞추어 배치하여 스토리텔링을 하려 한다. 중요한 내용은 몇 번 반복 등장하고, 가끔 다른 주제가 먼저 등장하기도 하는데 교재를 한 장 한 장 읽어 나가도록 구성하여 교재를 그대로 따라 복습하면 강의를 떠올리도록 한 것이다.&lt;/p&gt;

&lt;p&gt;두 번째 복습 방법은 과제를 내서 유도한다. 아무리 의지가 가득해도 입문자에게 독학이 어려운 이유 중 하나는 학습한 내용을 응용하여 복습하기 어렵기 때문이다. 과제 풀이를 열심히 한 수강자는 커리큘럼 후반으로 가며 다루는 주제가 다양해 질수록 과제를 푼 효과를 보는데, 새 주제가 등장하더라도 이전 주제와 연계되거나 응용하기 때문이다. 책이나 교육 웹사이트로 학습하는데 실습 문제나 과제가 나오면 꼭 풀기를 권한다.&lt;/p&gt;

&lt;p&gt;강의 시간은 기수를 거듭할수록 줄어 들었는데, 수강자가 복습하지 않으면 강의 시간이 아무리 길어도 별 효과가 없었기 때문이다. 실제로 4기는 강의 시간이 1기의 반도 안 됐지만 진도와 강의 주제의 깊이는 별 차이가 없었다.&lt;/p&gt;

&lt;h3 id=&quot;질문&quot;&gt;질문&lt;/h3&gt;

&lt;p&gt;공부하고 있는 걸 머리에 선명하게 새기는 또 다른 방법은 학습자가 질문하는 것인데, 복습한 사람이 질문을 하는 편이었다. 내 경우는 과제에 함정(?)을 심어 놓는데, 과제를 제출한 사람 중 함정에 대해 질문한 사람 없이 문제를 잘 해결했다면 수강자들이 진도를 잘 따라오고 있다고 판단하여 수업에서 좀 더 깊은 내용을 다루거나 더 많은 양을 다룬다. 함정에 빠진 피해자는 질문을 하게 되는데, 함정에 빠진데다 질문을 하여 답변을 받기 때문에 기억에 남을 가능성이 높다고 본다.&lt;/p&gt;

&lt;p&gt;독학할 때엔 이러한 피드백 과정을 겪기 어렵다. 혼자서 웹에서 검색하여 문제를 해결해도 문제의 앞뒤 맥락을 이해하기 보다는 답에 초점을 맞추어 넘어가기 십상이기 때문이다. 나는 문제에 부딪혀서 스스로 해결하지 못하여 웹에서 해결 방법을 찾으면 반드시 따로 갈무리 하여 쌓아놓고, 일정 시간 뒤에 갈무리 한 자료들의 범주를 나누고 복기한다. 갈무리 당시엔 개별 문제이지만, &lt;a href=&quot;http://scienceon.hani.co.kr/33793&quot;&gt;시간이 흘러 쌓인 문제들을 분류해놓고 보면 각 문제가 서로 연결되어 문제 상황과 맥락을 이해&lt;/a&gt;하게 된다.&lt;/p&gt;

&lt;p&gt;질문과 답변을 주고 받는 소통은 피드백 과정이기도 하다. &lt;a href=&quot;http://scienceon.hani.co.kr/33829&quot;&gt;피드백을 받지 못하면 실력은 늘지 않는다&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;질문하고 답을 찾자. 질문 하려면 질문할 준비가 돼야 한다. 그 준비란 바로 실습과 복습이다.&lt;/p&gt;

&lt;h3 id=&quot;함께-공부하기&quot;&gt;함께 공부하기&lt;/h3&gt;

&lt;p&gt;팀은 1기 때부터 계속 조성하려 애썼다. 1기 때는 강사 입장에선 운좋게도 수강자들이 스스로 팀을 짜서 팀 프로젝트를 수행했었다. 2기 때는 권유를 해봤고, 3기 때는 오리엔테이션 때 아예 팀 조성 시간을 갖고 팀 프로젝트를 정해주었으며 팀장에겐 작은 사례(?)를 하기도 했다. 4기 때는 3기 때와 거의 같으나 수시로 팀 프로젝트를 상기시키며 좀 더 독려했다. 하지만 팀 운영은 잘 안 됐다. 복습과 과제 수행도 버거운데 팀 활동은 더 시간 내기 어려웠다는 수강자가 많았다.&lt;/p&gt;

&lt;p&gt;하지만 여전히 팀 조성과 활동을 하도록 관심을 투자할 가치가 있다. 팀은 아니지만 지인과 나란히 앉아 공부하거나 서로 도우며 공부한 수강자는 혼자서 수업에 참여한 수강자에 비해 실패나 난관에 흔들리는 정도가 덜했다. 질문도 왕성하게 하고 붙임성 있게 다른 수강자와 교류하며 수업에 왕성하게 참여하는 수강자는 그 자신이 수업에서 거둬가는 게 많기도 하지만, 다른 수강자에게도 영향을 많이 끼친다. 그런 참여 활동이 &lt;a href=&quot;http://scienceon.hani.co.kr/33907&quot;&gt;당사자 뿐만 아니라 동료 수강자에게 피드백을 주고 받는 과정&lt;/a&gt;이기 때문이다.&lt;/p&gt;

&lt;p&gt;입문자일 수록 함께 공부할 동료를 구하라고 권하고 싶다.&lt;/p&gt;

&lt;h3 id=&quot;마치며&quot;&gt;마치며&lt;/h3&gt;

&lt;p&gt;재작년에 &lt;a href=&quot;http://blog.hannal.com/2014/5/principles_for_efficient_training/&quot;&gt;근거기반훈련 워크샵에 참석해 효과적 훈련의 원리&lt;/a&gt;를 배웠다. 막상 내게 제대로 활용하지 않았는데, 1년 여 강의하며 몇 가지 원리는 뚜렷하게 효과를 체험했다. &lt;a href=&quot;http://www.fastcampus.co.kr/dev_camp_wpb/&quot;&gt;웹 프로그래밍 입문&lt;/a&gt;과 &lt;a href=&quot;http://www.fastcampus.co.kr/dev_camp_wsd/&quot;&gt;웹 서비스 개발&lt;/a&gt;을 주제로 강의하긴 하지만, 꼭 내 강의가 아니더라도 혼자 공부하거나 지인과 공부하며 활용하면 충분히 효과를 볼 것이라 생각한다.&lt;/p&gt;

</description>
        <pubDate>Wed, 13 Jan 2016 10:45:00 +0900</pubDate>
        <link>http://localhost:4000//2016/01/how-to-study-programming/</link>
        <guid isPermaLink="true">http://localhost:4000//2016/01/how-to-study-programming/</guid>
        
        <category>python</category>
        
        <category>django</category>
        
        <category>강의</category>
        
        <category>패스트캠퍼스</category>
        
        
        <category>devlife</category>
        
      </item>
    
      <item>
        <title>2016년을 맞이하며 20년 전 판을 생각하다</title>
        <description>&lt;h3 id=&quot;게임-개발&quot;&gt;게임 개발&lt;/h3&gt;

&lt;p&gt;20년 전에 첫 게임을 만들었다. 내 &lt;a href=&quot;http://blog.hannal.com/profile/&quot;&gt;필명인 한날은 이 게임 이름에서 비롯&lt;/a&gt;된 것이다. 어설프고 재미없고 허섭했지만, 내 게임을 만들어 친구들과 내 게임 얘기를 나누었다. 내 고교 시절 생활기록부를 보니 장래 희망이 컴퓨터 프로그래머라 적혀 있었다. 당시엔 게임 개발이라는 직업이 사회에 인식되기 전이라서 편의상 게임 개발자 대신 컴퓨터 프로그래머라 적은 것인데, 20년이 지난 지금은 정말 게임 개발자가 아니라 컴퓨터 프로그래머가 되어 있다.&lt;/p&gt;

&lt;p&gt;가끔 언제 다시 게임 업계에 돌아오냐는 안부성 질문을 받곤 한다. 게임 업계에 돌아갈 지 안 갈 지 아직은 모르겠다. 하지만 난 게임을 만들어 왔고, 앞으로도 게임을 만들 것이다.&lt;/p&gt;

&lt;h3 id=&quot;홈페이지&quot;&gt;홈페이지&lt;/h3&gt;

&lt;p&gt;20년 전에 내 홈페이지를 처음 열었다. 1997년부터는 게임 개발, 프로그래밍 등을 주제로 운영하다 &lt;a href=&quot;https://web.archive.org/web/19991012051013/http://dimanche.co.kr/index-kr.html&quot;&gt;1998년에 도메인을 사서 나 나름대로 브랜드&lt;/a&gt;를 만들고 유지하려 했다. 꾸준하진 않지만 완전히 놓지 않고 계속 운영해 온 지난 20년을 스스로 대견하게 여긴다.&lt;/p&gt;

&lt;p&gt;나를 표현하는 익숙한 방법이 내 홈페이지 또는 블로그이다. 앞으로도 내 공간에 글을 쓸 것이다.&lt;/p&gt;

&lt;h3 id=&quot;판&quot;&gt;판&lt;/h3&gt;

&lt;p&gt;작더라도 내 판을 만들어야 한다는 생각을 해왔다. 아무리 잘하고 위협스러워도 남의 판에서는 승산이 없다. 판의 주인이 판을 엎고 새 규칙을 짜면 그만이다. 주인이 판 엎지 않게 아양 떨고 비위 맞추고, 규칙을 바꾸면 바꿀 규칙을 예측하며 그 판에 길들여지면 더이상 희망이 없다. 차라리 판의 주인이 한 짓에 삐쳐서 그 판을 떠나는 게 낫다. 내 판을 만들어 사람들이 내 판에 들어오고, 그 판을 키워야 한다. 그래야 내가 바라는 진정한 독립이 이뤄진다.&lt;/p&gt;

&lt;p&gt;하지만 난 그동안 준비되지 않았으며 진심으로 독립을 갈망한 것이 아니었을지도 모른다는 생각을 했다. 내 판을 만들어야 한다고 주창했지만 정작 말로만 고민했을 뿐, 실행할만큼 고민하지 않았다. 여전히 남의 판에 기대어 마이너 버전 수준에서 내 몸뚱아리를 업그레이드 하려 아둥바둥거렸다.&lt;/p&gt;

&lt;p&gt;앞으로 3~4년 뒤부터는 갈수록 내 판을 만드는 데 들이는 노력이 비싸질 것이라 예상한다. 내 판을 만드는 비용이 비싸질수록 포기할 가능성이 커지고, 포기하는 그때부터 남의 판에서 움직이는 장기말이자 노예가 될 것이다.&lt;/p&gt;

&lt;p&gt;20년 전에 막연히 내 판을 만들어야 한다는 생각을 한 것 같다. 능력도 없으면서 게임 만들자며 사람들 꼬셔 게임개발팀을 만들었고, 하루 방문자가 몇 명이더라도 내 홈페이지에 내 글을 남기려 했다. 내 스토리를 갖고 싶었고 만들려 애썼다. 길들여지지 말자. 내 판의 20년 전 원시형을 잊지 말고 포기하지 말자.&lt;/p&gt;

&lt;p&gt;그렇게 다짐하며 각오를 세운다.&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Jan 2016 16:00:49 +0900</pubDate>
        <link>http://localhost:4000//2016/01/hello_2016/</link>
        <guid isPermaLink="true">http://localhost:4000//2016/01/hello_2016/</guid>
        
        <category>2016년</category>
        
        <category>판</category>
        
        
        <category>essay</category>
        
      </item>
    
      <item>
        <title>내 개발 환경.</title>
        <description>&lt;p&gt;프로그래밍 입문자, 또는 새로 프로그래밍이나 도구에 입문하는 사람과 얘기를 나누다 보면 다른 사람, 기왕이면 그 언어나 도구에 익숙한 사람이 사용하는 개발 환경을 무척 궁금해 한다는 걸 느꼈다. 그냥 공식 홈페이지에 있는 걸 내려 받아서 설치하면 되는 거 아닌가? 생각하며 관련 자료를 찾아보니 사람들은 공식 홈페이지에 소개되지 않은 방법으로 개발 환경을 꾸린다는 걸 발견하면 더 혼란이 빠져서 아예 입문 자체를 부담스러워 하는 사람도 많다.&lt;/p&gt;

&lt;p&gt;그래서 내가 쓰는 개발 환경을 정리해 본다.&lt;/p&gt;

&lt;h3 id=&quot;공통-환경&quot;&gt;공통 환경&lt;/h3&gt;

&lt;h4 id=&quot;pc&quot;&gt;PC&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Macbook Pro 13인치 (2015년 early)&lt;/li&gt;
  &lt;li&gt;Macbook Pro 15인치 (2014년 early)&lt;/li&gt;
  &lt;li&gt;iMac 20인치 (2011년 mid)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;운영체제&quot;&gt;운영체제&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;주 환경 : OS X. 내가 주로 활동하는 분야는 윈도우 보다는 리눅스나 OS X에서 개발하기 더 편하다.&lt;/li&gt;
  &lt;li&gt;보조 환경 : Ubuntu. 주로 실 서버에 올리기 전에 시험 동작하려고 사용하거나 라즈베리 파이용 뭔가를 만들 때 쓰는 환경이지만, 집에 있는 리눅스 박스가 저사양이라서 평소엔 잘 안 쓴다.&lt;/li&gt;
  &lt;li&gt;쉘(shell) : bash를 주로 써왔지만, 2015년 11월부터 zsh을 쓰고 있다. &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh&quot;&gt;oh-my-zsh&lt;/a&gt;을 쓰고 설정은 기본값으로 쓰고 있으며, plugin만 git, virtualenv, virtualenvwrapper를 설정했다.&lt;/li&gt;
  &lt;li&gt;터미널은 OS X에 기본 내장된 것을 사용한다.&lt;/li&gt;
  &lt;li&gt;맥 패키지는 &lt;a href=&quot;http://brew.sh&quot;&gt;Homebrew&lt;/a&gt;로 관리한다.&lt;/li&gt;
  &lt;li&gt;파일, 디렉터리 구조는 &lt;a href=&quot;http://mama.indstate.edu/users/ice/tree/&quot;&gt;tree&lt;/a&gt;을 쓴다. OS X는 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew install tree&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;원격에 있는 파일은 &lt;a href=&quot;https://www.gnu.org/software/wget/&quot;&gt;wget&lt;/a&gt;로 받는다. OS X는 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew install wget&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;글꼴&quot;&gt;글꼴&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://sourcefoundry.org/hack/&quot;&gt;Hack&lt;/a&gt;을 사용한다.&lt;/p&gt;

&lt;h4 id=&quot;vcs-client&quot;&gt;VCS client&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; : 기본 클라이언트를 터미널에서 쓴다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.sourcetreeapp.com/&quot;&gt;sourcetree&lt;/a&gt; : 커밋이 복잡하게 꼬였을 때 쓰지만, 느려서 가끔 쓴다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/karan/joe&quot;&gt;joe&lt;/a&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 파일을 다룰 때 쓴다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;python&quot;&gt;Python&lt;/h3&gt;

&lt;h4 id=&quot;에디터&quot;&gt;에디터&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jetbrains.com/pycharm/&quot;&gt;PyCharm&lt;/a&gt; : 2015년 11월부터 쓰고 있다. 아직 익숙하지 않다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.sublimetext.com/&quot;&gt;Sublime text 3&lt;/a&gt; : 평소에 주로 써왔는데, 최근엔 조금씩 빈도를 줄이고 있다.
    &lt;ul&gt;
      &lt;li&gt;SublimeLinter + Python Flake8 lint : 코드 검사기는 &lt;a href=&quot;https://flake8.readthedocs.org&quot;&gt;Flake8&lt;/a&gt;을 SublimeLinter에 연동해 쓴다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;VIM : 급히 간단히 편집할 때 쓴다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;python-관련&quot;&gt;Python 관련&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Python 3, 2.7 : 최근엔 3 버전으로 시작하는 프로젝트가 늘고 있지만, 아직은 2.7로 동작하는 게 더 많다.&lt;/li&gt;
  &lt;li&gt;PyPy : 실 사용 환경에서 사용하고 있긴 한데, 여전히 제한되게 쓰고 있다.&lt;/li&gt;
  &lt;li&gt;virtualenv/virtualenvwrapper : 주로 사용하는 Python 환경 격리 도구.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;golang&quot;&gt;Golang&lt;/h3&gt;

&lt;h4 id=&quot;에디터-1&quot;&gt;에디터&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt; : 2015년 11월부터 쓰고 있다. 느려서 답답한데, 편하긴 하다. golang 정식 plugin이 출시되었다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.sublimetext.com/&quot;&gt;Sublime text 3&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;plugin : Goimports, GoSublime, SublimeLinter-contrib-golint&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;문서와-자료&quot;&gt;문서와 자료&lt;/h3&gt;

&lt;h4 id=&quot;편집&quot;&gt;편집&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;markdown : 로컬에서 문서를 작성하는 경우엔 대부분 markdown으로 작성한다. 편집은 &lt;a href=&quot;https://atom.io/&quot;&gt;Atom&lt;/a&gt;으로 하는데, 한글이 많으면 어느 에디터든 무척 느려지기 때문에 코딩 할 땐 사용하지 않는 Atom을 markdown 문서 편집용으로 쓴다.&lt;/li&gt;
  &lt;li&gt;google drive : 다른 사람과 협업하거나 공유해야 하는 경우에 사용한다. 주로 google docs, spreadsheet.&lt;/li&gt;
  &lt;li&gt;dropbox paper : 베타판부터 쓰고 있긴 한데, dropbox의 최근 선택과 집중 행보를 보자니 오래 유지 안 하고 종료할 것 같아서 이젠 별로 사용하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;자료-관리&quot;&gt;자료 관리&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;웹 스크래핑 : 모바일 환경에선 &lt;a href=&quot;https://getpocket.com/&quot;&gt;pocket&lt;/a&gt;, PC 환경에선 pocket과 &lt;a href=&quot;http://www.devontechnologies.com/products/devonthink/overview.html&quot;&gt;devonthink&lt;/a&gt;로 스크랩한다. evernote + clearly를 썼는데, 갈수록 구려져서 안 쓴다.&lt;/li&gt;
  &lt;li&gt;PDF : devonthink에 담아서 관리하며, dropbox에도 올려서 모바일 환경에서 접근한다.&lt;/li&gt;
  &lt;li&gt;bookmark : 구글 크롬에 북마크한다. 구글 계정 동기화를 해놔서 내가 사용하는 장비 모두와 북마크 동기화가 늘 되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;이외&quot;&gt;이외&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Google chrome : 느리고 뚱뚱하지만, 구글 계정 연동이 편해서 여전히 쓴다.&lt;/li&gt;
  &lt;li&gt;이외 도구는 가장 기본 설정대로 사용한다.
    &lt;ul&gt;
      &lt;li&gt;R Studio, Apache spark, React, Jupyter, …&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 18 Dec 2015 14:45:00 +0900</pubDate>
        <link>http://localhost:4000//2015/12/my-dev-envs/</link>
        <guid isPermaLink="true">http://localhost:4000//2015/12/my-dev-envs/</guid>
        
        <category>python</category>
        
        <category>golang</category>
        
        <category>개발환경</category>
        
        <category>os X</category>
        
        
        <category>devlife</category>
        
      </item>
    
      <item>
        <title>10. 이용자가 올린 사진 목록 보기</title>
        <description>&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/category/start-with-django-webframework/&quot;&gt;날로 먹는 Django 웹프레임워크 강좌 목차&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;마지막 갱신일시 : 2017년 1월 30일 1시 10분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사진을 게시하였으니 저장된 사진을 가져와 나열하는 기능이 필요합니다. 로그인한 이용자가 사진을 게시하는 기능을 만들었으니 이용자 단위로 사진을 가져와 보여주는 개인 프로필 공간을 만들어 보겠습니다. 이번 편은 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 이용해 데이터를 찾는 방법을 다룹니다.&lt;/p&gt;

&lt;h3 id=&quot;개인-프로필-기능용-앱-만들기&quot;&gt;개인 프로필 기능용 앱 만들기&lt;/h3&gt;

&lt;p&gt;강좌 &lt;a href=&quot;http://blog.hannal.com/2014/8/start_with_django_webframework_01/&quot;&gt;1편 Pystagram 기획&lt;/a&gt;에서 개인 프로필 공간(이하 프로필 페이지)은 다음 기능을 포함합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;간단한 소개&lt;/li&gt;
  &lt;li&gt;팔로잉, 팔로워&lt;/li&gt;
  &lt;li&gt;이용자가 올린 사진&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로필 페이지를 비롯해서 이용자의 대외 노출 기능은 모두 별도 Django 앱을 만들어 다루겠습니다. 꼭 앱으로 나누지 않아도 되지만, 같은 목적이나 맥락끼리 기능을 구분하여 앱으로 묶어 관리하는 게 낫습니다. 터미널 쉘에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py&lt;/code&gt; 파일을 이용해 앱을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python manage.py startapp profiles
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;url-패턴-만들기&quot;&gt;URL 패턴 만들기&lt;/h3&gt;

&lt;p&gt;이번 편에서는 “이용자가 올린 사진”을 나열하는 기능을 구현하는데, 페이지 URL은 &lt;code class=&quot;highlighter-rouge&quot;&gt;/users/&amp;lt;이용자 ID&amp;gt;/&lt;/code&gt; 패턴입니다. 이전 편까지는 URL 패턴을 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일이 있는 시작 패키지의 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에 등록하였는데, 프로필 공간에 들어가는 기능이나 페이지에 필요한 URL은 따로 분리하여 연결하는 방식을 쓰겠습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리에 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 만들어서 이 모듈에 프로필 관련 URL을 등록하고, 시작 패키지의 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에서는 앱 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;include()&lt;/code&gt; 함수로 포함시키는 방식입니다. Django Admin에 사용하는 URL 패턴을 이 방식으로 포함시켜 사용합니다.&lt;/p&gt;

&lt;p&gt;먼저 시작 패키지, 그러니까 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일이 있는 디렉터리에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 열고 다음 내용을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.conf.urls import include

urlpatterns = [
    # 생략
    url(r'^users/', include('profiles.urls')),
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt; 함수를 이용해 &lt;code class=&quot;highlighter-rouge&quot;&gt;users/&lt;/code&gt;로 시작하는 URL들은 &lt;code class=&quot;highlighter-rouge&quot;&gt;'profiles.urls'&lt;/code&gt;에 있는 포함시킵니다. 이는 실제로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 만들어 사용하는데, 좀 더 정확하게는 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;urlpatterns&lt;/code&gt; 이름을 갖는 객체를 만들어야 합니다.&lt;/p&gt;

&lt;p&gt;이번엔 include 대상인 &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles.urls&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;urlpatterns&lt;/code&gt;를 만듭니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 새로 만들고, 그 안에 다음 내용을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.conf.urls import url

from . import views

urlpatterns = [
    url(
        r'^(?P&amp;lt;username&amp;gt;[\w.@+-]+)/$',
        views.profile,
        name='profile'
    ),
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그동안 봐온 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 내용과 다를 바 없습니다. 단지 &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱에서 사용하는 URL을 &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles.urls&lt;/code&gt;에 만든 것 뿐입니다.&lt;/p&gt;

&lt;h3 id=&quot;뷰-함수와-템플릿-뼈대-만들기&quot;&gt;뷰 함수와 템플릿 뼈대 만들기&lt;/h3&gt;

&lt;p&gt;이번엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱의 &lt;code class=&quot;highlighter-rouge&quot;&gt;views.py&lt;/code&gt; 파일에 &lt;code class=&quot;highlighter-rouge&quot;&gt;profile()&lt;/code&gt; 뷰 함수를 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.shortcuts import render

def profile(request, username):
    ctx = {}
    return render(request, 'profile.html', ctx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에서 이용자 이름(ID) 문자열을 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;으로 받아내어 뷰 함수로 전달하도록 하였으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;profile()&lt;/code&gt; 함수에서도 두 번째 인자로 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;을 지정해야 합니다.&lt;/p&gt;

&lt;p&gt;뷰 함수는 뼈대부터 만들 것이므로 뷰 함수에서 사용할 뷰 함수 템플릿을 &lt;code class=&quot;highlighter-rouge&quot;&gt;'profile.html'&lt;/code&gt;로 지정합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일은 앱용 템플릿 디렉터리(&lt;code class=&quot;highlighter-rouge&quot;&gt;APP_DIRS&lt;/code&gt;)에 만듭니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;templates&lt;/code&gt; 디렉터리를 새로 만들고, 그 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일을 만든 뒤 다음 내용을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% extends 'layout.html' %}

{% block content %}
profile page
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;드디어 뼈대를 만들었습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py runserver&lt;/code&gt;로 개발용 내장 웹서버를 구동하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8000/users/hannal/&lt;/code&gt;과 같은 URL로 접근하면 프로필 페이지가 나타납니다.&lt;/p&gt;

&lt;p&gt;하지만, 이 글 내용 그대로 수행했다면 반갑지 않은 화면이 나타납니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hannal.com/assets/uploads/2015/10/10-not_exist_template_file_error.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일이 존재하지 않는다는 내용입니다. 이 파일이 분명히 있는데 저 오류가 발생한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt; 설정에 우리가 새로 생성한 &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱을 추가하지 않아서 그렇습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일은 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리&lt;/strong&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;templates&lt;/code&gt; 디렉터리에 있습니다. 앱 디렉터리에 있다는 의미는 Django가 앱 디렉터리라는 걸 인식해야 한다는 의미입니다. 그래서 &lt;code class=&quot;highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt;에 추가하는 것입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt; 항목에 &lt;code class=&quot;highlighter-rouge&quot;&gt;'profiles'&lt;/code&gt; 문자열을 추가하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'photos',
    'profiles',
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;접속한-페이지의-이용자-정보-가져오기&quot;&gt;접속한 페이지의 이용자 정보 가져오기&lt;/h3&gt;

&lt;p&gt;접속한 프로필 페이지의 이용자 이름은 뷰 함수에 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt; 인자로 전달됩니다. 우리는 Django에서 제공하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델을 사용하므로 이 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt; 모델 필드를 검색(lookup)하는 데 사용하여 이용자를 찾습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.shortcuts import get_object_or_404
from django.contrib.auth import get_user_model

def profile(request, username):
    User = get_user_model()
    user = get_object_or_404(User, username=username)
    ctx = {
        'user': user,
    }

    return render(request, 'profile.html', ctx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get_user_model()&lt;/code&gt; 함수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 모듈의 &lt;code class=&quot;highlighter-rouge&quot;&gt;AUTH_USER_MODEL&lt;/code&gt; 설정 항목을 기준으로 Django 프로젝트가 사용하는 이용자 모델을 가져옵니다. 자세한 내용은 &lt;a href=&quot;http://blog.hannal.com/2015/06/start_with_django_webframework_08/&quot;&gt;8편 로그인, 로그아웃 하기&lt;/a&gt; 편을 참고하세요.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get_object_or_404()&lt;/code&gt; 함수는 지정한 모델과 검색 조건으로 데이터를 가져오려 해보고 없으면 HTTP 404 오류를 일으키는 함수입니다. 두 종류 인자를 필요로 하는데, 첫 번째 인자는 데이터를 찾고 가져올 대상 모델 클래스를 받고, 나머지 인자는 검색에 사용합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;get_object_or_404(User, username=username)&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt; 모델 필드의 값이 뷰 함수에 인자로 전달된 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;과 같은 것을 찾는 내용입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;/users/hannal/&lt;/code&gt; URL로 접근하면 뷰 함수의 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt; 인자의 값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;'hannal'&lt;/code&gt; 문자열이므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;get_object_or_404(User, username='hannal')&lt;/code&gt;을 실행합니다. 이 함수는 데이터 하나를 특정 지어 반한하므로 여러 데이터가 조건에 해당되선 안 됩니다. 데이터가 없는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.http&lt;/code&gt; 모듈에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Http404&lt;/code&gt; 예외 오류를 일으킵니다.&lt;/p&gt;

&lt;p&gt;데이터가 있는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;에 할당하고, 이 객체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿에 템플릿 맥락 요소(context)로 전달하며, 템플릿 안에서 템플릿 변수로 사용할 이름은 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;이번엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일을 수정합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% extends 'layout.html' %}

{% block content %}
&amp;lt;h1&amp;gt;님의 프로필 페이지&amp;lt;/h1&amp;gt;

&amp;lt;ul&amp;gt;
{% for photo in user.photo_set.all %}
    &amp;lt;li&amp;gt;&amp;lt;img src=&quot;&quot; /&amp;gt;&amp;lt;/li&amp;gt;
{% empty %}
    &amp;lt;li&amp;gt;게시한 사진이 없습니다.&amp;lt;/li&amp;gt;
{% endfor %}
&amp;lt;/ul&amp;gt;

{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;눈 여겨 볼 부분은 &lt;code class=&quot;highlighter-rouge&quot;&gt;user.photo_set.all&lt;/code&gt;입니다. 이 부분은 Python 코드로 표현하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;user.photo_set.all()&lt;/code&gt;입니다. Django 템플릿 엔진은 Python의 함수나 클래스와 같이 호출 가능한(callable) 객체를 템플릿 안에서 소괄호를 쳐서 직접 호출하는 걸 허용하지 않습니다. 객체 이름이나 메서드 이름만 명시하면 Django가 대상의 자료형을 검사해서 호출 가능한 객체인 경우 대신 호출하여 수행합니다. 소괄호를 사용하지 못하므로 함수나 메서드에 인자를 전달하지도 못합니다. 인자를 전달하려면 Django 템플릿 필터나 태그를 직접 만들어 사용해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;queryset-객체&quot;&gt;QuerySet 객체&lt;/h3&gt;

&lt;h4 id=&quot;연관-객체-참조-related-objects-reference&quot;&gt;연관 객체 참조 (related objects reference)&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;user.photo_set.all()&lt;/code&gt;는 접속한 프로필 페이지의 이용자(&lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;)가 소유한(own) 모든 사진 게시물을 가져오는 코드입니다. 하나씩 살펴 보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;는 뷰 함수에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; &lt;strong&gt;모델&lt;/strong&gt; 클래스로 데이터를 가져와 연결시켜(mapping) Python 인스턴스 객체로 생성한 것입니다. 그런데 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델은 우리가 앞서 만든 &lt;code class=&quot;highlighter-rouge&quot;&gt;photo&lt;/code&gt; 앱의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델이 &lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;로 연결되어 있습니다. 이용자 한 명이 사진을 여러 개 가지므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델이 1, &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델은 다수(n) 관계라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델 기준으로는 1:N(OneToMany) 관계입니다.&lt;/p&gt;

&lt;p&gt;이 관계가 중요한데요. Django는 모델이 관계(relationship)를 맺고 있으면 연결 당한 쪽에 &lt;strong&gt;연관 객체 참조 속성&lt;/strong&gt;이라는 특별한 속성을 만듭니다. 연결하는 쪽은 모델 필드로 연결하는 대상 모델을 가리키고 있지만, 연결 당하는 쪽은 Python 코드상으로는 알 도리가 없습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델을 놓고 보면, &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;user = models.ForeignKey(settings.AUTH_USER_MODEL)&lt;/code&gt; 모델 필드를 만들어서 연결하는 모델이 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델이라는 것이 드러나지만, &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델엔 아무런 조치를 취하지 않으므로 Python 코드만으로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델이 자신을 연결하는지는 알지 못합니다. 하지만 Django는 모델 관계를 파악하여 연결 당하는 쪽에 연결하는 모델에 대한 접근 경로를 객체 속성(attribute)으로 만들어 줍니다.&lt;/p&gt;

&lt;p&gt;일 대 다(&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;)나 다 대 다(&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;) 관계는 연결 당하는 특정 데이터에 연결하는 쪽의 여러 데이터가 관계를 맺습니다. 이처럼 &lt;strong&gt;1&lt;/strong&gt;쪽에 &lt;strong&gt;N&lt;/strong&gt;으로 연결되는 경우, &lt;strong&gt;1&lt;/strong&gt;쪽에 N쪽 모델 이름을 참조하여 속성을 만듭니다. 이 속성은 따로 지정하지 않으면 N쪽 모델 이름을 소문자 Snake case 표기로 만들고 &lt;code class=&quot;highlighter-rouge&quot;&gt;_set&lt;/code&gt;을 덧붙인 이름을 갖습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델로 놓고 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델의 인스턴스 객체에 &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt; 속성이 만들어 집니다.&lt;/p&gt;

&lt;h4 id=&quot;queryset-객체-1&quot;&gt;QuerySet 객체&lt;/h4&gt;

&lt;p&gt;연관 객체 참조 속성은 Django 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;은 이름에서 드러나듯이 Query 집합(set)입니다. Django model manager는 크게 두 종류 객체를 반환하는데, 하나는 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체이고 다른 하나는 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체가 아닌 객체입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;엔 다음과 같은 특징이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Model manager의 API를 포함 (정확히는 QuerySet API를 manager가 상속 받아 사용)&lt;/li&gt;
  &lt;li&gt;꼬리에 꼬리를 무는 연산(evaluation). 일명 chaining 연산.
    &lt;ul&gt;
      &lt;li&gt;단 QuerySet(또는 model manager)의 메서드가 반환하는 객체가 QuerySet이어야 함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;지연 평가 연산과 캐쉬 처리&lt;/li&gt;
  &lt;li&gt;순서열(&lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;tuple&lt;/code&gt;) 연산 지원&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 특성은 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;의 역할에 기인합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;은 사용자의 요청을 받아 질의(query)를 생성합니다. 이 요청이 데이터베이스에서 데이터를 가져와야만 하는 것이면 생성한 질의를 데이터베이스로 보냅니다. 그렇지 않으면 생성한 질의는 그대로 보관한 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 복제하여 새로 반환합니다. 이 경우 반환한 객체도 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체이므로 또 다시 model manager API를 이용해 요청을 보낼 수 있습니다. 이런 과정을 반복합니다. 데이터베이스에 질의를 보내 데이터를 가져오면 그 데이터를 보관해두며, 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체의 데이터를 사용하는 경우 보관된 데이터를 사용합니다. 몇 번을 접근하더라도 보관된 데이터를 그대로 재사용합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;지연 평가 연산 : 데이터베이스에 접근해야 할 때까지 질의를 보내지 않고 질의를 생성해 조합하며 쌓는 동작&lt;/li&gt;
  &lt;li&gt;캐쉬 처리 : 보관한 데이터를 재사용해 데이터에 접근할 때마다 데이터베이스에 질의를 요청하지 않음&lt;/li&gt;
  &lt;li&gt;chaining : &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 반환하는 경우, 그 객체를 이용해 요청을 이어나감&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우리가 앞서 만든 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델 클래스로 예를 들겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;qs = Photo.objects.filter(pk__in=(1, 2, 3, 4, ))  # 첫 번째 요청.
qs = qs.filter(content__contains='te')  # 두 번째 요청.
qs.count()  # 세 번째 요청.
qs.count()  # 네 번째 요청.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;총 네 번 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체의 메서드를 호출했습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;첫 번째 요청은 &lt;code class=&quot;highlighter-rouge&quot;&gt;pk&lt;/code&gt; 모델 필드(기본키, primary key)가 1, 2, 3, 4인 데이터를 가져오라는 질의를 만듭니다. SQL 질의문으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT * FROM &quot;photos_photo&quot; WHERE &quot;photos_photo&quot;.&quot;id&quot; IN (1, 2, 3, 4)&lt;/code&gt;을 생성한 채 일단 기다립니다.&lt;/li&gt;
  &lt;li&gt;두 번째 요청은 &lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt; 모델 필드로 &lt;code class=&quot;highlighter-rouge&quot;&gt;te&lt;/code&gt; 문자열을 포함하는 데이터를 가져오라는 질의를 만듭니다. 기존 질의문을 조합한 만드므로 질의문은 &lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT * FROM &quot;photos_photo&quot; WHERE (&quot;photos_photo&quot;.&quot;id&quot; IN (1, 2, 3, 4) AND &quot;photos_photo&quot;.&quot;content&quot; LIKE %te% ESCAPE '\')&lt;/code&gt;가 됩니다. 여전히 데이터베이스에 질의를 보내지 않고 기다립니다.&lt;/li&gt;
  &lt;li&gt;세 번째 요청은 여태까지 누적한 탐색(lookup) 조건에 해당하는 모든 데이터의 개수를 가져오는 &lt;code class=&quot;highlighter-rouge&quot;&gt;count()&lt;/code&gt; 메서드입니다. 데이터베이스에 질의를 보내야만 확인 가능한 데이터입니다. 여태까지 만든 질의문을 비로소 데이터베이서에 요청합니다.&lt;/li&gt;
  &lt;li&gt;네 번째 요청도 &lt;code class=&quot;highlighter-rouge&quot;&gt;count()&lt;/code&gt; 메서드입니다. 이미 캐쉬된 데이터가 있어서 데이터베이스에 질의하지 않고 보관하고 있는 데이터에서 개수를 가져와 반환합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;count()&lt;/code&gt; 메서드는 개수를 숫자로 반환하며, 숫자는 정수형(&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;) 객체여서 더이상 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체의 특성을 사용하지 못합니다. 이렇게 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 반환하지 않는 model manager API는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;메서드&lt;/th&gt;
      &lt;th&gt;반환하는 객체&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;조건에 해당하는 특정 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;first()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 보관된 데이터 중 첫 번째 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;last()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 보관된 데이터 중 마지막 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;earliest()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;인자로 전달해 지정한 모델 필드를 기준으로 가장 첫 번째 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;latest()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;인자로 전달해 지정한 모델 필드를 기준으로 가장 마지막 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;count()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; 객체&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 보관된 질의를 기준으로 개수를 가져오거나 보관된 데이터의 개수를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exists()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; 객체&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 보관된 질의 또는 보관된 데이터를 기준으로 데이터가 존재하는 지 여부를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get_or_create()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;조건에 해당하는 특정 데이터를 가져오고 없으면 인자로 전달한 내용으로 데이터를 저장한 후 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;update_or_create()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;특정 데이터를 수정하고, 그 데이터가 없으면 인자로 전달한 내용으로 데이터를 저장한 후 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이외에도 몇 가지 더 있는데 강좌 진행 중 사용하면 자세히 다루겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 반환하는 메서드도 살펴 보겠습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;메서드&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;전체 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;인자로 전달한 조건에 해당하는 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exclude()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;인자로 전달한 조건에 해당하지 않는 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;order_by()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 모델 필드로 정렬하여 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reverse()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 저장된 데이터를 뒤집어서 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;select_related()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;N:1(ManyToOne, &lt;code class=&quot;highlighter-rouge&quot;&gt;ForeginKey&lt;/code&gt;)으로 연결된 데이터를 함께 가져온다. 데이터베이스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;JOIN&lt;/code&gt; 처리.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;prefetch_related()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;N:N(&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;)으로 연결된 함께 데이터를 가져온다. 데이터베이스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;JOIN&lt;/code&gt; 처리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;using()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 데이터베이스에서 데이터를 가져온다. 기본은 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt;로 지정된 데이터베이스.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이번 편에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;order_by()&lt;/code&gt;을 다루며, 다른 메서드는 사용할 때 자세히 다루겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;filter-메서드&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt; 메서드&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt;을 설명하려고 먼 길 다녀왔네요. &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt; 속성은 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체입니다. 그냥 객체는 아니고 조건이 걸려있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델의 인스턴스 객체에서 사용하는데, 이 말은 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델로 가져온 이용자 데이터를 담고 있는 인스턴스 객체, 즉 특정 이용자에 연결된 &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt;입니다. 이를 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델로 풀어쓰면 다음 코드와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user = User.objects.get(username='hannal')
photos = Photo.objects.filter(user=user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;이 &lt;code class=&quot;highlighter-rouge&quot;&gt;'hannal'&lt;/code&gt;인 이용자를 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;에 할당하고, 소유주(&lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;)가 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;인 모든 사진 게시물(&lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt;)을 찾아서 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos&lt;/code&gt;에 할당합니다. 간단히 말해 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;이 &lt;code class=&quot;highlighter-rouge&quot;&gt;'hannal'&lt;/code&gt;인 이용자의 모든 사진 게시물을 가져오는 것이지요.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt; 메서드는 검색(lookup) 조건을 &lt;a href=&quot;http://blog.hannal.com/2015/03/keyword-only-arguments_and_annotations_for_python3/&quot;&gt;키워드 인자&lt;/a&gt;를 받습니다. 인자 이름(key)는 모델 필드의 탐색 방식이고 전달하는 객체(value)는 검색할 값입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;filter(content='hannal')&lt;/code&gt;로 키워드 인자를 전달하면 모델 필드 &lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt;의 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;hannal&lt;/code&gt;과 일치하는 데이터를 찾습니다.&lt;/p&gt;

&lt;p&gt;하지만 검색 방식이 이렇게 단순하진 않습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;hannal&lt;/code&gt; 문자열과 일치하는 게 아니라 &lt;code class=&quot;highlighter-rouge&quot;&gt;hannal&lt;/code&gt; 문자열을 포함한다든지 지정한 숫자보다 큰 값을 갖는 데이터를 찾는 식으로 다양한 검색 방식이 필요한데, Django는 모델 필드 이름에 &lt;code class=&quot;highlighter-rouge&quot;&gt;__탐색키워드&lt;/code&gt;를 덧붙인 인자 이름으로 이러한 검색을 지원합니다. 예를 들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;hannal&lt;/code&gt; 문자열을 포함하는 데이터를 찾는 조건이라면 &lt;code class=&quot;highlighter-rouge&quot;&gt;filter(content__contains='hannal')&lt;/code&gt;와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;__contains&lt;/code&gt;를 모델 필드인 &lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt;에 덧붙입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;탐색 키워드&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;contains&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 문자열을 포함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;리스트나 튜플에 담긴 값들에 해당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gt&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 값을 &lt;strong&gt;초과&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gte&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 값 &lt;strong&gt;이상&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lt&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 값 &lt;strong&gt;미만&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lte&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 값 &lt;strong&gt;이하&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;year&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 연도. &lt;code class=&quot;highlighter-rouge&quot;&gt;DateField&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;DateTimeField&lt;/code&gt; 필드에 한함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;month&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 월. &lt;code class=&quot;highlighter-rouge&quot;&gt;DateField&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;DateTimeField&lt;/code&gt; 필드에 한함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;day&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 일. &lt;code class=&quot;highlighter-rouge&quot;&gt;DateField&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;DateTimeField&lt;/code&gt; 필드에 한함&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;탐색 키워드 역시 자주 쓰는 것만 소개하였으며, 이외 탐색 키워드는 사용할 때 자세히 다루겠습니다.&lt;/p&gt;

&lt;p&gt;여러 탐색 조건을 지정해도 되는데, 함수에 키워드 인자 여러 개를 넣는 방법과 동일합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Photo.objects.filter(user=user, content__contains='te')
Photo.objects.filter(user=user).filter(content__contains='te')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;두 코드는 동일한 역할을 합니다. 이 코드는 사진 게시물의 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;이고(AND), &lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;'te'&lt;/code&gt; 문자열이 포함된 모든 데이터를 가져옵니다. 쉼표로 구분해 여러 키워드 인자를 전달하든 &lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt; 메서드를 체인으로 반복해서 부르든 동일하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt; 조합으로 데이터를 찾습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;OR&lt;/code&gt; 조합으로 찾으려면 별도 조치를 취해야 하는데, 나중에 다루겠습니다.&lt;/p&gt;

&lt;p&gt;정리하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델 클래스의 인스턴스 객체에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt; 속성은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델 클래스와 연결되어 만들어졌으며, &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체로 만들어졌는데 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt; 속성이 속한 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 인스턴스 객체의 데이터를 기반으로 합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체이므로 체인 연결하듯이 후속 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;의 메서드를 사용할 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;user.photo_set.all()&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt; 메서드를 쓴 것입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo.objects.filter(user=user).all()&lt;/code&gt;과 동일한 역할을 합니다.&lt;/p&gt;

&lt;h3 id=&quot;사진-정렬하여-나열하기&quot;&gt;사진 정렬하여 나열하기&lt;/h3&gt;

&lt;p&gt;프로필 페이지에서 사진은 저장된 등록된 순서대로 나열됩니다. 별도로 지정하지 않으면 기본키(primary key)를 기준으로 하여 순서대로 나열되기 때문입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;으로 가져오는 데이터를 정렬하는 방법은 크게 두 가지입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;order_by()&lt;/code&gt; 메서드로 정렬할 모델 필드 이름 지정&lt;/li&gt;
  &lt;li&gt;모델에 정렬할 기본(default) 기준을 지정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;order_by()&lt;/code&gt;는 &lt;a href=&quot;http://blog.hannal.com/2015/03/keyword-only-arguments_and_annotations_for_python3/&quot;&gt;위치 인자&lt;/a&gt;로 정렬 기준으로 삼을 모델 필드 이름을 문자열로 받습니다. 여러 개를 지정하면 정렬 우선순위에 따라 정렬합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Photo.objects.order_by('created_at')  # created_at 순서대로.
Photo.objects.order_by('-created_at')  # created_at 역순으로.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;첫 번째 구문은 전체 사진 게시물을 &lt;code class=&quot;highlighter-rouge&quot;&gt;created_at&lt;/code&gt; 모델 필드 기준으로 하여 순서대로 가져옵니다. 역순으로 가져오려면 모델 필드 이름 앞에 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;를 덧붙이면 되며 두 번째 구문이 &lt;code class=&quot;highlighter-rouge&quot;&gt;created_at&lt;/code&gt; 역순으로 정렬하는 것입니다. 만약 &lt;code class=&quot;highlighter-rouge&quot;&gt;created_at&lt;/code&gt;, 즉 생성일시가 완전히 동일한 경우에는 기본키 역순으로 정렬하도록 하려면 인자를 추가하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Photo.objects.order_by('-created_at', `-pk`)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;무작위 순서로 정렬하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo.objects.order_by('?')&lt;/code&gt;처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;'?'&lt;/code&gt;를 인자로 전달하면 되는데, 주의할 점은 상당히 느립니다. 되도록이면 쓰지 않길 권합니다.&lt;/p&gt;

&lt;p&gt;모델에 정렬할 기본 기준을 정하려면 모델에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; 클래스를 만들고, &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; 클래스 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ordering&lt;/code&gt; 속성을 만들어 정렬할 모델 필드 이름을 나열하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Photo(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL)
    image = models.ImageField(upload_to='%Y/%m/%d/orig')
    filtered_image = models.ImageField(upload_to='%Y/%m/%d/filtered')
    content = models.TextField(max_length=500, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ('-created_at', '-pk', )

    # 후략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;나중에 자세히 다루겠지만, 템플릿에서는 함수 호출하듯이 소괄호(&lt;code class=&quot;highlighter-rouge&quot;&gt;(&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;)&lt;/code&gt;)를 사용하여 객체 호출을 직접 하지 못합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;{% for photo in user.photo_set.all %}&lt;/code&gt;와 같은 구문을 &lt;code class=&quot;highlighter-rouge&quot;&gt;{% for photo in user.photo_set.order_by('-created_at', '-pk') %}&lt;/code&gt;와 같이 쓰지 못합니다. 그래서 정렬하려면 뷰 함수에서 정렬한 데이터를 별도 변수에 할당하여 이 변수를 템플릿에 전달해야 합니다. 예를 들겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# photos/views.py

def profile(request, username):
    User = get_user_model()
    user = get_object_or_404(User, username=username)
    photos = user.photo_set.order_by('-created_at', '-pk')

    ctx = {
        'user': user,
        'photos': photos,
    }

    return render(request, 'profile.html', ctx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{# photos/templates/profile.html #}
&amp;lt;ul&amp;gt;
{% for photo in photos %}
    &amp;lt;li&amp;gt;&amp;lt;img src=&quot;&quot; /&amp;gt;&amp;lt;/li&amp;gt;
{% empty %}
    &amp;lt;li&amp;gt;게시한 사진이 없습니다.&amp;lt;/li&amp;gt;
{% endfor %}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또는 모델에서 정렬 기준을 정의하여 따로 &lt;code class=&quot;highlighter-rouge&quot;&gt;order_by()&lt;/code&gt; 메서드를 쓰지 않더라도 기본으로 지정한 기준대로 정렬되도록 처리해도 됩니다.&lt;/p&gt;

&lt;p&gt;이 강좌에서는 명시한 정렬 기준이 코드에 드러나는 차원에서 뷰 함수에서 정렬하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;강좌 10편을 마칩니다. 정말 오랜만에 연재했네요. 이제 몇 회만 더 연재하면 강좌 1부가 끝납니다. 강좌 분량이 많아지면서 처음 계획을 바꿨습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1부 : Django 전반을 두루 겪기&lt;/li&gt;
  &lt;li&gt;2부 : 1부에서 다루지 않은 내용을 더 자세히 다루기&lt;/li&gt;
  &lt;li&gt;3부 : 앞단 만들고 배포하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;올해 안에 1부를 마치도록 노력하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hannal/start_with_django_webframework/tree/l10&quot;&gt;10편까지 진행한 전체 소스 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 02 Oct 2015 12:45:00 +0900</pubDate>
        <link>http://localhost:4000//2015/10/start_with_django_webframework_10/</link>
        <guid isPermaLink="true">http://localhost:4000//2015/10/start_with_django_webframework_10/</guid>
        
        <category>django</category>
        
        <category>queryset</category>
        
        <category>ordering</category>
        
        
        <category>start-with-django-webframework</category>
        
      </item>
    
      <item>
        <title>Celery의 Subtask 기능을 이용하여 Chord와 Chain로 작업 분산해서 다루기</title>
        <description>&lt;h3 id=&quot;웹페이지-긁어오기&quot;&gt;웹페이지 긁어오기&lt;/h3&gt;

&lt;p&gt;Python으로 웹페이지 열 곳을 긁어와서 하나로 합쳐 보겠습니다. Python HTTP library인 &lt;a href=&quot;http://docs.python-requests.org/en/latest/&quot;&gt;requests&lt;/a&gt;를 쓰면 아주 간단합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import requests

def fetch_page_by_url(url):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text

merged_text = []
for i in range(0, 10):
    result = fetch_page_by_url(
        'http://localhost:8000/{}.html'.format(i)
    )

    if result is not None:
        merged_text.append(result)

do_something(merged_text.join(''))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;celery를-이용해-비동기-방식으로-긁어오기&quot;&gt;Celery를 이용해 비동기 방식으로 긁어오기&lt;/h3&gt;

&lt;p&gt;차례대로 긁어오니 열 개 페이지를 모두 가져오기 전까지는 결과를(&lt;code class=&quot;highlighter-rouge&quot;&gt;do_something(merged_text.join(''))&lt;/code&gt;) 확인하지 못합니다. &lt;a href=&quot;https://docs.python.org/3/library/multiprocessing.html&quot;&gt;multiprocessing&lt;/a&gt;을 이용해 여러 프로세스로 동시성을 확보해도 되지만, 분산 작업 큐 시스템인 &lt;a href=&quot;http://celery.readthedocs.org/en/latest/&quot;&gt;Celery&lt;/a&gt;로 쉽고 간편하게 비동기 처리하기도 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from celery import Celery

app = Celery(__name__)

@app.task
def fetch_page_by_url(url):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text

merged_text = []
for i in range(0, 10):
    result = fetch_page_by_url.apply_async(
        'http://localhost:8000/{}.html'.format(i)
    )

    if result is not None:
        merged_text.append(result)

do_something(merged_text.join(''))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드에는 문제가 있습니다. Celery 작업 수행 객체로 장식된(decorated) &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url&lt;/code&gt; 객체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;apply_async()&lt;/code&gt; 메서드를&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 이용하여 &lt;strong&gt;비동기&lt;/strong&gt;로 작업을 수행하는데, 이 메서드가 반환하는 객체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;res.text&lt;/code&gt;가 아니라 Celery 결과 작업을 다루는 객체입니다. 게다가 비동기로 작업을 수행하고 바로 프로그램 수행 제어권을 호출자에게 반환하므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url.apply_async(...)&lt;/code&gt; 호출이 되자마자 바로 다음 구문을 수행하는데, 웹 페이지를 가져오는 작업이 끝났는지 여부는 알지 못 합니다.&lt;/p&gt;

&lt;p&gt;이 문제를 피하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt; 메서드를 이용합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if result.get() is not None:
        merged_text.append(result)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt; 메서드는 비동기로 수행하는 작업 객체(&lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;)가 작업을 마치고 값을 반환하기를 &lt;strong&gt;동기식&lt;/strong&gt;으로 기다려서 반환합니다. 어?! 이렇게 할 거라면 굳이 Celery를 쓸 필요가 없지요. Celery에게 여러 작업을 맡겨서 비동기로 처리하고, 비동기로 처리한 결과를 받아다 뭔가를 하려면 다른 방법을 써야 합니다. 이 글에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;chain&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;chord&lt;/code&gt;을 사용하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;chain-기능&quot;&gt;chain 기능&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chain&lt;/code&gt; 기능은 이름에서 전해지듯이 작업을 체인처럼 줄줄이 수행합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from celery import chain

@app.task
def fetch_page_by_url(url, append_text=None):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        if append_text is None
            return res.text
        else:
            res.text + append_text

tasks = []
for i in range(0, 10):
    tasks.append(
        fetch_page_by_url.subtask(
            'http://localhost:8000/{}.html'.format(i)
        )
    )

result = chain(tasks)()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;subtask()&lt;/code&gt;는 Celery 작업 객체를 하위 작업으로 수행하는 메서드입니다&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url&lt;/code&gt; 객체를 하위 작업으로 수행하는 작업 열 개를 담아 &lt;code class=&quot;highlighter-rouge&quot;&gt;chain()&lt;/code&gt;에 전달하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;chain()&lt;/code&gt;은 순서대로 작업을 수행합니다. 각 작업이 반환하는 객체는 다음 작업자에게 인자로 전달합니다. 첫 번째 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt; 함수가 반환하는 웹페이지 문자열을 두 번째 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;는 두 번째 인자로 받는 것이죠. 그래서 두 번째 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;부터는 앞 작업자가 반환하는 결과를 넘겨 받는 것이지요.&lt;/p&gt;

&lt;p&gt;다른 예를 들어 보겠습니다. 숫자 두 개를 인자로 전달하면 두 숫자를 더하는 작업자를 쓰겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;첫 번째 셈은 1 + 1 입니다.&lt;/li&gt;
  &lt;li&gt;두 번째 셈은 첫 번째 덧셈 결과를 받아서 10을 더합니다.&lt;/li&gt;
  &lt;li&gt;세 번째 셈은 두 번째 덧셈 결과를 받아서 100을 더합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이걸 &lt;code class=&quot;highlighter-rouge&quot;&gt;chain()&lt;/code&gt;을 이용하면 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;do_chain_tasks = chain(add.s(1, 1), add.s(10), add.s(100))
do_chain_tasks()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chain()&lt;/code&gt;도 바로 작업을 수행하는 게 아니라 Celery 작업 객체를 반환하며&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;, 이 작업 객체를 실행해야 합니다. 바로 위 코드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;chain(...)()&lt;/code&gt;라는 구문을 나눈 것입니다.&lt;/p&gt;

&lt;p&gt;재밌는 점은 Celery는 비트 연산으로도 &lt;code class=&quot;highlighter-rouge&quot;&gt;chain()&lt;/code&gt; 작업 객체를 만들어 준다는 점입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(
    fetch_page_by_url.s('http://localhost:8000/0.html') |
    fetch_page_by_url.s('http://localhost:8000/1.html') |
    fetch_page_by_url.s('http://localhost:8000/2.html') |
    fetch_page_by_url.s('http://localhost:8000/3.html')
).apply_async()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참 꼼꼼하게 만들어 놨어요. :)&lt;/p&gt;

&lt;h3 id=&quot;chord-기능&quot;&gt;chord 기능&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chain()&lt;/code&gt;을 이용해 비동기로 열 개 작업을 수행하고 그 결과를 합쳤는데, 아쉬운 마음이 듭니다. 전체 작업 자체는 분명 비동기로 시작한 게 맞지만, 웹페이지를 긁어오는 작업도 동시에 분산해서 처리하면 더 효율이 좋을 겁니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;chord()&lt;/code&gt;는 하위 작업을 동시에 수행하고, 각 작업자가 반환하는 값을 callback 실행 객체로 전달해줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from collections import MutableSequence
from celery import chord

@app.task
def fetch_page_by_url(url):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text

@app.task
def merge_text(texts):
    assert(isinstance(texts, MutableSequence))
    return texts.join('')

tasks = []
for i in range(0, 10):
    tasks.append(
        fetch_page_by_url.s('http://localhost:8000/{}.html'.format(i))
    )

do_chain_tasks = chord(tasks)
do_chain_tasks(merge_text.s())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt; 함수가 원래대로(?) 돌아왔고, &lt;code class=&quot;highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt; 함수가 새로 추가됐습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt;는 전달받은 인자 &lt;code class=&quot;highlighter-rouge&quot;&gt;texts&lt;/code&gt;를 합치는 일을 하는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;가 반환하는 문자열을 담은 리스트형(&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;) 객체입니다. 맨 처음에 비동기로 작성한 코드에서 웹페이지 문자열을 리스트로 담은 &lt;code class=&quot;highlighter-rouge&quot;&gt;merged_text&lt;/code&gt;와 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chord()&lt;/code&gt;는 각 작업자(&lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;)가 반환하는 값을 리스트형으로 모아서 callback 객체에게 인자로 전달합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;chord()&lt;/code&gt;로 만든 Celery 작업 객체로 callback 객체를 전달할 때 인자를 지정하지 않아도 됩니다. 알아서 넣어 줍니다.&lt;/p&gt;

&lt;p&gt;근데 이 코드엔 사소하다면 사소하고 심각하다면 심각한 문제가 있습니다. 작업들을 비동기로 수행하다보니 웹페이지 문자열이 우리가 원하는 순서대로 담겨져 &lt;code class=&quot;highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt;로 전달된다는 보장이 없습니다. 작업이 먼저 끝나는 순서대로 결과가 담기니 0 - 1 - 2 - 3 … 순서가 될 지 9 - 4 - 7 - 1 순서가 될 지는 아무도 모릅니다.&lt;/p&gt;

&lt;p&gt;여러 해결책이 있겠지만, 각 작업자마다 순번을 주고, &lt;code class=&quot;highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt;는 이 순번대로 문자열을 합치면 되겠네요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@app.task
def fetch_page_by_url(url, num):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text, num

@app.task
def merge_text(texts):
    assert(isinstance(texts, MutableSequence))
    texts.sort(key=lambda x: x[1])
    return texts.join('')

tasks = []
for i in range(0, 10):
    tasks.append(
        fetch_page_by_url.s(
            'http://localhost:8000/{}.html'.format(i), i
        )
    )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;에 두 번째 인자로 순번(&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;)을 전달하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;는 받은 순번을 웹페이지 문자열과 함께 그대로 반환합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt;가 전달받은 &lt;code class=&quot;highlighter-rouge&quot;&gt;texts&lt;/code&gt;엔 각 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt; 결과가 &lt;code class=&quot;highlighter-rouge&quot;&gt;[(문자열, 0), (문자열, 3), ...]&lt;/code&gt; 형태로 담깁니다. 그래서 각 항목의 두 번째(&lt;code class=&quot;highlighter-rouge&quot;&gt;[1]&lt;/code&gt;) 값으로 정렬하고 나서 한 문자열로 합친 것입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://celery.readthedocs.org/en/latest/userguide/canvas.html#the-primitives&quot;&gt;Canvas: Designing Workflows : The primitives&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://celery.readthedocs.org/en/latest/userguide/tasks.html#avoid-launching-synchronous-subtasks&quot;&gt;Tasks : Avoid launching synchronous subtasks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;대개는 &lt;code class=&quot;highlighter-rouge&quot;&gt;delay()&lt;/code&gt;라는 메서드로 줄여서 수행합니다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;대개는 &lt;code class=&quot;highlighter-rouge&quot;&gt;s()&lt;/code&gt;로 줄인 메서드 이름을 씁니다. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chain&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;chord&lt;/code&gt;는 함수처럼 생겼지만 클래스입니다. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Wed, 08 Jul 2015 17:25:00 +0900</pubDate>
        <link>http://localhost:4000//2015/07/celery_chord_and_chain/</link>
        <guid isPermaLink="true">http://localhost:4000//2015/07/celery_chord_and_chain/</guid>
        
        <category>python</category>
        
        <category>celery</category>
        
        <category>asynchronous</category>
        
        <category>distributed</category>
        
        
        <category>devlife</category>
        
      </item>
    
  </channel>
</rss>
