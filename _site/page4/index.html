<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <script src="//cdn.optimizely.com/js/3144930209.js"></script>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on iPhones and stuff-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="icon" type="image/png" href="http://blog.hannal.com/favicon.ico" />
  <link rel="alternate" type="application/rss+xml" title="Kay on the rails RSS Feed" href="http://blog.hannal.coom/feed.xml" />
  <title>
    
      Kay on the rails &middot; 
    
  </title>
  <meta property="og:title" content="Kay on the rails &middot; " />
  <meta property="og:site_name" content="Kay on the rails"/>
  <meta property="og:url" content="http://blog.hannal.com" />
  <meta property="fb:app_id" content="308847979152210" />
  <meta property="og:type" content="article" />

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  <!-- Icons -->
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <style>
  .posts h2.post-title {
    font-size: 1.6em !important;
  }

  .post-parting-line {
    border-top: 7px solid #eee !important;
    border-bottom: 7px solid #fff !important;
  }
  </style>
</head>


  <body>
    <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ko_KR/sdk.js#xfbml=1&appId=308847979152210&version=v2.0";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Kay as known as Hannal walks on the rails
</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    <a class="sidebar-nav-item" href="/category/essay/">한날의 낙서</a>
    <a class="sidebar-nav-item" href="/category/kay-on-the-team/">팀과 함께하는 한날</a>
    <a class="sidebar-nav-item" href="/category/start-with-django-lectures/">Django 입문자용 강좌</a>
    <a class="sidebar-nav-item" href="/category/start-with-django-webframework/">Django 중급자용 강좌</a>
    <a class="sidebar-nav-item" href="/category/flaskon-startup-diary/">플라스콘 창업 일지</a>
    <a class="sidebar-nav-item" href="/category/devlife/">개발 생활</a>
    <a class="sidebar-nav-item" href="/category/game/">게임 생활</a>
  </nav>

  <nav class="sidebar-nav" style="margin-top: 1.2em;">
    <a class="sidebar-nav-item" href="/profile/">소개합니다</a>
    <a class="sidebar-nav-item" href="/fingers/">손 끝에 맺힌 글</a>
    <a class="sidebar-nav-item" href="/copyright/">저작권</a>

    
    <span class="sidebar-nav-item">Alpha v</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2016. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Kay on the rails</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h2 class="post-title">
      <a href="/2015/06/start_with_django_webframework_08/">
        8. 로그인, 로그아웃 하기
      </a>
    </h2>

    <span class="post-date">07 Jun 2015</span>

    <ul>
<li><a href="http://blog.hannal.com/category/start-with-django-webframework/">날로 먹는 Django 웹프레임워크 강좌 목차</a></li>
<li>마지막 갱신일시 : 2015년 6월 7일 7시 19분</li>
</ul>

<p>이번 편에서는 Django 이용자 인증 체계을 알아보고, 이 인증 체계에서 로그인을 어떻게 처리하는지 살펴 보겠습니다.</p>

<h3>1. Django 이용자 인증 체계</h3>

<p>Django 이용자 인증 체계는 크게 두 가지 요소로 구분합니다.</p>

<ul>
<li>인증 (Authentication)</li>
<li>권한 (Authorization)</li>
</ul>

<p>인증은 “나 누구인데 확인 좀...”이라면 권한은 “나 이거 해도 돼요?”라 보면 됩니다. 누구인지 신원이 확인되지 않은 존재에게 권한을 세밀하게 부여하진 못합니다. 신원이 확인된, 즉, 인증된 이용자인지 아닌지로 구분하는 정도로 권한을 부여합니다. 그래서, 권한 체계를 비롯하여 이용자 인증 체계 자체는 인증(Authetication)을 바탕으로 합니다.</p>

<h4>(1) Django 내장 인증 기능</h4>

<p>Django는 이용자 인증 체계를 내장하고 있으며, 우리는 이미 이 기능을 사용해봤습니다. <a href="http://blog.hannal.com/2014/10/start_with_django_webframework_04/">4. Photo 모델로 Admin 영역에서 데이터 다루기</a> 편에서 최고 권한 이용자로 Admin 영역에 로그인하여 사진 게시물을 입력 했었거든요.</p>

<p>Django에 내장된 인증 체계는 <code>django.contrib.auth</code>라는 경로(name space)인 Python 패키지에 모여 있으며, Django 개념으로는 Django App입니다. <code>settings.py</code> 파일에 있는 <code>INSTALLED_APPS</code> 설정 항목을 보면 <code>&#39;django.contrib.auth&#39;,</code>가 있는데, 우리가 만드는 Pystagram에 사용할 Django App에 Django 인증 체계가 앱 형태로 기본 내장되어 있는 것입니다.</p>

<p>Django webframework으로 제품을 만든다면 Django 인증 체계를 사용하는 게 좋습니다. 오랜 기간 개발되어 보안 수준은 성숙하고 안전하며, 확장 가능하게 유연합니다. Django에서 제공하는 다른 여러 기능이 내장된 인증 기능 구조를 따르기 때문에 Django가 제공하는 기능을 유기성 있고 풍부하게 쓰기에도 Django 인증 체계를 쓰는 게 좋습니다.</p>

<h4>(2) Django 내장 권한 기능</h4>

<p>권한 검사 기능도 Django에 내장되어 있습니다. 뷰(View) 단위 행동(behaviour), 데이터 단위 행동에 권한을 부여하여 운용 가능하며, 권한을 그룹 단위로 묶어서(grouping) 이용자에게 지정하는 기능도 제공합니다. 자세한 내용은 권한 기능을 적용할 때 다루겠습니다.</p>

<h3>2. 로그인 기능 구현</h3>

<h4>(1) URL 패턴 추가</h4>

<p>Django에서 제공하는 인증 기능을 이용하여 로그인, 로그아웃 기능을 구현 하겠습니다. <code>settings.py</code> 파일이 있는 시작패키지에서 <code>urls.py</code> 파일을 열고, 다음 URL 패턴을 <code>urlpatterns</code>에 추가합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">urlpatterns = patterns(
    &#39;&#39;,
    # 중략
    url(
        r&#39;^accounts/login/&#39;,
        &#39;django.contrib.auth.views.login&#39;,
        name=&#39;login&#39;,
        kwargs={
            &#39;template_name&#39;: &#39;login.html&#39;
        }
    ),
    url(
        r&#39;^accounts/logout/&#39;,
        &#39;django.contrib.auth.views.logout&#39;,
        name=&#39;logout&#39;
    ),
)
</code></pre></div>
<p><code>r&#39;^accounts/login/&#39;</code>은 로그인 하는 URL이고, 로그인 화면을 출력하거나 로그인 인증 처리를 하는 뷰 함수는 Django에 내장된 <code>login</code> 뷰 함수를 사용합니다. 이 함수 객체는 <code>django.contrib.auth.views</code> 모듈에 존재합니다. 이 URL 패턴의 이름을 <code>name</code> 키워드 인자를 이용하여 <code>login</code>이라고 지었는데, 이 인자를 사용하지 않아도 무방합니다. <code>kwargs</code>는 URL 패턴에 연결한 뷰 함수에 추가로 전달할 인자를 사전형(<code>dict</code>) 객체로 전달합니다. 키가 <code>&#39;template_name&#39;</code>이고 값이 <code>&#39;login.html&#39;</code>인 사전형 객체인데, Django에서 제공하는 <code>login</code> 뷰 함수에 <code>template_name</code> 이름으로 키워드 인자를 지정하면 로그인 화면을 출력하는 데 사용할 템플릿으로 사용합니다. <code>&#39;login.html&#39;</code>이라는 문자열을 지정했으니 우리가 <code>settings.py</code>에서 <code>TEMPLATE_DIRS</code>에 지정한 템플릿 디렉터리 중 최상위 순위에 있는 <code>login.html</code> 파일을 찾아서 로그인 화면을 출력하는 데 사용합니다.</p>

<p><code>r&#39;^accounts/logout/&#39;</code>은 로그아웃 하는 URL이며, 로그아웃 기능 역시 로그인 기능과 마찬가지로 Django에 내장된 뷰 함수를 사용합니다.</p>

<h4>(2) 로그인 템플릿 파일</h4>

<p>이번엔 로그인 화면에 사용할 <code>login.html</code> 템플릿 파일을 만듭니다. <code>templates</code> 디렉터리에 <code>login.html</code> 파일을 만들고 다음 내용을 담습니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{% extends &quot;layout.html&quot; %}

{% block content %}

{% if form.errors %}
&lt;p&gt;ID나 비밀번호가 일치하지 않습니다.&lt;/p&gt;
{% endif %}

{% if next %}
    {% if user.is_authenticated %}
    &lt;p&gt;권한이 없는 페이지에 접근하였으니, 권한이 있는 계정으로 로그인하세요.&lt;/p&gt;
    {% else %}
    &lt;p&gt;이 페이지를 보려면 로그인을 해야 합니다.&lt;/p&gt;
    {% endif %}
{% endif %}

&lt;form method=&quot;post&quot; action=&quot;{% url &#39;login&#39; %}&quot;&gt;
{% csrf_token %}
&lt;table&gt;
&lt;tr&gt;
    &lt;td&gt;{{ form.username.label_tag }}&lt;/td&gt;
    &lt;td&gt;{{ form.username }}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;td&gt;{{ form.password.label_tag }}&lt;/td&gt;
    &lt;td&gt;{{ form.password }}&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;input type=&quot;submit&quot; value=&quot;로그인&quot; /&gt;
&lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;{{ next }}&quot; /&gt;
&lt;/form&gt;

{% endblock %}
</code></pre></div>
<p>Django에서 견본으로 제공하는 <a href="https://docs.djangoproject.com/en/1.8/topics/auth/default/#django.contrib.auth.views.login">login.html 템플릿 파일</a>에서 따와서 약간 고쳤습니다. <code>form.errors</code>엔 입력한 폼 양식에 문제가 있는 경우에 문제 내용이 담겨 있습니다. ID(<code>username</code>)나 비밀번호를 입력하지 않거나 형식에 맞지 않는 등 여러 오류 종류가 있겠지만, 간결하게 ID와 비밀번호가 일치하지 않는다고만 안내합니다. 로그인에 대해서는 굳이 친절하게 뭐가 문제인지 자세히 알려줄 필요는 없습니다.</p>

<p><code>{% if next %}</code>에서 <code>next</code>는 로그인을 한 후 이동할 URL을 뜻합니다. 예를 들어, 로그인을 하지 않은 채 사진에 달린 댓글을 삭제하려 하면 로그인하는 URL로 이동하고 로그인을 하고 나면 로그인하기 전에 접근하려는 URL으로 이동하는데, 이동할 URL이 GET이나 POST 방식으로 전달된 Query String 키인 <code>next</code>에 담깁니다. 대개는 URL이 <code>https://pystagram.com/accounts/login/?next=/redirect_to_here/</code>와 같이 표현됩니다.</p>

<p>이동할 곳이 있는데(<code>{% if next %}</code>) 로그인한 상태에서 로그인 URL에 왔다는 건 무슨 뜻일까요? 현재 로그인한 이용자 인증이나 권한 상태로는 문제가 있으니 다른 계정으로 로그인하라는 의미입니다. 로그인을 하지 않았다면, 로그인을 해야 접근 가능한 페이지이니 로그인을 하라고 안내합니다.</p>

<p>그외엔 <a href="http://blog.hannal.com/2015/05/start_with_django_webframework_07/">7. 사진 게시물 제출하여 게시하기</a> 편 내용과 비슷합니다. <code>form</code>은 <code>django.contrib.auth.forms</code> 모듈에 있는 <code>AuthenticationForm</code> 폼 클래스로 생성한 인스턴스 객체입니다. 이 폼에 있는 <code>username</code> 폼 필드와 <code>password</code> 폼 필드를 사용한 것입니다. <code>username</code>은 이용자의 실명이나 필명이 아니라 이용자 ID라고 보면 됩니다.</p>

<p>이제 <code>http://localhost:8000/accounts/login/</code>에 접속하면 로그인 화면이 나옵니다. 잘못된 <code>username</code>과 <code>password</code>을 제출하면 이에 대한 안내도 나오고요.</p>

<p><img src="/assets/uploads/2015/06/08-login_form_01.png" alt=""></p>

<p><img src="/assets/uploads/2015/06/08-login_form_02.png" alt=""></p>

<p>현재 구현한 로그인 기능으로 로그인을 하면 “Page not found” 오류를 만나게 됩니다. 이에 대해서는 곧 처리하겠습니다.</p>

<p><img src="/assets/uploads/2015/06/08-404_after_login.png" alt=""></p>

<h3>3. 로그인 과정</h3>

<p>Django가 제공하는 로그인 뷰 함수가 어떤 과정을 거쳐 이용자 인증을 처리하는지 좀 더 살펴 보겠습니다. 이 부분을 몰라도 로그인 기능을 이용하는 데 문제 없습니다.</p>

<h4>(1) Form 검증</h4>

<p>웹 페이지에서 폼 양식으로 넘어오는 값은 Form을 이용해 값을 검증합니다. Django는 로그인 절차에 <code>AuthenticationForm</code> 폼을 사용하며, 이 폼은 <code>django.contrib.auth.forms</code> 모듈에 있습니다. 이쯤되면 눈치 채셨을텐데, Django는 인증 관련 모델, 폼, 뷰, 미들웨어 등을 <code>django.contrib.auth</code> 패키지 안에 담아 놨습니다. 인증과 관련된 소스 코드를 보려면 이 패키지를 살펴 보시면 됩니다.</p>

<p><code>AuthenticationForm</code> 폼은 현재 이용자 정보와 HTTP 요청 정보를 담은 <code>request</code> 객체도 함께 인자로 전달 받는데, 세션 처리에 필요하기 때문에 그렇습니다. 폼 양식 값이 유효하면(<code>is_valid()</code>) 이용자가 로그인 후에 이동할 URL 문자열이 안전한 지 검사합니다. 그런 뒤 <code>auth_login()</code> 함수를 이용해 로그인 인증 처리를 마무리하고 나서 이용자를 다음 URL로 이동(redirect) 시킵니다.</p>

<p><code>auth_login()</code> 함수는 이름과는 달리 실제로는 인증 과정 마무리 단계를 담당합니다. 로그인 양식을 토대로 이용자 정보를 가져와서 HTTP Request(<code>request</code>) 정보와 함께 사용해 서버 세션 정보를 만듭니다. 세션 정보를 만들지 않으면 로그인 정보는 유지되지 않아서 다른 페이지에 방문할 때마다 매번 로그인을 해야 합니다.</p>

<p>로그인 양식, 그러니까 로그인 하려고 제출한 <code>username</code>과 <code>password</code>에 정확히 일치하는 이용자를 찾는 과정은 <code>AuthenticationForm</code> 폼에서 이뤄집니다. 이 폼의 <code>clean()</code> 메서드에서 <code>username</code>과 <code>password</code> 내용을 토대로 <code>authenticate()</code> 함수를 이용해 인증을 시도합니다. 일치하는 이용자가 없으면 Form 오류를 일으키고, 우리는 “ID나 비밀번호가 일치하지 않습니다.”라는 안내를 화면에서 만납니다. 일치하는 이용자가 있으면 이 이용자 계정이 활성화 된 상태인지(<code>is_active</code>) 검사하는 걸로 폼 안에서 처리하는 인증 과정을 마칩니다.</p>

<h4>(2) 인증 체계 기반으로 처리</h4>

<p><code>authenticate()</code> 함수는 <code>settings</code>의 <code>AUTHENTICATION_BACKENDS</code> 항목에 등록된 인증 체계 기반 클래스를 하나씩 가져와서 <code>authenticate()</code> 메서드를 호출하여 인증을 시도합니다. 우리가 <code>settings.py</code> 파일에 따로 이 항목을 설정하지 않아도 문제가 없는 건, Django에 기본으로 내장된 <code>global_settings.py</code>에 이 항목이 설정되어 있기 때문입니다. 이 항목에 있는 내용은 <code>&#39;django.contrib.auth.backends.ModelBackend&#39;</code> 이름영역인 클래스가 튜플 객체로 담겨 있습니다.</p>

<p>데이터베이스에서 <code>username</code>와 <code>password</code>로 이용자를 찾는 과정이 비로소 이 단계에서 이뤄집니다. 이용자 모델을 가져오고, 이 모델을 이용해 <code>username</code>으로 먼저 이용자 데이터를 가져오고, 이 이용자 데이터에 저장된 비밀번호와 이용자가 로그인하며 제출한 <code>password</code>를 비교합니다. 비밀번호까지 일치하면 해당 이용자 데이터, 그러니까 이용자 모델로 생성한 인스턴스 객체를 반환하고, 그렇지 않으면 <code>None</code>을 반환합니다.</p>

<p><code>settings</code>의 <code>AUTHENTICATION_BACKENDS</code> 항목에 <code>django.contrib.auth.backends.ModelBackend</code>이 튜플에 담겨져 있다는 말은 다음 두 가지를 의미합니다.</p>

<ol>
<li>Django 인증 체계 기반(backend)을 꼭 사용하지 않아도 된다.</li>
<li>인증 체계 기반을 여러 개 이상을 사용하는 게 가능하다.</li>
</ol>

<p>인증 체계 기반의 클래스 규칙대로 인터페이스를 만들기만 한다면 우리가 직접 만든 인증 체계를 사용하거나 Facebook, Twitter처럼 인증 API를 제공하는 서비스나 플랫폼을 기반으로 인증 체계를 운용해도 됩니다.</p>

<h4>(3) 이용자 모델 가져오기</h4>

<p>인증 체계 기반을 Django에서 제공하는 기본 인증 <code>ModelBackend</code>를 다른 것으로 갈아끼우거나 추가한다면, 이용자 정보를 데이터베이스에서 다루는 이용자 모델도 대체하여 쓸 수 있습니다. Django에 내장된 이용자 모델은 <code>django.contrib.auth.models</code>에 <code>User</code> 모델 클래스입니다. 이 이용자 모델엔 모델 필드이 간결하게 담겨 있습니다.</p>

<ul>
<li><code>username</code> : 이용자 ID 역할. 다른 값과 중복되지 않는 고유한 값만 허용합니다(<code>unique=True</code>).</li>
<li><code>password</code> : 비밀번호. <code>PasswordField</code> 모델 필드.</li>
<li><code>first_name</code> : 성씨. <code>CharField</code> 모델 필드이며 생략 가능.</li>
<li><code>last_name</code> : 이름. <code>CharField</code> 모델 필드이며 생략 가능.</li>
<li><code>email</code> : 전자우편 주소. <code>EmailField</code> 모델 필드.</li>
<li><code>is_staff</code> : 관리자 여부. <code>BooleanField</code> 모델 필드.</li>
<li><code>is_active</code> : 활성화 된 계정인지 여부. <code>BooleanField</code> 모델 필드.</li>
</ul>

<p>이외에도 <code>is_superuser</code>나 <code>groups</code> 같은 모델 필드 몇 가지가 더 있지만, 이 모델 필드의 값을 직접 다룰 일은 드물고, 이 강좌 내용을 이해하시면 이런 모델 필드를 직접 찾아 다루는 건 어렵지 않으므로 이 강좌에선 다루지 않겠습니다.</p>

<p>만약, 필명이나 사용하는 언어, 거주 지역처럼 정보를 추가로 이용자로부터 입력 받아 관리하려면 이용자 모델 클래스를 <strong>확장</strong>해야 합니다. Django에서 제공하는 이용자 모델을 변경해도 되지만, Django 소스 파일을 직접 고쳐서 쓰지 않는 게 좋습니다. Django 판을 올릴 때마다 직접 수정한 부분을 매번 챙겨야 하고, 연계되어 동작하는 다른 기능에 부작용을 일으킬 여지도 있습니다. 그래서 변경하지 않고 <strong>확장</strong>해야 합니다.</p>

<p>확장하는 자세한 방법은 다른 편에서 따로 다루기로 하고<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>, 여기에선 확장 방법 종류만 간단히 언급하겠습니다.</p>

<ol>
<li>따로 이용자 모델을 만들고, Django의 이용자 모델에 연결(Model relationship).</li>
<li>이용자 모델과 모델 매니저, 이용자 폼 등을 모두 구현하여 이용자 모델 부분을 대체.</li>
</ol>

<p>2번 방법에서 “모델 부분을 대체”한다는 표현을 눈 여겨 보세요. 일일이 Django 소스에서 이용자 모델 관련 부분, 가령, <code>django.contrib.auth.models.User</code>를 <code>pystagram_auth.models.User</code>와 같이 교체하는 건 아닙니다. <code>settings</code>의 <code>AUTH_USER_MODEL</code> 항목에 지정하기만 하면 됩니다.</p>

<p>이 항목 역시 우리가 따로 설정한 적이 없는데, Django의 <code>global_settings</code>에 설정되어 있으며, 기본 값으로 <code>&#39;auth.User&#39;</code> 문자열이 할당되어 있습니다. <code>auth</code>는 Django 앱 이름(Python 패키지)이고, <code>User</code>는 모델 클래스 이름입니다. Python 이름영역(name space)으로 풀어 쓰면 <code>auth.models.User</code>인 셈입니다.</p>

<p><code>settings</code>의 <code>AUTH_USER_MODEL</code> 설정 항목을 참조하여 이용자 모델을 실제로 가져오는 역할은 <code>get_user_model()</code> 함수가 맡으며, <code>django.contrib.auth</code>에 있습니다. 이 함수를 이용하면 이용자 모델이 어떤 것으로 바뀌든 코드를 일관되게 유지하게 됩니다. <code>AUTH_USER_MODEL = &#39;auth.User&#39;</code>라고 설정하고 <code>get_user_model()</code> 함수를 실행하면 <code>auth.models.User</code>를 반환하고, <code>AUTH_USER_MODEL = &#39;pystagram_auth.MyUser&#39;</code>로 설정하고 실행하면 <code>pystagram_auth.models.MyUser</code>를 이용자 모델로 반환합니다. 그러므로 <code>get_user_model()</code> 함수로 이용자 모델을 가져오는 게 좋습니다.</p>

<p>인증 체계 기반(backend)과는 달리 기본 이용자 모델은 하나만 가능합니다.</p>

<h4>(4) 정리하면</h4>

<p>로그인 과정을 정리하면 다음과 같습니다.</p>

<ul>
<li><code>django.contrib.auth.views.login</code>

<ul>
<li><code>django.contrib.auth.forms.AuthenticationForm</code>

<ul>
<li><code>django.contrib.auth.authenticate()</code>

<ul>
<li><code>settings.AUTHENTICATION_BACKENDS</code>에서 인증 기반 하나씩 가져옴</li>
<li><code>django.contrib.auth.backends.ModelBackend</code>의 <code>authenticate()</code> 메서드로 인증 처리</li>
</ul></li>
</ul></li>
<li><code>django.contrib.auth.auth_login</code> (정확히는 <code>django.contrib.auth.login</code>를 <code>auth_login</code>으로 import 한 것.)으로 인증 관련 세션 처리</li>
</ul></li>
<li>로그인 이후 이동할 URL로 이동 처리(redirect)</li>
</ul>

<h3>4. 로그인 관련 설정 항목</h3>

<p><code>settings.py</code>에 설정하는 로그인 관련 항목이 몇 가지 있습니다.</p>

<h4>(1) <code>LOGIN_URL</code></h4>

<p><code>LOGIN_URL</code>은 로그인 URL을 뜻합니다. Django에서 제공하는 장식자(decorator) 중 <code>login_required</code>는 뷰 함수에 접근할 때 로그인 여부를 검사하고, 로그인하지 않으면 로그인 URL로 이용자를 이동시키는데, 이 로그인 URL을 <code>settings.LOGIN_URL</code>에서 가져 옵니다. <code>global_settings</code>에 설정된 기본값은 <code>/accounts/login/</code>입니다.</p>

<h4>(2) <code>LOGOUT_URL</code></h4>

<p><code>LOGIN_URL</code>과 같은 역할을 합니다. 기본값은 <code>/accounts/logout/</code>입니다.</p>

<h4>(3) <code>LOGIN_REDIRECT_URL</code></h4>

<p>로그인을 하고 나서 이동할 URL을 설정합니다. 로그인 하고나서 이동할 URL이 지정된 경우 그 URL로 이동하지만, 이동할 URL이 지정되지 않았거나 지정한 URL이 보안상 문제가 있는 경우 <code>settings.LOGIN_REDIRECT_URL</code>를 사용합니다.</p>

<p>현재 구현한 기능으로는 로그인을 마치면 “Page not found” 오류를 만납니다.</p>

<p><img src="/assets/uploads/2015/06/08-404_after_login.png" alt=""></p>

<p>웹 브라우저 주소입력란을 잘 보면 <code>http://localhost:8000/accounts/profile/</code>과 같이 전혀 본 적 없는 URL로 되어 있습니다. 이는 Django 기본 <code>LOGIN_REDIRECT_URL</code> 설정값이 <code>/accounts/profile/</code>이라서 그렇습니다. 아직 우리는 프로필 페이지를 만들지 않았으니 임시로 <code>/photo/upload/</code>로 이동하도록 설정하겠습니다. 시작패키지에서 <code>settings.py</code> 파일을 열고 다음 코드를 추가합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">LOGIN_REDIRECT_URL = &#39;/photo/upload/&#39;
</code></pre></div>
<p>이제 로그인을 마치면 <code>/photo/upload/</code>로 이동하여 사진을 올리라는 압박을 줍니다.</p>

<hr>

<p>강좌 8편을 마칩니다. 아직은 Django 1.7판을 기준으로 강좌를 진행하고 있는데, 조만간 1.8판을 기준으로 내용을 다듬어야 겠습니다.</p>

<ul>
<li><a href="https://github.com/hannal/start_with_django_webframework/tree/08-fullsource/pystagram">8편까지 진행한 전체 소스 코드</a></li>
</ul>

<hr>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>다른 편에서 다루겠다는 내용이 늘어가니 불안해지네요. 까먹고 다루지 않을까봐요.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

  </div>
  <hr class="post-parting-line" />
  
  <div class="post">
    <h2 class="post-title">
      <a href="/2015/05/start_with_django_webframework_07/">
        7. 사진 게시물 제출하여 게시하기
      </a>
    </h2>

    <span class="post-date">18 May 2015</span>

    <ul>
<li><a href="http://blog.hannal.com/category/start-with-django-webframework/">날로 먹는 Django 웹프레임워크 강좌 목차</a></li>
<li>마지막 갱신일시 : 2015년 6월 11일 4시 25분</li>
</ul>

<p>그동안 우리는 사진 게시물을 Django Admin에서 게시했습니다. 이번엔 사진 게시물을 게시하는 기능을 구현하겠습니다. Django Form을 이용할 것인데, 이번 편에서는 왜 Django Form을 쓰면 좋고, 어떻게 동작하는 지 흐름을 이해하는 내용을 다루겠습니다.</p>

<h3>1. Django Form</h3>

<p>Django Form은 Django의 주요 매력 요소 중 하나라 생각합니다. <a href="http://blog.hannal.com/2014/9/start_with_django_webframework_03/">Django는 MTV 패턴을 따른다</a>고 하는데, Django Model과 Form을 활용하면 반복되는 처리를 Django가 대신 하고 이용자는 데이터(model)와 표현물(template)에 집중하게 됩니다.</p>

<p>Form은 이름에서 드러나듯이 입력 양식(form)을 다루는 기능입니다. “입력 양식”이란 Django가 웹 프레임워크이니 웹 입력 양식을 뜻합니다. Django Form은 HTML로 만든 웹 화면의 form 태그에서 서버로 전달된 항목이 유효한 지 검증(validation)할 뿐만 아니라 웹 입력 항목에 필요한 HTML 태그를 생성해 출력합니다. 유효하지 않은 항목이 있으면 어떻게 유효하지 않은 지 안내말을 출력하기도 합니다.</p>

<p>유효성은 꼼꼼하게 검사(validation)해야 합니다. 보안 측면에서 클라이언트(서비스 이용자)가 서버로 보내오는 데이터는 그다지 신뢰해서는 안 됩니다. 우리 서비스를 위태롭게 할 코드가 숨겨져 있을지도 모릅니다. 운영 측면에서도 이용자가 system이나 admin과 같이 운영자를 사칭하는 계정 이름을 짓거나 화면을 망가뜨리거나 다른 이용자의 권한을 가로채는 서비스 앞단(front-end)용 코드를 심을지도 모릅니다.</p>

<p>보안성을 높이려면 마냥 뚫고 들어오지 못 하게 폐쇄하기만 할 게 아니라 개방할 필요도 있습니다. 개발자 또는 개발팀이 아무리 뛰어난 능력을 가졌어도 갈수록 증가하는 소프트웨어 복잡성에서 발생하는 수많은 경우와 상황에 대응하는 건 불가능합니다. 또한 서비스에 구현된 모든 기능을 완전히 직접 구현하여 제공하는 것이 아닌 이상 우리가 만드는 소프트웨어는 다른 소프트웨어나 도구와 연결되는데, <a href="http://blog.dahlia.kr/post/82482810330">우리가 만든 소프트웨어의 바깥 환경이 변하면서 우리가 만든 소프트웨어도 녹슬어</a> 끊임없이 새로운 문제에 부딪히게 됩니다. 이 문제는 폐쇄하여 감출 게 아니라 오히려 개방하여 더 드러내서 많은 사람이 문제를 발견하는 게 낫습니다. Django는 오픈소스 프로젝트이며, 많은 개발자가 참여하고 기여하고 사용합니다. Django처럼 애용되고 활성화 된 오픈소스 프로젝트는 사람이 유발하는 보안 구멍을 주시하는 눈이 많아서 우리가 직접 구현하는 것보다 더 신뢰할 만하다고 생각합니다. 우리의 능력이 뛰어나든 그렇지 않든 말이지요.</p>

<p>운영 측면에서 대응해야 할 대응은 반복되는 처리가 많습니다. 예를 들어, 숫자만 입력받을 항목에 숫자 외 다른 글자가 입력되었는지 검사하고 들어 있으면 예외 처리하거나 첨부한 이미지 파일이 제대로 된 파일인지 검사하는 처리는 항목 개수만큼이나 반복되는 과정입니다. 이를 일일이 코드로 검사한다면 실수할 가능성이 큽니다. 일관성과 관리 차원에서 그러한 역할을 하는 검사기(validator)를 만들어 처리하는 게 좋습니다.</p>

<p>이렇게 클라이언트로부터 전송받은 데이터가 유효한지 검사하고 걸러내는 역할을 Django Form가 합니다. Django Form을 사용하면 상당히 다양한 입력 형식에 대해 수 년에 걸쳐 쌓인 경험으로 유효성을 검사합니다. 가령, Django Form의 <code>EmailField</code> 폼 필드를 사용하면, 다국어나 <code>.wiki</code>나 <code>.google</code>과 같은 새로운 최상위 도메인(Top-level domain), 심지어 IPv4나 IPv6와 같이 IP주소로 구성된 전자우편 주소에 대응 가능합니다.</p>

<p>물론 어디까지나 유효성을 검사하는 것이므로 제가 앞서 언급한 보안성에 대해 무결하지는 않습니다. 예를 들어, Django Form의 <code>ImageField</code> 폼 필드는 클라이언트가 제출한 파일이 <a href="https://github.com/django/django/blob/1.8.1/django/forms/fields.py#L691">이미지 파일로 유효한지 확인하는 방법을 Image Library인 PIL이나 Pillow의 <code>verify()</code>에 의존</a>합니다. <code>verify()</code> 메서드는 파일의 헤더 영역을 읽어 들여서 유효한 파일인지 검사할 뿐입니다. 그 마저도 일부 파일에 대해서만 제공하여, <a href="https://github.com/python-pillow/Pillow/blob/master/PIL/GifImagePlugin.py">GIF 파일</a>을 처리하는 모듈엔 <code>verify()</code>가 아예 없습니다. GIF, PNG, Jpeg과 같은 이미지 파일은 일반 문자열을 담는 Metadata 영역(chunk)을 지원하는데, 이 요소를 악용하여 보안을 위협하는 코드를 삽입하여 서버나 클라이언트(방문자)에게 해를 끼칠 가능성이 있습니다<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>.</p>

<p>하지만, 이는 Django Form이 보안에 초점을 맞춘 기능은 아니니 보안 대응용으로 Django Form에 의존하지 않아야 한다는 의미이며, 입력 항목이 유효한 지에 대한 필수 검사 요소는 갖추고 있으므로 Django Form을 가장 기본으로 사용하고 보안에 필요한 조치를 추가하는 것이 나을 것입니다.</p>

<h4>Form과 ModelForm</h4>

<p>Django Form은 <code>django.forms</code> 모듈에서 <code>Form</code>과 <code>ModelForm</code> 클래스로 제공됩니다. <code>Form</code>은 앞서 설명한 내용을 그대로 담고 있는 클래스입니다. <code>ModelForm</code>은 Django Model과 연계한 Form 클래스입니다. Django Model을 사용한다면 <code>ModelForm</code>을 이용하여 입력 양식과 입력 항목 검증, 그리고 검증된 입력 데이터를 데이터베이스에 저장하는 과정을 편하게 처리합니다.</p>

<p>자세한 건 코드로 구현하면서 다루겠습니다.</p>

<h3>2. 사진 게시물을 Form을 이용하여 게시하기</h3>

<h4>Form 만들기</h4>

<p><code>photo</code> 디렉터리에 <code>forms.py</code> 파일을 만듭니다. 앞으로 <code>photo</code> 앱에서 사용하는 Form은 이 모듈에 만듭니다. 이제 사진 게시물을 편집하는(생성하거나 수정) 폼을 <code>PhotoEditForm</code>이라는 이름으로 만듭니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># coding: utf-8

from __future__ import unicode_literals

from django import forms

from photo.models import Photo


class PhotoEditForm(forms.ModelForm):
    class Meta:
        model = Photo
</code></pre></div>
<p>아주 간결한 코드입니다. <code>forms</code> 모듈에 있는 <code>ModelForm</code> 클래스를 상속받는 <code>PhotoEditForm</code> 클래스를 만들면 이 클래스는 Form 클래스입니다. <code>ModelForm</code>이므로 클래스 안에 <code>Meta</code> 클래스를 또 만들고, 그 안에 <code>model = Photo</code>라는 코드로 이 Model form에 연계하는 Model을 <code>Photo</code>로 지정한 것입니다. 이 <code>Photo</code> 모델 클래스는 <code>photo</code> 앱 디렉터리의 <code>models.py</code> 모듈에 있으니 <code>from photo.models import Photo</code>로 읽어 들인 것입니다.</p>

<p><code>ModelForm</code>은 Form에 연결한 Model의 모델 필드를 기반으로 폼 필드를 만듭니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Photo(models.Model):
    image_file = models.ImageField(upload_to=&#39;%Y/%m/%d&#39;)
    filtered_image_file = models.ImageField(upload_to=&#39;static_files/uploaded/%Y/%m/%d&#39;)
    description = models.TextField(max_length=500, blank=True)
    created_at = models.DateTimeField(auto_now_add=True, auto_now=False)
</code></pre></div>
<p><code>Photo</code> 모델이 이와 같은 모델 필드로 구성되어 있으니 <code>PhotoEditForm</code>을 일반 <code>Form</code> 클래스를 상속받아 만든다면 다음과 같이 만드는 셈입니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class PhotoEditForm(forms.Form):
    image_file = forms.ImageField()
    filtered_image_file = forms.ImageField()
    description = forms.CharField(
        max_length=500,
        required=False,
        widget=forms.Textarea
    )
    created_at = forms.DateTimeField(required=False)
</code></pre></div>
<p>Model과 비슷하게 생겼습니다. 웹페이지에 사용할 HTML도 거의 비슷합니다.</p>

<p><img src="/assets/uploads/2015/05/07-new_photo_modelform.png" alt="ModelForm으로 만든 PhotoEditForm"></p>

<p>앞 화면은 <code>ModelForm</code>으로 만든 <code>PhotoEditForm</code> 폼이 만든 HTML 화면이고, 다음 화면은 <code>Form</code>으로 만든 <code>PhotoEditForm</code> 폼이 만든 HTML 화면입니다.</p>

<p><img src="/assets/uploads/2015/05/07-new_photo_form.png" alt="Form으로 만든 PhotoEditForm"></p>

<p>거의 동일하지요?</p>

<p>Model은 데이터베이스와 연관되어 있어서 모델 필드형(type)이 데이터베이스의 컬럼(column)형(type)에 맞추어져 있고, Form은 웹 입력 양식인 form 관련 태그의 종류에 맞추어져 소소한 차이가 있지만, 결국 웹에서 넘겨받은 데이터를 데이터베이스에 넣는 것이라 서로 비슷한 인터페이스를 갖습니다. <code>ModelForm</code>을 쓰면 모델 필드와 폼 필드 간 차이 마저도 별로 의식하지 않습니다. 그래서 Model을 잘 만들고 <code>ModelForm</code>을 이용하여 Model form을 만들면 우리는 데이터 유효성을 검사하고 이를 데이터베이스에 넣거나 찾아 쓰는 데이터 관리와 처리를 날로 먹게 됩니다.</p>

<h4>사진 게시물 작성 화면 만들기</h4>

<p>사진 게시물을 게시하려면 사진 파일을 선택하고, 사진을 설명하는 본문 등 사진 게시물에 필요한 사항을 입력해야 합니다. 본 강좌 중 <a href="http://blog.hannal.com/2014/8/start_with_django_webframework_01/">Pystagram 기획</a>편에서 사진 게시물을 작성하고 게시하는 URL을 <code>/photo/upload/</code>로 하기로 했으니 <code>urls.py</code>에 이 주소 패턴을 등록합니다. 시작 패키지(<code>settings.py</code> 파일이 있는 디렉터리)에 있는 <code>urls.py</code> 파일을 열고 다음 URL 패턴을 추가합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">url(r&#39;^photo/upload/$&#39;, &#39;photo.views.new_photo&#39;, name=&#39;new_photo&#39;),
</code></pre></div>
<p>이 내용을 반영하면 다음과 같은 코드가 됩니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">urlpatterns = patterns(
    &#39;&#39;,
    url(
        r&#39;^photo/(?P&lt;photo_id&gt;\d+)/$&#39;,
        &#39;photo.views.single_photo&#39;,
        name=&#39;view_single_photo&#39;
    ),
    url(r&#39;^photo/upload/$&#39;, &#39;photo.views.new_photo&#39;, name=&#39;new_photo&#39;),
    url(r&#39;^admin/&#39;, include(admin.site.urls)),
)
</code></pre></div>
<p><code>/photo/upload/</code> URL에 <code>photo.views.new_photo</code>을 연결(mapping)한 것입니다. <code>photo</code> 앱의 <code>views</code> 모듈에 있는 <code>new_photo</code>라는 객체를 가리키는 이름영역(namespace)입니다. 간단히 말해서, <code>photo</code> 앱 디렉터리에 있는 <code>views.py</code> 파일에 있는 <code>new_photo</code>라는 실행 가능한(callable) 객체를 연결한 것이며, 이 <code>new_photo</code>는 뷰 함수(View function)입니다.</p>

<p>이번엔 <code>views.py</code> 파일에 <code>new_photo</code> 뷰 함수를 만듭니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">from photo.forms import PhotoEditForm

def new_photo(request):
    edit_form = PhotoEditForm()

    return render(
        request,
        &#39;new_photo.html&#39;,
        {
            &#39;form&#39;: edit_form,
        }
    )
</code></pre></div>
<p><code>new_photo.html</code> 템플릿 파일에 템플릿 맥락 요소(Context)로 앞서 만든 <code>PhotoEditForm</code> 클래스 객체를 전달하는데, 폼 클래스 자체가 아니라 폼 클래스를 인스턴스 객체로 생성하여 <code>edit_form</code>에 할당하고, 이 <code>edit_form</code>을 전달합니다.</p>

<p><code>render()</code> 함수는 <a href="http://blog.hannal.com/2014/11/start_with_django_webframework_05/">5. url에 view 함수 연결해서 사진 출력하기</a> 편에서 역할을 설명했고, 이번 편에서 처음 사용합니다. 이 함수는 대개 세 가지 인자를 필요로 합니다.</p>

<ul>
<li><code>request</code></li>
<li>템플릿 파일 이름</li>
<li>사전형 객체로 전달되는 템플릿 맥락 요소(context)</li>
</ul>

<p><code>request</code> 객체는 뷰 함수에 첫 번째 인자로 전달되는 객체입니다. <a href="https://docs.djangoproject.com/en/1.8/ref/request-response/#httprequest-objects">HTTP Request</a>를 뜻합니다. 뷰 함수는 언제나 첫 번째 인자로 <code>request</code> 객체를 전달 받는데, 이 객체를 <code>render()</code> 함수의 첫 번째 인자로 전달합니다. 템플릿에서 템플릿 맥락 요소로 <code>request</code> 객체를 지정하는(mapping) 데 사용됩니다. 두 번째 인자는 템플릿 파일 경로를 문자열로 지정하며, 이 인자 역시 필수 인자입니다. 마지막으로, 세 번째 인자는 템플릿 파일 안에서 사용할 템플릿 맥락 요소를 사전형(<code>dict</code>) 객체로 전달합니다. <code>{&#39;form&#39;: edit_form}</code>에서 <code>Key</code>인 <code>&#39;form&#39;</code>은 템플릿 파일 안에서 <code>form</code>이라는 이름으로 사용하는 템플릿 변수가 되고, <code>Value</code>인 <code>edit_form</code>(<code>PhotoEditForm()</code>의 인스턴스 객체)가 이 템플릿 변수에 연결된(mapped) 객체인 셈이지요.</p>

<p>이번엔 템플릿 파일인 <code>new_photo.html</code>을 만듭니다. <code>photo</code> 디렉터리에 <code>templates</code> 디렉터리를 만들고, 그 안에 <code>new_photo.html</code> 파일을 만들어 다음 내용을 담습니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{% extends &#39;layout.html&#39; %}

{% block content %}
&lt;form
    method=&quot;POST&quot;

    action=&quot;{% url &#39;new_photo&#39; %}&quot;

    enctype=&quot;multipart/form-data&quot;
&gt;
    {% csrf_token %}
    {{form.as_p}}

    &lt;p&gt;
        &lt;input type=&quot;submit&quot; /&gt;
    &lt;/p&gt;
&lt;/form&gt;

{% endblock %}
</code></pre></div>
<p>Django Template은 추후 연재에서 자세히 다루겠습니다. 이 <code>new_photo.html</code>는 뷰 함수에서 지정한 템플릿 파일이니 이후엔 <strong>뷰 템플릿 파일</strong>이라 부르겠습니다. 템플릿 내용 중 눈여겨 볼 점은 <code>{{form.as_p}}</code> 코드입니다. <code>form</code>은 <code>new_photo</code> 뷰 함수가 <code>edit_form</code> 폼 객체를 <code>form</code>이라는 템플릿 변수로 지정해 전달한 것입니다. 이 객체의 인스턴스 메서드인 <code>as_p()</code>를 호출하면 각 폼 필드를 HTML 태그인 <code>&lt;p&gt;&lt;/p&gt;</code>(paragraph, 문단 태그)로 감싸서 출력합니다. 실제로 출력되는 HTML 코드는 다음과 같습니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">&lt;p&gt;&lt;label for=&quot;id_image_file&quot;&gt;Image file:&lt;/label&gt; &lt;input id=&quot;id_image_file&quot; name=&quot;image_file&quot; type=&quot;file&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;label for=&quot;id_filtered_image_file&quot;&gt;Filtered image file:&lt;/label&gt; &lt;input id=&quot;id_filtered_image_file&quot; name=&quot;filtered_image_file&quot; type=&quot;file&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;label for=&quot;id_description&quot;&gt;Description:&lt;/label&gt; &lt;textarea cols=&quot;40&quot; id=&quot;id_description&quot; maxlength=&quot;500&quot; name=&quot;description&quot; rows=&quot;10&quot;&gt;
&lt;/textarea&gt;&lt;/p&gt;
</code></pre></div>
<p><code>Photo</code> 모델에 있는 모델 필드 네 개 중 세 개가 HTML form 입력항목 태그로 표현 되었습니다. <code>created_at</code>은 없는데, 날짜나 시간 관련 모델 필드(<code>DateTimeField</code>, <code>DateField</code>, <code>TimeField</code>)에 <code>auto_now_add</code>나 <code>auto_now</code> 필드 옵션 중 하나라도 <code>True</code>로 지정되면 Model form으로 폼 필드를 만들 때 기본 입력 항목으로 지정되지 않고, 그래서 HTML 태그로도 만들어 내지 않습니다.</p>

<p><code>{% csrf_token %}</code>는 <a href="https://goo.gl/Bw90sV">CSRF(Cross Site Request Forgery)</a> 토큰을 만드는 템플릿 태그입니다. Django로 만든 웹 페이지에 접속하면 각 세션을 기반으로 CSRF 토큰을 만들며, 이 토큰이 조작되거나 존재하지 않으면 Form 데이터를 Django로 동작하는 웹 애플리케이션 서버에 보내지 못합니다<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>. CSRF 토큰 검사를 하지 않도록 하면 되지만, 보안 상 좋지 않으니 HTML 폼 영역에 CSRF 토큰을 생성하도록 <code>{% csrf_token %}</code>을 습관처럼 넣길 권합니다. 빠뜨리면 CSRF 검증을 실패하였다는 오류가 발생합니다.</p>

<p><img src="/assets/uploads/2015/05/07-csrf_failed.png" alt=""></p>

<p>뷰 템플릿 파일인 <code>new_photo.html</code>는 레이아웃 구조를 잡는 역할을 하는 <code>layout.html</code> 템플릿 파일로 확장하므로(<code>{% extends &#39;layout.html&#39; %}</code>) 이 <code>layout.html</code> 파일도 만들어야 합니다.</p>

<p>이번엔 <code>manage.py</code> 파일이 있는 디렉터리에 <code>templates</code> 디렉터리를 새로 만들고, 그 안에 <code>layout.html</code> 파일을 만들어 다음 내용을 담습니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{% load staticfiles %}

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;ko&quot;&gt;

&lt;head&gt;
    &lt;title&gt;{% block page_title %}Pystagram{% endblock %}&lt;/title&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;{% static &#39;js/jquery-2.1.3.min.js&#39; %}&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;
{% block content %}{% endblock %}
&lt;/body&gt;

&lt;/html&gt;
</code></pre></div>
<p>지난 6회 연재 글에서 다룬 정적(static) 파일 내용이 얼핏 보이네요. 이것도 Django Template을 다루는 연재 글에서 자세히 다루겠습니다.</p>

<p><code>layout.html</code>은 여러 뷰 템플릿에서 공통으로 사용하므로 앱 디렉터리가 아닌 별도 템플릿 디렉터리를 만들어 배치했습니다. 이 템플릿 디렉터리를 <code>settings.py</code>에 설정합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">TEMPLATE_DIRS = (
    os.path.join(BASE_DIR, &#39;templates&#39;),
)
</code></pre></div>
<p>참고로 이 설정은 Django 1.8에서는 유효하지 않으며, 추후 템플릿에 대해 자세히 다룰 때 이 설정을 수정하도록 하겠습니다.</p>

<p>이제 Django의 개발용 내장 웹 서버를 구동하고(<code>python manage.py runserver</code>) <code>/photo/upload/</code> URL로 접속하면 사진 게시물을 작성하는 편집 화면이 나옵니다. 그런데 <code>filtered_image_file</code>은 이미지 필터를 적용하여 가공된 이미지 파일을 담는 모델 필드입니다. 다시 말하면, 사진 게시물을 편집하는 단계에서 이용자가 접근해서는 안 되는 필드입니다. 그래서 화면에 나타나지 않게 감추겠습니다. 방법은 간단합니다. <code>PhotoEditForm</code> 모델 폼의 메타 클래스에서 폼 필드로 사용할 모델 필드를 지정하면 됩니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class PhotoEditForm(forms.ModelForm):
    class Meta:
        model = Photo
        fields = (&#39;image_file&#39;, &#39;description&#39;, )
</code></pre></div>
<p><code>fields</code>는 폼에서 사용할 모델 필드를 지정하는 데 사용하며, 모델 필드 이름을 문자열로 리스트(<code>list</code>)나 튜플(<code>tuple</code>) 객체에 나열해 담으면 됩니다. 그런데 폼 필드로 사용하지 않을 모델 필드는 <code>filtered_image_file</code> 하나이고, 사용할 모델 필드는 221개쯤 있다고 가정하겠습니다. 고작 하나를 사용하지 않으려고 221개 모델 필드 이름을 나열하면 무척 고통스럽습니다. 이런 경우는 사용하지 않을 모델 필드만 지정해야 편한데, <code>exclude</code>에 지정하면 됩니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class PhotoEditForm(forms.ModelForm):
    class Meta:
        model = Photo
        exclude = (&#39;filtered_image_file&#39;, )
</code></pre></div>
<p>이 코드에서 유의할 점은 <code>exclude</code> 역시 리스트나 튜플 객체를 할당해야 하므로 <code>&#39;filtered_image_file&#39;</code> 뒤에 쉼표 하나 더 찍어줘야 합니다<sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup>.</p>

<p><img src="/assets/uploads/2015/05/07-new_photo_modelform_without_some_field.png" alt=""></p>

<p>이제 필터가 적용된 이미지 파일 모델 필드는 폼에서 다루지 않습니다.</p>

<h4>사진 게시물 게시하기</h4>

<p>우리는 사진 게시물 내용을 작성하는 URL과 사진 게시물을 제출하여 게시하는 URL을 같이 쓰겠습니다. 즉, <code>/photo/upload/</code>에 HTTP Get 방식으로 접근하면 사진 게시물을 작성하는 화면이 나오고, POST 방식으로 접근하면 게시물을 제출합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">def new_photo(request):
    if request.method == &quot;GET&quot;:
        edit_form = PhotoEditForm()
    elif request.method == &quot;POST&quot;:
        edit_form = PhotoEditForm(request.POST, request.FILES)

        if edit_form.is_valid():
            new_photo = edit_form.save()

            return redirect(new_photo.get_absolute_url())

    return render(
        request,
        &#39;new_photo.html&#39;,
        {
            &#39;form&#39;: edit_form,
        }
    )
</code></pre></div>
<p><code>request.method</code>가 <code>GET</code>인 경우는 기존 코드를 그대로 사용하면 됩니다. <code>POST</code> 방식, 즉, 게시물 내용과 파일을 제출 받는 부분을 추가했습니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">PhotoEditForm(request.POST, request.FILES)
</code></pre></div>
<p><code>PhotoEditForm</code> 폼에 첫 번째 인자로 <code>request.POST</code>를, 두 번째 인자로 <code>request.FILES</code>를 전달합니다. 첫 번째 인자는 폼에서 다룰 데이터를 뜻하며, 사전형(<code>dict</code>) 객체나 사전형 객체처럼 동작하는(비슷한 인터페이스를 제공하는) 객체<sup id="fnref4"><a href="#fn4" rel="footnote">4</a></sup>여야 합니다. 파일을 제외한 HTML Form에서 <code>POST</code> 방식으로 전송해온 모든 데이터가 <code>request.POST</code>에 있습니다. 파일은 <code>request.FILES</code>에 있습니다. 그래서, 이 둘을 분리하여 첫 번째 인자, 두 번째 인자로 전달한 것입니다.</p>

<p>여기까지는 폼에서 처리할 데이터를 인자로 전달하여 설정한 것일 뿐이므로, <code>edit_form = PhotoEditForm()</code>와 다를 바 없습니다. 그렇다고 해서 다음과 같이 코드를 작성해서는 안 됩니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    edit_form = PhotoEditForm()
    if request.method == &quot;POST&quot;:
        edit_form.data = request.POST
        edit_form.files = request.FILES

        if edit_form.is_valid():
            new_photo = edit_form.save()
</code></pre></div>
<p>Django Form은 첫 번째 인자로 넘어온 데이터는 <code>data</code> 멤버에, 파일은 <code>files</code> 멤버에 할당하는 걸 이용한 것인데, Form 클래스로 인스턴스 객체를 생성해 할당하는 과정에서(<code>__init__()</code>) 인자로 전달된 데이터나 파일이 있으면 <code>is_bound</code>라는 멤버에 <code>True</code>가 할당되고, 이 <code>is_bound</code>가 <code>True</code>여야만 <code>is_valid()</code>를 비롯한 폼 검사를 수행하기 때문입니다. 물론,</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    if request.method == &quot;POST&quot;:
        edit_form.is_bound = True
        edit_form.data = request.POST
        edit_form.files = request.FILES
</code></pre></div>
<p>이렇게 <code>is_bound</code>를 직접 <code>True</code>로 할당하면 되지만, <code>edit_form = PhotoEditForm(request.POST, request.FILES)</code>라고 코드를 짜면 그만인 것을 굳이 저렇게 짤 필요는 없습니다.</p>

<p>폼에 검사할 데이터를 전달하여 초기화하여 인스턴스 객체(<code>edit_form</code>)에는 전달된 데이터를 검사하는 몇 가지 인스턴스 메서드를 제공합니다. <code>full_clean()</code>나 <code>clean()</code> 메서드가 폼 데이터를 검사하는 데 사용하는 메서드인데, 실제로는 <code>is_valid()</code> 메서드를 사용하면 됩니다. <code>is_valid()</code> 메서드는 폼에 전달된 데이터를 폼 필드를 기준으로 검사하여 모든 데이터가 유효하면 <code>True</code>를, 하나라도 유효하지 않은 항목이 있으면 <code>False</code>를 반환합니다. 동작은 다음과 같습니다.</p>

<ol>
<li><a href="https://github.com/django/django/blob/master/django/forms/forms.py#L163">is_valid</a> : 폼 검사와 관련된 오류(error)가 있는 지 검사.

<ul>
<li><a href="https://github.com/django/django/blob/master/django/forms/forms.py#L157">errors</a> 항목 검사를 수행한 적이 없어서 오류 내용 존재 자체가 아예 존재하지 않는 경우(<code>None</code>), <code>full_clean()</code> 메서드 실행</li>
</ul></li>
<li><a href="https://github.com/django/django/blob/master/django/forms/forms.py#L362">full_clean()</a> : <a href="https://github.com/django/django/blob/master/django/forms/forms.py#L380"><code>_clean_fields()</code></a>, <a href="https://github.com/django/django/blob/master/django/forms/forms.py#L399"><code>_clean_form()</code></a>, <a href="https://github.com/django/django/blob/master/django/forms/models.py#L410"><code>_post_clean()</code></a> 메서드를 차례대로 수행하여 폼 데이터 유효성을 검사.</li>
<li>최종 : <code>is_valid()</code>는 오류(errors)가 없으면 <code>True</code>를 반환하고, 있으면 데이터가 유효하지 않아 <code>False</code>를 반환하며, 어떤 항목에 문제가 유효하지 않은 지 여부는 폼 인스턴스 객체의 <code>errors</code> 멤버(프로퍼티)에 사전형 객체처럼 생긴 <code>ErrorDict</code>의 인스턴스 객체로 할당.</li>
</ol>

<p>데이터가 모두 유효하면 <code>PhotoEditForm</code> 폼의 인스턴스 객체인 <code>edit_form</code>의 <code>save()</code> 메서드를 실행하고, 이 메서드는 연결된 모델을 이용하여 데이터를 저장합니다. <code>save()</code> 메서드는 <code>ModelForm</code> 클래스에 있는 메서드인데, 모델 폼에 연결한 모델을 이용하여 데이터를 저장하고 저장한 모델의 인스턴스 객체를 반환합니다. <code>PhotoEditForm</code>에 <code>Photo</code> 모델을 연결하였으므로 <code>Photo</code> 모델로 생성한 인스턴스 객체를 반환하는 셈이지요.</p>

<p><code>return redirect(new_photo.get_absolute_url())</code> 에서 <code>redirect()</code> 함수는 HTTP Response를 반환하는 Django의 <code>HttpResponseRedirect</code> 클래스를 이용하여 클라이언트를 지정한 URL로 이동(redirect)시킵니다. <code>render()</code> 함수처럼 몇 가지 절차를 간편하게 줄여준 함수이며, <code>django.shortcuts</code> 모듈에 있습니다. 사용하려면 <code>import</code>해야 겠지요?</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">from django.shortcuts import (
    render,
    redirect,
)
</code></pre></div>
<p><code>new_photo.get_absolute_url()</code>에서 눈여겨 볼 부분은 <code>get_absolute_url()</code> 메서드입니다. <code>new_photo</code>는 <code>Photo</code> 모델로 생성한 인스턴스 객체인데, 우리는 <code>Photo</code> 모델에 <code>get_absolute_url()</code> 인스턴스 메서드를 만든 적이 없습니다. 먼저 만들고 설명하겠습니다. <code>photo</code> 앱 디렉터리 안에 있는 <code>models.py</code>에서 <code>Photo</code> 모델 클래스에 다음 코드를 추가합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">from django.core.urlresolvers import reverse_lazy


class Photo(models.Model):
    # 중략

    def get_absolute_url(self):
        return reverse_lazy(&#39;view_single_photo&#39;, kwargs={&#39;photo_id&#39;: self.id})
</code></pre></div>
<p>Django Model의 <code>get_absolute_url()</code> 메서드는 모델의 개별 데이터에 접근하는 URL을 문자열로 반환합니다. 우리는 개별 사진을 보는 URL을 <code>/photo/사진ID/</code> 패턴으로 제공하므로, 2번 사진은 <code>/photo/3/</code>, 1023번 사진은 <code>/photo/1023/</code> URL로 접근해 봅니다. 각 사진의 데이터는 <code>Photo</code> 모델에 존재하며, 사진 데이터란 모델 클래스의 인스턴스 객체이므로 모델 클래스에 인스턴스 메서드로 <code>get_absolute_url()</code>를 만드는 것입니다.</p>

<p><code>get_absolute_url</code>라는 이름을 반드시 따를 필요는 없으며 없어도 무방합니다. <code>permalink()</code>라는 이름으로 메서드를 만들어도 무방합니다. 다만, <code>get_absolute_url</code>는 Django가 개별 모델 데이터의 URL을 제공하는 메서드라고 전제해 놓은 이름이어서 Django가 알아서 처리하는 감춰진 동작<sup id="fnref5"><a href="#fn5" rel="footnote">5</a></sup>에 사용됩니다. 이런 관례(convention)를 따르면 일일이 지정하고 설정하지 않아도 되어 코드가 간결해집니다.</p>

<p><code>reverse_lazy()</code>는 나중에 좀 더 자세히 다루기로 하고, 이번 편에서는 <code>urls.py</code>에 <code>&#39;view_single_photo&#39;</code> 이름으로 등록한 URL 패턴에 키워드 인자인 <code>photo_id</code>의 값으로 <code>self.id</code>를 할당하여 URL 문자열을 가져오는 데 사용했다고 이해하고 넘어가겠습니다.</p>

<p>사진 게시물을 게시하는 기능을 구현했습니다. 실제로 올려보세요. 잘 게시됩니다.</p>

<p><img src="/assets/uploads/2015/05/07-uploaded_photo.png" alt=""></p>

<h4>유효하지 않은 폼 항목 오류 출력하기</h4>

<p>혹시 사진으로 이미지 파일을 첨부하지 않거나 이미지 파일이 아닌 파일을 첨부하여 게시물을 첨부해 보셨나요? 강좌 소스 코드대로 잘 따라 오셨다면, 오류 내용이 안내됩니다.</p>

<p><img src="/assets/uploads/2015/05/07-form_required_field.png" alt=""></p>

<p><img src="/assets/uploads/2015/05/07-form_not_valid_image.png" alt=""></p>

<p>우리는 템플릿 파일 어디에도 폼 오류 안내말을 출력하지 않았는데, 이게 어떻게 된 일일까요? 우리가 템플릿 파일에 폼 관련 내용을 담은 건 고작 한 줄 뿐입니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    {{form.as_p}}
</code></pre></div>
<p><code>as_p</code>로 폼 내용을 HTML로 출력하려 하면, 폼 항목에 오류가 있는 지, 즉, 폼 인스턴스 객체의 <code>errors</code> 속성에 내용이 있는 지 확인하고, 있다면 오류 내용을 출력합니다. <code>{{form.as_p}}</code>를 풀어쓰면 다음과 같습니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    {% for field in form %}
    &lt;p&gt;
        {% if field.errors %}
        {{ field.errors }}
        {% endif %}

        {{field}}
    &lt;/p&gt;
    {% endfor %}
</code></pre></div>
<p><code>form</code> 템플릿 변수(<code>views.py</code>에서는 <code>edit_form</code> 객체)는 <code>for</code>문으로 순환 가능합니다. 순환하면 폼에 등록된 폼 필드 순서대로 하나씩 폼 필드 객체를 꺼냅니다. 이 필드 객체를 출력하려 하면 이 필드가 생성하는 HTML 내용을 반환하는데, 이 필드 객체에 오류가 있는 경우, 오류 내용이 필드 객체의 <code>errors</code>에 할당됩니다. 한 폼 필드에 오류 내용은 한 개 이상인 경우도 생기므로 순서열 객체(<code>list</code>)에 오류가 하나씩 할당됩니다. <code>{{ field.errors }}</code> 마저도 더 풀어쓰면 다음과 같습니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">        {% if field.errors %}
        &lt;ul&gt;
            {% for error in field.errors %}
            &lt;li&gt;{{error}}&lt;/li&gt;
            {% endfor %}
        &lt;/ul&gt;
        {% endif %}
</code></pre></div>
<p>폼 필드를 직접 명시하여 오류를 확인하는 방법도 있습니다. 예를 들어, 이미지 파일 필드인 <code>image_file</code>에 오류가 있는 지 확인하는 방법은 다음과 같습니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{% if form.errors.image_file %}
    {{form.errors.image_file}}
{% endif %}

또는

{% if form.image_file.errors %}
    {{form.image_file.errors}}
{% endif %}
</code></pre></div>
<p>대개는 Django Form이 자동으로 만들어주는 폼 항목 구성을 그대로 사용하진 않습니다. 각 폼 항목에 CSS나 HTML 속성을 다르게 부여하는데, Django 애플리케이션 개발자가 고치지 않고 Front-end 개발자가 수정하는 경우도 있습니다. 그래서 폼 필드를 구성하는 요소(레이블, 오류, 폼 필드 자체)를 분리해서 위와 같이 다루는 경우가 흔하고, 오히려 <code>{{form.as_p}}</code>와 같이 Django에서 만들어내는 HTML 그대로를 사용하는 경우가 드뭅니다.</p>

<hr>

<p>강좌 7편을 마칩니다. 이번 편에서 다룬 Django Form이 동작하는 큰 흐름을 이해하면 앞으로 다룰 Form 세부 요소를 이해하기 쉽습니다.</p>

<ul>
<li><a href="https://github.com/hannal/start_with_django_webframework/tree/07-fullsource/pystagram">7편까지 진행한 전체 소스 코드</a></li>
</ul>

<hr>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p><a href="https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/">Encoding Web Shells in PNG IDAT chunks</a> 글이나 <a href="https://blog.sucuri.net/2013/07/malware-hidden-inside-jpg-exif-headers.html">Malware Hidden Inside JPG EXIF Headers</a> 글 참조.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p><a href="https://dobest.io/how-csrf-token-works/">Django와 Rails에서 CSRF Token의 동작 방식</a>이라는 글을 참조하세요.&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p>쉼표를 빼서 <code>(&#39;filtered_image_file&#39;)</code>로 표기하면 그냥 문자열 객체가 됩니다. 리스트 객체를 만드는 데 대괄호를(<code>[</code>와 <code>]</code>) 사용하고 튜플 객체를 만드는 데 소괄호(<code>(</code>와 <code>)</code>)를 활용해서 헷갈리기 일쑤인데, 튜플을 만드는 데에 필요한 건 괄호가 아니라 쉼표(<code>,</code>)입니다. 왜냐하면 쉼표로 항목을 구분하여 나열하며, 괄호는 명시적으로 생략 가능하기 때문입니다. 단, 예외로 아무 항목이 없는 빈 튜플을 만드는 경우엔 그냥 소괄호로 짝지으면 됩니다. 자세한 내용은 <a href="https://docs.python.org/3/library/stdtypes.html#tuples">공식 문서의 Tuples</a>를 참조하세요.&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

<li id="fn4">
<p>사전형 객체처럼 생긴 이런 객체를 인스턴스로 만드는 데 사용하는 클래스(<code>type</code>)도 <code>dict</code>를 상속받아서 만들어서 <code>dict</code>형이 제공하는 인터페이스를 포함합니다.&nbsp;<a href="#fnref4" rev="footnote">&#8617;</a></p>
</li>

<li id="fn5">
<p>“magic”이라는 표현을 씁니다. 뭔가 알아서 수행되는데, 이용자(개발자)가 굳이 알 필요가 없는 내부에 감춰진 동작을 뜻하지요.&nbsp;<a href="#fnref5" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

  </div>
  <hr class="post-parting-line" />
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page5">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page3">Newer</a>
    
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-33535239-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-KS9HDB"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KS9HDB');</script>
<!-- End Google Tag Manager -->
 <!--[if lt IE 9]>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <![endif]-->
    <!--[if gte IE 9]><!-->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <!--<![endif]-->
    </body>
</html>
