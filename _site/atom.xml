<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text" xml:lang="en">Kay on the rails</title>
  <link type="application/atom+xml" href="atom_feed_url" rel="self"/>
  <link type="text/html" href="home_url_canonical" rel="alternate"/>
  <updated>2023-08-13T22:00:58+09:00</updated>
  <id>unique_feed_identifier</id>
  <author>
    <name>author_name</name>
  </author>
  <rights>copyright_details</rights>

  
  <entry>
    <title>맥을 Docker remote host로 사용하기</title>
    <link href="/2023/08/use-mac-as-docker-remote-host/"/>
    <updated>2023-08-13T21:00:00+09:00</updated>
    <id>/2023/08/docker-remote-host-on-mac-os</id>
    <content type="html">&lt;h2 id=&quot;배경&quot;&gt;배경&lt;/h2&gt;

&lt;p&gt;작업 PC로 인텔 아이맥 27인치를 사용한다. 디스플레이가 괜찮은데다 램을 128기가로 넉넉하게 구성해서 유용하다. 그런데 CPU 발열이 심한 편이라서 CPU 과부하가 심할 땐 과열로 시스템이 뻗곤 한다. 그래서 작업 PC로 사용할 맥 스튜디오를 샀다. 가격이 부담스러워서 램 용량이 적은 32기가 메모리 모델을 샀는데, 램을 주로 점유하는 것들을 아이맥에서 띄워 서버용으로 사용할 계획이기 때문이다.&lt;/p&gt;

&lt;p&gt;램을 많이 사용하는 것 중 하나는 Docker이다. 그래서 아이맥을 Docker remote host용으로, 간단히 말해서 Docker 서버용으로 사용하도록 설정하기로 했다. 그런데 Docker를 서버로 구동할 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dockerd&lt;/code&gt;는 Linux에서 동작하며, Mac OS는 지원하지 않기 때문에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;virtualbox&lt;/code&gt;를 이용해 Linux를 가상화하여 Guest OS로 구동하여 Docker를 사용한다. 따라서 아이맥에 virtualbox로 Linux를 설치하고, 그 가상화로 구동하는 Linux에 구성한 dockerd를 사용해야 한다. Host OS인 Mac OS와 Guest OS인 Linux 간 네트워크도 연결해주고.&lt;/p&gt;

&lt;p&gt;귀찮기도 하고 웬지 무겁고 비효율적일 것 같은데, 이 글에서 사용할 Docker desktop 대체재인 &lt;a href=&quot;https://orbstack.dev&quot;&gt;OrbStack&lt;/a&gt;을 사용하여 쉽게 설정하고 가볍게 동작하는 환경을 구성할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;아이맥 : Ventura 13.4&lt;/li&gt;
  &lt;li&gt;Docker client : OrbStack&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;docker-설치&quot;&gt;Docker 설치&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Docker remote host인 아이맥에 &lt;a href=&quot;https://docs.orbstack.dev/install&quot;&gt;OrbStack 설치&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;원격으로 접근할 client인 맥스튜디오에도 설치.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;docker-engine을-daemon으로-구동할-ubuntu-서버-구성&quot;&gt;Docker engine을 daemon으로 구동할 Ubuntu 서버 구성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;아이맥에 OrbStack으로 Linux machine을 만든다.
    &lt;ul&gt;
      &lt;li&gt;참고 : &lt;a href=&quot;https://docs.orbstack.dev/machines/&quot;&gt;Using Linux machines&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;orb create &lt;span class=&quot;nt&quot;&gt;--arch&lt;/span&gt; amd64 ubuntu my-ubuntu
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아이맥이 인텔맥이라서 아키텍쳐를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;amd64&lt;/code&gt;로 지정했다.&lt;/p&gt;

&lt;p&gt;Linux machine을 만들고 나면 ssh로 접근 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;orb &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; my-ubuntu &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; default
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기본으로 생성되는 계정 이름이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt;이다. 기본으로 존재하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt;로 접근해도 된다.&lt;/p&gt;

&lt;p&gt;Linux machine을 생성하면 OrbStack이 이 ubuntu에 ssh로 접근할 수 있게 ssh host configuration을 자동으로 만들어줘서 더 적게 타이핑하여 접근할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh orb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;orb&lt;/code&gt;가 OrbStack이 만든 ssh host configuration이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# ~/.orbstack/ssh/config
# 이 파일은 ~/.ssh/config 에서 Include 하도록 OrbStack이 설정한다.

Host orb
  Hostname 127.0.0.1
  Port 32222
  # SSH user syntax:
  #   &amp;lt;container&amp;gt;@orb to connect to &amp;lt;container&amp;gt; as the default user (matching your macOS user)
  #   &amp;lt;user&amp;gt;@&amp;lt;container&amp;gt;@orb to connect to &amp;lt;container&amp;gt; as &amp;lt;user&amp;gt;
  # Examples:
  #   ubuntu@orb: container &quot;ubuntu&quot;, user matching your macOS user
  #   root@fedora@orb: container &quot;fedora&quot;, user &quot;root&quot;
  User default

  # replace or symlink ~/.orbstack/ssh/id_ed25519 file to change the key
  IdentityFile ~/.orbstack/ssh/id_ed25519

  # only use this key
  IdentitiesOnly yes
  ProxyCommand &apos;/Applications/OrbStack.app/Contents/Frameworks/OrbStack Helper (VM).app/Contents/MacOS/OrbStack Helper (VM)&apos; ssh-proxy-fdpass /Users/hannal
  ProxyUseFdpass yes
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;docker-engine-설치&quot;&gt;Docker engine 설치&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Linux machine에 접근하여 docker engine을 설치한다.&lt;/li&gt;
  &lt;li&gt;참고 : &lt;a href=&quot;https://docs.docker.com/engine/install/ubuntu/&quot;&gt;Install Docker Engine on Ubuntu&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;충돌날만한-불필요한-패키지-제거&quot;&gt;충돌날만한 불필요한 패키지 제거&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;pkg &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;docker.io docker-doc docker-compose podman-docker containerd runc&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt-get remove &lt;span class=&quot;nv&quot;&gt;$pkg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;docker-repository-설정&quot;&gt;Docker repository 설정&lt;/h3&gt;

&lt;p&gt;HTTPS로 repository에서 패키지를 가져와 설치해야 하므로 관련 패키지를 설치한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt update
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;ca-certificates curl gnupg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Docker의 공식 GPG 키를 추가한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo install&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-m&lt;/span&gt; 0755 &lt;span class=&quot;nt&quot;&gt;-d&lt;/span&gt; /etc/apt/keyrings
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://download.docker.com/linux/ubuntu/gpg | &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;gpg &lt;span class=&quot;nt&quot;&gt;--dearmor&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; /etc/apt/keyrings/docker.gpg
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo chmod &lt;/span&gt;a+r /etc/apt/keyrings/docker.gpg
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Docker repository를 등록한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;s2&quot;&gt;&quot;deb [arch=&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;dpkg &lt;span class=&quot;nt&quot;&gt;--print-architecture&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot; signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;
  &quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt; /etc/os-release &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$VERSION_CODENAME&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot; stable&quot;&lt;/span&gt; | &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;sudo tee&lt;/span&gt; /etc/apt/sources.list.d/docker.list &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; /dev/null

&lt;span class=&quot;c&quot;&gt;# repository를 새로 등록했으니 update 해준다.&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt update
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Docker 공식 repository에서 패키지를 가져와 설치한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;docker를-system-서비스로-등록한다&quot;&gt;Docker를 system 서비스로 등록한다&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;나는 systemd를 사용하므로 systemd 설정을 했다.&lt;/li&gt;
  &lt;li&gt;참고 : &lt;a href=&quot;https://docs.docker.com/config/daemon/remote-access/&quot;&gt;Configure remote access for Docker daemon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;docker.service
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl &lt;span class=&quot;nb&quot;&gt;enable &lt;/span&gt;containerd.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;remote-access되도록-docker-설정&quot;&gt;Remote access되도록 docker 설정&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/docker/daemon.json&lt;/code&gt;에 설정하거나 systemd에서 docker 서비스 실행에서 인자로 지정하거나. 여기에선 후자 방법으로 했다. daemon 설정이 더 늘어나면 그때 분리하려 한다.&lt;/p&gt;

&lt;p&gt;후자 방법은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/systemd/system/docker.service.d/override.conf&lt;/code&gt; 파일을 편집하는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-conf highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[&lt;span class=&quot;n&quot;&gt;Service&lt;/span&gt;]
&lt;span class=&quot;n&quot;&gt;ExecStart&lt;/span&gt;=
&lt;span class=&quot;n&quot;&gt;ExecStart&lt;/span&gt;=/&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;/&lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;/&lt;span class=&quot;n&quot;&gt;dockerd&lt;/span&gt; -&lt;span class=&quot;n&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;:// -&lt;span class=&quot;n&quot;&gt;H&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tcp&lt;/span&gt;://&lt;span class=&quot;m&quot;&gt;127&lt;/span&gt;.&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;m&quot;&gt;2375&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-H&lt;/code&gt; 옵션은 Docker daemon 소켓이 연결할(사용할) 호스트를 지정한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-H fd://&lt;/code&gt;는 Unix file descriptor로 호스트 연결을 하는 것이고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-H tcp://127.0.0.1:2375&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;127.0.0.1:2375&lt;/code&gt; TCP IP로 연결하는 것이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-H fd://&lt;/code&gt;는 기본(default) 옵션이고, TCP로 원격 접근하도록 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-H tcp://...&lt;/code&gt; 옵션을 추가한 것이다.&lt;/p&gt;

&lt;p&gt;systemd service 스크립트를 수정하지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;override.conf&lt;/code&gt;를 수정하는 이유는 자동으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;override.conf&lt;/code&gt;가 포함되기 때문이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo systemctl status docker.service&lt;/code&gt; 명령을 실행해 확인해보자.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl status docker.service

● docker.service - Docker Application Container Engine
     Loaded: loaded &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;/lib/systemd/system/docker.service&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; enabled&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; preset: enabled&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    Drop-In: /etc/systemd/system/docker.service.d
             └─http-proxy.conf, override.conf
     Active: active &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;running&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; since Sun 2023-08-13 17:54:09 KST&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 1h 24min ago
TriggeredBy: ● docker.socket
       Docs: https://docs.docker.com
   Main PID: 12127 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;dockerd&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
      Tasks: 20
     Memory: 24.6M
        CPU: 973ms
     CGroup: /system.slice/docker.service
             └─12127 /usr/bin/dockerd &lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; fd:// &lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; tcp://127.0.0.1:2375
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Drop-In&lt;/code&gt;에 보면 include한 conf 파일 중 하나인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;override.conf&lt;/code&gt;가 명시되어 있다.&lt;/p&gt;

&lt;p&gt;또는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo systemctl edit docker.service&lt;/code&gt; 명령어로 systemd service script를 직접 열어봐도 확인 가능하다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl edit docker.service


&lt;span class=&quot;c&quot;&gt;### Editing /etc/systemd/system/docker.service.d/override.conf&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;### Anything between here and the comment below will become the new contents of the file&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Service]
&lt;span class=&quot;nv&quot;&gt;ExecStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;ExecStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/bin/dockerd &lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; fd:// &lt;span class=&quot;nt&quot;&gt;-H&lt;/span&gt; tcp://127.0.0.1:2375

&lt;span class=&quot;c&quot;&gt;### Lines below this comment will be discarded&lt;/span&gt;
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;systemd service script를 변경했으니 systemd가 해당 script를 다시 적재하도록 하고, docker를 재실행한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl reload docker.service

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;systemctl restart docker.service
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;mac-os에-tcp-forwarding-설정&quot;&gt;Mac OS에 TCP forwarding 설정&lt;/h2&gt;

&lt;p&gt;Docker remote host에 Linux machine을 만들어 docker daemon을 띄웠으니 외부에서 이 host에 접근해 docker host에 접근하도록 TCP 포워딩을 한다. Linux machine에 하는 것이 아니라 Linux machine를 guest OS로 구동한 Host OS인 Mac OS에 설정하는 것이다. 내 경우는 아이맥에 하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;원격-로그인-설정&quot;&gt;원격 로그인 설정&lt;/h3&gt;

&lt;p&gt;[System Settings] - [General] - [Sharing]에 들어간다(한국어로 뭐라고 나오는지는 모르겠다). &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Remote Login&lt;/code&gt;(원격 로그인?)을 활성화한다. ssh daemon을 사용할지를 설정하는 것이다. 느낌표 아이콘을 클릭하면 ssh로 접근을 허용할 계정을 지정하는 화면이 나온다. 난 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Administrators&lt;/code&gt;는 빼고 내 개인 계정을 추가했다.&lt;/p&gt;

&lt;p&gt;다른 Host에서 ssh로 접근 가능한지 테스트 해본다. 난 맥 스튜디오에서 아이맥으로 접근하는 것이다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh &lt;span class=&quot;nt&quot;&gt;-i&lt;/span&gt; ~/.ssh/id_rsa hannal@ip-address
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잘 된다. 타이핑하기 귀찮으니 ssh host 설정을 해준다.&lt;/p&gt;

&lt;div class=&quot;language-conf highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# ~/.ssh/config 파일
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Host&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imac&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;HostName&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ip&lt;/span&gt;주소
  &lt;span class=&quot;n&quot;&gt;User&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hannal&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;IdentityFile&lt;/span&gt; ~/.&lt;span class=&quot;n&quot;&gt;ssh&lt;/span&gt;/&lt;span class=&quot;n&quot;&gt;id_rsa&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;IdentitiesOnly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yes&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;PasswordAuthentication&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 호스트명인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imac&lt;/code&gt;으로 간편하게 접근된다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh imac
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 ssh host인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imac&lt;/code&gt;은 ssh 호스트가 필요한 곳엔 어디에서든지 사용할 수 있으므로 설정해두면 편리하다.&lt;/p&gt;

&lt;h3 id=&quot;ssh-daemon에-tcp-forwarding-허용-설정&quot;&gt;SSH daemon에 TCP forwarding 허용 설정&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/ssh/sshd_config&lt;/code&gt; 파일을 열어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AllowTcpForwarding&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GatewayPorts&lt;/code&gt; 설정을 추가하거나 주석을 해제한다.&lt;/p&gt;

&lt;div class=&quot;language-conf highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;AllowTcpForwarding&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yes&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;GatewayPorts&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;yes&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 설정을 하는 이유는 OrbStack은 보안을 이유로 OrbStack이 관리하는 Linux machine에 원격으로 접근하지 못하기 때문이다. OrbStack이 구동한 localhost에서만 접근 가능하다.&lt;/p&gt;

&lt;p&gt;ssh daemon 설정을 변경하면 ssh daemon에 반영되도록 재실행해야 한다. 앞서 [Sharing]에 있던 [Remote Login]을 비활성화했다가 다시 활성화하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;client-설정&quot;&gt;Client 설정&lt;/h2&gt;

&lt;p&gt;Client, 즉, 램이 32기가 뿐인 맥 스튜디오에 있는 docker가 아이맥에 있는 docker를 서버로 사용하도록 지정하는 건 대개 두 가지 방법 중 하나로 한다.&lt;/p&gt;

&lt;h3 id=&quot;docker_host-환경-변수-사용&quot;&gt;DOCKER_HOST 환경 변수 사용&lt;/h3&gt;

&lt;p&gt;환경변수인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DOCKER_HOST&lt;/code&gt;에 docker가 사용할 host를 지정하는 방법이다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;DOCKER_HOST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;imac
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker-compose up

&lt;span class=&quot;c&quot;&gt;# 또는&lt;/span&gt;

&lt;span class=&quot;nv&quot;&gt;$ DOCKER_HOST&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;imac docker-compose up
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만 환경변수는 실수하기 십상이니 다른 방법을 사용한다.&lt;/p&gt;

&lt;h3 id=&quot;docker-context-사용&quot;&gt;docker context 사용&lt;/h3&gt;

&lt;p&gt;docker에서 제공하는 context 기능을 이용하는 것이다. 먼저 Docker remote host인 imac에 대한 context를 만든다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker context create &lt;span class=&quot;nt&quot;&gt;--docker&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;ssh://imac imac-docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imac-docker&lt;/code&gt;는 context 이름이다. 잘 만들어졌는지 확인해본다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker context list

NAME            DESCRIPTION   DOCKER ENDPOINT       ...
default &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;       Current ...   unix:///var/run/docker.sock
imac-docker                   ssh://imac
orbstack        OrbStack      unix:///Users/hannal/.orbstack/ ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt;가 기본으로 존재하고, OrbStack을 설치하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;orbstack&lt;/code&gt;도 생긴다. 이들을 포함하여 방금 만든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imac-docker&lt;/code&gt; context가 목록에 나온다.&lt;/p&gt;

&lt;p&gt;docker context는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;use&lt;/code&gt; 보조 명령어로 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker context use imac-docker

Current context is now &lt;span class=&quot;s2&quot;&gt;&quot;imac-docker&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 docker는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imac-docker&lt;/code&gt; context에 지정된 Host에 연결한다. 확인해보자. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imac-docker&lt;/code&gt; context를 지정한 상태에서 docker container를 구동한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker-compose up

&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+] Running 4/0
 ✔ Container redis      Created                     0.0s
Attaching to redis
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아이맥에 있는 docker에 컨테이너가 구동된 것이라면 맥 스튜디오에 있는 docker에는 구동된 컨테이너가 없을테니 그걸 확인한다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker context use default

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker ps

CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아무 컨테이너도 없다. 아이맥에 있는 docker를 확인해본다.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ssh imac

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;docker ps

CONTAINER ID   IMAGE                ...
2b806a9e441e   redis:7              ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;잘 떠있다. 이렇게 5K 해상도 디스플레이가 달린 Docker 서버를 마련했다.&lt;/p&gt;

&lt;h2 id=&quot;뜻밖의-공지&quot;&gt;뜻밖의 공지&lt;/h2&gt;

&lt;p&gt;그나저나 오랜만에 블로그에 글 올리려고 jekyll을 실행하니 설치에서 시간 낭비했고, 동작도 느리다. hugo로 이전해보려 했는데, 깔끔하게 이전되지도 않는다.&lt;/p&gt;

&lt;p&gt;요즘엔 글을 안 쓰기도 하고, 관리하는 것도 은근히 신경 쓰이니 이 참에 개인 블로그를 닫아야겠다.&lt;/p&gt;

&lt;p&gt;2003년부터 운영해온 개인 블로그는 2023년 8월 13일자로 닫습니다. 그동안 한날의 개인 블로그에 와주신 분들께 감사 인사 드립니다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>2021년을 마치며</title>
    <link href="/2021/12/closing/"/>
    <updated>2021-12-31T13:00:00+09:00</updated>
    <id>/2021/12/closing</id>
    <content type="html">&lt;p&gt;어째 이 블로그에 회고만 올리는 것 같다. 1쪽에 2년치 회고가 나란히 나열되는 게 민망하니 2022년엔 분발해야겠다.&lt;/p&gt;

&lt;h3 id=&quot;몸-건강&quot;&gt;몸 건강&lt;/h3&gt;

&lt;p&gt;작년부터 올해 상반기까진 몸을 치료하고 재활했다. 연초에 필라테스를 시작해서 일주일에 한두 번씩 다니고 있는데, 운동 수행 능력은 거의 안 는 것으로 보인다. 직업병은 다소 나아졌다.&lt;/p&gt;

&lt;p&gt;올해엔 백신을 여섯 방 맞았다. 코비드19 세 번, 독감 한 번, A형 간염 두 번. 이 정도면 우리 동네 백신대장 정도는 되겠지? 코비드19 1차 접종은 좀 힘들었지만 그래도 2~3일 감기몸살 앓는 정도로 지나갔고, 2차 접종은 감기 기운 도는 정도로 지나갔고, 3차 접종은 내 왼쪽 어깨에도 근육이 있다는 걸 인지하는 정도로 지나갔다. 생각해보면 어느 백신이든 난 부작용을 안 겪거나 거의 안 겪는 것 같다.&lt;/p&gt;

&lt;h3 id=&quot;정신-건강&quot;&gt;정신 건강&lt;/h3&gt;

&lt;p&gt;연초부터 개인사가 겹치며  제대로 정신이 털렸다. 그 시기엔 혼란스럽긴 해도 정서나 정신 체계에 영향을 받지 않고 있다고 여겼는데, 내게 문제가 일어나고 있다는 걸 2분기에 깨달았다. 두드러진 증상은 집중력 저하와 의욕 감소, 상황 과소 평가와 나 자신에 대한 과대 평가, 그리고 수면 장애였다.&lt;/p&gt;

&lt;p&gt;한 달 정도 쉬니 기분이 다소 나아졌지만, 집중력 저하와 수면 장애는 별 차이가 없었다. “아무리 봐도 ADHD인데…”라고 ADHD인 지인이 내게 한 말도 있고 해서 정신과에서 검사를 받았다. ADHD 의심 진단을 받고 약을(콘서타) 먹기 시작했는데, ADHD 사람들이 말하는 극적인 변화는 아쉽게도 경험하지 못했다. 차이가 있긴 있다.&lt;/p&gt;

&lt;p&gt;수면 장애는 좀 더 차이나게 약 효과를 봤다. 효과를 빠르게 봐서 수면제인 줄 알았는데 우울증 약이라고 한다. 평소 우울감을 모르며 지낸다. 정확히는 기복 없이 낮고 평평한 감정과 정서를 유지하며 산다. 하지만 우울감이 도드라지지 않은 것일 뿐 뇌에선 우울증이 일어나는 호르몬 변화가 있었나 보다. ADHD약은 조금씩 증량해서인지 소문과(?) 달리 천천히 변화를 체감하고, 우울증약은 빠르게 효과를 봤다. 과거형인 이유는 식욕 부진이 심해져 약을 바꿨는데, 식욕 부진은 해소됐지만 수면 질이 안좋아졌기 때문이다.&lt;/p&gt;

&lt;h3 id=&quot;취미&quot;&gt;취미&lt;/h3&gt;

&lt;p&gt;정신과에 가기 전에 정신 건강 회복을 위해 새로운 취미 활동을 시작했다. 실용음악학원에서 보컬과 드럼을 배우는데, 드럼은 좋아하는 악기여서 선택했다. 보컬 수업은 목 안 쉬고, 편안하게 말하면서도 전달력 있는 목소리로 대화하고 싶어서 등록했다. 스피치 학원을 가는 게 맞지만, 온라인에서 스피치 관련 강의 몇 개를 들어보니 나와 안 맞아서 출석을 제대로 안 할 것 같았다.&lt;/p&gt;

&lt;p&gt;드럼 수업은 재밌는데, 안 그래도 사지가 동기화 되어 움직여서 답답한데 악보 읽느라 박자 따라가기도 벅차다. 생소한 문법이나 패러다임인 프로그래밍 언어로 작성된 코드를 읽는 느낌이다. 음표를 봐야 하는데 음표 간격으로 박자를 세는, 눈이 본질이 아닌 것에 현혹되는 함정에 자꾸 빠진다. 그런 내 모습이 답답하고 재밌다.&lt;/p&gt;

&lt;p&gt;보컬 수업은 의지력을 꽤 발휘하며 출석하고 있다. 난 내 목소리가 탁성에 톤이 낮다고 생각했는데, 탁한 음색은 아니며 탁한 소리가 나는 건 발성이 좋지 않아서 그럴 거라고, 그리고 음역대가 남성 평균보다 조금 높다는, 생전 처음 듣는 피드백을 받았다. 내가 공감하지 못하는 걸 느꼈는지 바리톤 치고는 조금 더 높다는 것이지 고음 또는 초고음역대는 아니라고 부연해주었다.&lt;/p&gt;

&lt;h3 id=&quot;집중의-질&quot;&gt;집중의 질&lt;/h3&gt;

&lt;p&gt;ADHD약을 복용하면서 집중하는 질이 좋아졌다. 여전히 극적인 변화를 체험해보진 못했다. 과열된 CPU의 클럭을 낮춰 다소 느리게라도 동작하는 것처럼 내 두뇌는 더 느려진 것 같다. 초반엔 시간이 빨리가는 건 체감해서 집중력이 좋아져 몰입하니 시간이 빨리간 것인가 싶었는데, 좀 더 관찰해보니 아니었다. 엄청난 중력이 미치는 공간에 내가 들어서서 내 시간선이 느려진 느낌에 더 가깝다. 다른 시간선은 다를 바 없는 속도인데 내 시간이 느려져서 상대적으로 시간이 빨리 가는 것 같다. 내 사유체는 여전히 불쑥 끼어드는 다른 생각이나 사건(event)에 쉽게 붙잡혀 끌려간다. 그래서 초반엔 무능감이 커졌다.&lt;/p&gt;

&lt;p&gt;그럼에도 약효가 있다고 여기는 이유가 있다. 사유체가 어딘가로 끌려가는 상황을 예로 들면, 예전엔 순순히 투항한 것처럼 그대로 동행했다. 약 복용하면서부터는 즐겁게 따라가다 뿌리치고 다시 원래 맥락으로 돌아오는 데 성공하는 사건이 포착된다. 약 용량을 늘려가자 실은 동행이 아닌 납치라는 걸 또렷하게 인식하게 됐고, 납치되었다 되돌아오는 데 성공하는 빈도가 늘고 있다.&lt;/p&gt;

&lt;p&gt;여러 생각이 비슷한 영향력(가치, 우선순위)으로 머릿 속에서 날뛰고 시시각각 생기는데, 이 부분에도 변화가 있다. 양자요동 치듯 머릿 속에서 날뛰는 생각들이 다소 줄었다. 개체(생각) 수와 날뛰는 강도가 줄었으며, 무엇보다도 각 생각이 뿜어대는 영향력 차이를 가늠하는 게 점점 더 수월해진다. 온갖 생각이 시시각각 생기고 움직이는 현상(증상?)이 없어지진 않지만, 가장 영향력을 내는 생각을 찾아내고 그 놈을 놓치지 않은 채 따라가는 게 수월해져서 덜 혼란스럽다. 아니, 이전엔 누구나 다 그렇다고 마땅하게 여겨서 그런 상태를 혼란스럽다고 느낀 적이 없었다. 사람에 따라서는 그 상태를 혼란이나 혼돈이라고 느낀다면, 나 역시 그 느낌을 이젠 좀 알게 된 것 같다.&lt;/p&gt;

&lt;p&gt;ADHD가 아닌 사람은 평소에 머릿 속에 떠있는 생각 개수가 적거나, 많더라도 순번이나 영향력 같은 것이 있어서 정렬을 하며 사는 건가?&lt;/p&gt;

&lt;h3 id=&quot;42seoul&quot;&gt;42Seoul&lt;/h3&gt;

&lt;p&gt;42Seoul에 비상근 멘토로 참여해 여러 교육생분들을 멘토링했다. 탐나는 분을 여럿 만났다. 현업에서 뛰는 비상근 멘토가 멘토링하는 과정에서 교육생들 데려가도록 만드는 것이 비상근 멘토 제도의 목적 중 하나로 있는 게 분명하다.&lt;/p&gt;

&lt;p&gt;멘토링하다보니 단골처럼 몇 가지 주제가 반복되는 걸 알게 됐다. 2022년엔 블로그에 이 주제에 관해 글쓸 예정이다. 멘토링하며 나눈 이야기를 다루는 게 아니라 멘토링 단골주제 자체를 소재로 삼는 것이다.&lt;/p&gt;

&lt;p&gt;좋은 경험을 주는 멘토링은 뭔가 가르쳐주거나 도와야겠다는 의지가 충만한 채 멘토링하는 경우 보다는 멘티가 얘기 나누고 싶은 게 많아서 그가 이야기를 이끌어가며 이야기를 주고 받을 때, 그리고 멘토링 한 번으로 끝나지 않고 멘티와 피드백을 주고 받으며 멘토와 멘티 간 맥락이 유지되고 올라간 상태에서 진행한 멘토링이 좋은 경우가 많다.  예를 들어, 한 멘티는 이력서에 대해 두 번 멘토링을 했는데, 멘토링 과정에서 변화하는 각 버전 별 차이가 잘 구분이 되었다. 그 차이가 간접적인 피드백인 셈이다. 그래서 멘토링이나 코칭에 대한 여러 고민 주제 중 자연스럽게 피드백 루프를 형성하여 멘토링하는 내 만족도를 높이는 부분도 고민하고 있다.&lt;/p&gt;

&lt;h3 id=&quot;책&quot;&gt;책&lt;/h3&gt;

&lt;p&gt;3분기에 한 달 정도 쉬면서 방향성 없이 손에 잡히는대로 책을 읽었다. 상당히 효율 떨어지게 읽었다. 이해하고 배우며 읽는 게 아니라 다 읽는 데 목표를 두었다. 읽은 책을 다시 읽기도 했는데, 읽었다는 사실과 내용을 까먹어서 처음 보는 것 마냥 읽다가 예전에 책에 남긴 메모를 발견하는 식이다. 올해에 40권 정도 읽었는데, 3분기에 32권을 읽었다. 32권 중 20권은 400쪽이 넘는데, 대체로 기술서다. 책을 느리게 읽는 편인데도 이럴지니, 어쩌면 비지도학습으로 자연어 학습을 훈련하는 기계보다도 더 언어 활동을 안 했을지도 모른다.&lt;/p&gt;

&lt;p&gt;그렇게 대충 읽었지만, 그래도 몇 권 꼽아본다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;좋았던 책 : High output management&lt;/li&gt;
  &lt;li&gt;리더십, 코칭 : 유능한 관리자, 개발 7년차 매니저 1일차, 두려움 없는 조직, 코칭 리더십(존 휘트모어)&lt;/li&gt;
  &lt;li&gt;현실 도피를 도와준 책 : 죽음의 수용소에서, 블랙홀과 시간여행, 수학이 필요한 순간, 물리의 정석&lt;/li&gt;
  &lt;li&gt;재밌게 본 책 : 엘리너 올리펀트는 완전 괜찮아&lt;/li&gt;
  &lt;li&gt;기대 안 했는데 좋았던 책 : 제텔카스텐 - 글 쓰는 인간을 위한 두 번째 뇌&lt;/li&gt;
  &lt;li&gt;먹고 사는 데 도움을 준 책 : JavaScript로 함수형 프로그래밍 학습하는 책들, 전문가를 위한 파이썬, 프로덕트 리더십, 테스트 주도 개발로 배우는 객체 지향 설계와 실천, 돈의 심리학&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아참, 3분기에 책을 읽으며 두 번 산 책 몇 권을 발견하는 성과도 있다.&lt;/p&gt;

&lt;h3 id=&quot;제텔카스텐&quot;&gt;제텔카스텐&lt;/h3&gt;

&lt;p&gt;얼마 전부터 메모하는 방법과 체계를 제텔카스텐(zettelkasten)에 맞춰가고 있다.&lt;/p&gt;

&lt;p&gt;제텔카스텐을 단순하게 소개하자면, 임시 메모를 기록하고, 그 메모를 자신의 언어로 즉 자신의 생각으로써 문헌 노트나 영구 노트로 정리한다. 문헌 노트나 영구 노트로 정리하고 나면 임시 노트는 제거한다. 문헌 노트와 영구 노트는 서로 연결하여 상향식으로 아이디어 군집(cluster)을 형성하는데, 연결하는 과정도 문헌 노트와 영구 노트를 작성하는 것처럼 자신의 생각(아이디어)이 기준이다. 제텔카스텐에 대한 메모이더라도 ADHD에 관한 내 생각이 메모와 노트를 작성한 이유라면, 그 메모엔 ADHD 관련 키워드를 달고 그 키워드와 관련된 기존 메모와 연결한다.&lt;/p&gt;

&lt;p&gt;지인 소개로 제텔카스텐을 처음 접할 땐 별 감흥이 일진 않았는데,  ADHD를 치료하는 최근에 비로소 관심이 생겨서 시도하고 있다. 한 달 정도 됐는데, 아직 성과는 없다. 이쯤되면 대개는 내게 안 맞다고 여기고 포기하는데, 내 취향에 맞을지도 모른다는 생각을 한 일이 있었다.&lt;/p&gt;

&lt;p&gt;난 임시 메모를 남발하고 있으므로 제텔카스텐을 제대로 실천하는 건 아니다. 생각보다 까다롭고 시간이 많이 들다보니 자꾸 미루고 있는데, 며칠 전부터 임시 메모 몇 개를 문헌 노트로 정리하기 시작했다. 책 구절은 기억 안 나는데다 문헌 노트로 정리한 임시 노트는 삭제하다보니 책을 읽으며 남긴 메모인데도 책에 대한 내용은 안 남고 책에 대한 내 생각이 남았다.&lt;/p&gt;

&lt;p&gt;글을 읽다보면 글을 쓴 글쓴이가 어떤 생각을 했는지, 어떤 사람인지 머릿 속에서 모델링이 이뤄진다. 아무 글이나 그렇진 않고 내 취향이나 성향에 맞으며 글쓴이의 생각이 드러나고 잘 쓴 글이어야 한다. 난 몇 달에 한 번씩 내 옛날 글 몇 개를 다시 읽는데, 내 글을 읽으면서 글쓴이, 그러니까 나에게서 독립/분리된 인격체로서 저 글을 쓴 글쓴이에 대한 모델링이 가끔 이뤄진다. 못쓴 글이지만 내가 쓴 글이니 가끔 그런 경험을 하는데, 바로 이 지점이다. 과거에 쓴 내 글로 인물을 모델링하는데, 그 인물이 나 혹은 나와 매우 비슷한 부류라고 느껴지는 인물이기에 사진이나 동영상 보다도 더 입체감 있게 과거 속 나를 보는 내 취향을 제텔카스텐 방법으로 남기고 꺼내보는 것이다.&lt;/p&gt;

&lt;p&gt;이 회고는 초고를 작성하는 데 40분, 퇴고하는 데 90분 걸렸다. 이 정도 시간을 들여서 쓴 글이 이 수준이라 마음이 아프다. 적어도 이 부분만큼은 제텔카스텐으로 개선할 수 있을 것 같다.&lt;/p&gt;

&lt;h3 id=&quot;2022년-계획&quot;&gt;2022년 계획&lt;/h3&gt;

&lt;p&gt;집필하고 있다. 2022년이면 8년차가 된다. 계약 당시 1.6 버전이던 Django는 2022년 중에 4.0 버전대로 접어든다. 음… 계약한 출판사에서는 왜 기다려주는 거지. ㅜㅜ 2022년엔 반드시 초고를 완료하겠다.&lt;/p&gt;

&lt;p&gt;몇 가지 주제로 블로그 글 혹은 적절한 매체나 방법으로 컨텐츠를 만들려 한다. 색다른 것도 있고, 아닌 것도 있다.&lt;/p&gt;

&lt;p&gt;팀을 만들고 있고, 내년엔 더 적극 집중과 관심을 투자할 계획이다.&lt;/p&gt;

&lt;p&gt;퇴고하며 거의 분량 반 정도를 쳐냈는데도 여전히 참 말 많다. 내가 말 많다는 걸, 심지어 갈수록 많아지는 걸 느낀다. 말 줄이는 노력도 계획에 넣어본다.&lt;/p&gt;

</content>
  </entry>
  
  <entry>
    <title>2020년을 마치며</title>
    <link href="/2020/12/closing/"/>
    <updated>2020-12-25T13:00:00+09:00</updated>
    <id>/2020/12/closing</id>
    <content type="html">&lt;h3 id=&quot;탈진한-상반기&quot;&gt;탈진한 상반기&lt;/h3&gt;
&lt;p&gt;상반기는 탈진하도록 몸과 마음을 썼다. 2분기에 들어서는 시점에 탈진 징조를 느꼈고, 6월 중순부터 회복과 충전하는 시간을 가졌다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;내게 익숙하고 편한 몸무게로 감량&lt;/li&gt;
  &lt;li&gt;치과 치료&lt;/li&gt;
  &lt;li&gt;요통 치료&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;한창 크로스핏 할 땐 도무지 도달하지 못했던 몸무게인 67~68kg에 건강하지 못한 방식으로 도달하자 자전거 오래 타다 땅을 딛는 것처럼 몸이 불편했다. 그래서 1분기부터 부담 가지 않는 선에서 1일 1식 하며 체중 감량을 하여 약 4~6개월 만에 4~5kg를 빼고 유지하고 있다. 정형외과에서는 좀 더 경과를 보며 치료를 하되 운동을 재개해도 된다고 하여 내년엔 필라테스를 해볼 생각이다.&lt;/p&gt;

&lt;p&gt;마음도 어딘가 고장 난 것 같기도 하고 혹시 성인 ADHD인가 싶어 종합 심리 평가를 받아봤다. 종합 심리 평가에서 성인 ADHD 징후라도 언급해주길 기대했지만 그렇진 않아 괜히 했나 생각했는데, 결과 보고서를 보니 해보길 잘했다. 내가 모르던 강점이나 가능성이 나와서 흥미롭기도 했고, 익히 알고 있던 부분을 재확인하기도 했다. 현재 나의 상태(state)를 살펴본다는(inspect) 점에서 가끔 해볼 만 한 것 같다. 참고로 보고서에 나온 내 강점을 단순무식하게 곧이곧대로 받아들인다면,
나는야 작가 꿈나무.&lt;/p&gt;

&lt;h3 id=&quot;1일-1식&quot;&gt;1일 1식&lt;/h3&gt;
&lt;p&gt;몸무게 감량하려고 2월부터 1일 1식을 시작했다. 처음엔 상당히 힘들었지만 석 달쯤 되자 몸이 적응했다. 원래 아침을 안 먹기 때문에 아침 공복이 괴롭지 않는 편이고, 아주 엄격하게 1일 1식을 지키진 않아 예상보다 빨리 적응한 것 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;일주일에 하루는 먹고 싶은 대로 먹기&lt;/li&gt;
  &lt;li&gt;여행 가면 1일 1식 안 함&lt;/li&gt;
  &lt;li&gt;초기엔 저녁에 샐러드 위주로 먹고 1일 1식은 드문드문 함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1일 1식에 몸이 맞춰지자 하루 시작이 가벼워서 좋다. 1일 2식을 할 땐 몰랐고 1일 1식을 유지할 때에도 몰랐는데, 저녁을 푸짐하게 먹거나 야식을 하면 다음 날 몸이 불쾌하게 무거운 걸 확연히 느꼈다. 조금 더 활력이 있긴 한데 크게 체감할 정도는 아니며 불쾌한 무게감은 더 크다. 하지만 하루 한 끼(점심)에 충분한 열량과 영양소를 섭취하지 못하면 다음 날 힘들긴 해서, 점심을 예전에 먹던 한 끼보다 1.2~1.5배 정도 더 먹고 잘 먹어야 한다.&lt;/p&gt;

&lt;p&gt;또 다른 변화는 커피와 술에 더 예민해진 것이다. 체력이 떨어져서 예민해졌다 생각했는데, 아무래도 1일 1식으로 체질이 변해서 그런 것 같다. 이제 커피는 하루에 한 잔으로 엄격하게 제한해야 하며, 맥주 500cc만 마셔도 술에 취해서 불편하다. 더 마시면 다음 날 머리가 아프고 땀에 흠뻑 젖은 내복을 입고 있는 것처럼 내 몸이 불편하다.&lt;/p&gt;

&lt;h3 id=&quot;계획과-다른-하반기-활동&quot;&gt;계획과 다른 하반기 활동&lt;/h3&gt;
&lt;p&gt;하반기 계획은 크게 세 가지 활동을 계획했다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;몸과 마음 회복/충전&lt;/li&gt;
  &lt;li&gt;목표 두지 않고 부담 없이 아무거나 공부&lt;/li&gt;
  &lt;li&gt;지출을 줄이고 느슨한 관계로 시간 많이 안 쓰는 일 하며 2020년 마무리하기&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;먹고 살아야 하니 3번을 꼼꼼하게 계획했다. 그래서 &lt;a href=&quot;https://innovationacademy.kr/&quot;&gt;이노베이션 아카데미&lt;/a&gt;에 비상근 개발 멘토로 지원했고, 미뤄둔 집필도 재개했다. 어딘가에 자문하거나 감수하기도 했다. 그런데 코비드19로 이노베이션 아카데미의 비상근 멘토 운영 계획에 차질이 생겨고, 이 활동에서 기대하는 수입은 사실상 사라졌다. 그래서 시간을 들여야 하는 일을 치렀다.&lt;/p&gt;

&lt;p&gt;한 프로젝트는 React를 공부하여 React와 React Native로 웹과 앱을 만드는 일이었다. React로 처음 개발하는 데다 Back-end도 포함해서 혼자 구현하다 보니 프로젝트 규모에 비해 시간을 많이 썼지만, 좋은 팀과 협업하여 스트레스 받지 않고 편하게 일했다.&lt;/p&gt;

&lt;p&gt;한 프로젝트는 Vue.js로 Front-end 개발하는 일이었다. 분명 시작은 Vue.js 개발이었는데, 어느 시점부터 Front-end이든 Back-end이든 문제를 해결하는 방향으로 일하는 방식이 바뀌었다. 그래서 Ruby on Rails 코드도 보게 됐는데, 내 성향이나 취향에 안 맞는 부분은 여전히 있지만 참 여러모로 예쁘고 우아한 언어와 도구라는 생각을 했다.&lt;/p&gt;

&lt;h3 id=&quot;모른다고-말하고-틀렸다고-인정하기&quot;&gt;모른다고 말하고 틀렸다고 인정하기&lt;/h3&gt;
&lt;p&gt;예전엔 몰랐는데, 아는 게 깊어질수록 그 분야에 모르는 게 있거나 내가 틀린 걸 인정하는 게 그리 부담스럽지 않아서 좋다. 깊이가 얕을수록 내가 모르는 걸 들키기 싫어하고 틀린 걸 어떡해서든 방어하려 했다. 좀 더 알게 될수록 아는 것만 말하는 게 불편하지 않다. 아는 것만 말해도 손해보지 않거나 불리해지지 않는 상황과 입장이 된 면도 있고.&lt;/p&gt;

&lt;p&gt;얕고 넓게 아는 걸 좋아하는 성향과 깊게 잘 알려는 태도 사이에서 아직은 흔들리는데, 깊게 파고드는 매력 중 하나를 이제나마 깨달아서 다행이고 지난 세월은 아쉽다.&lt;/p&gt;

&lt;h3 id=&quot;손그림&quot;&gt;손그림&lt;/h3&gt;
&lt;p&gt;꼬맹이가 미술에 관심과 집중력을 보여서 공통 취미나 관심사를 하나 정도 만들고자 손그림을 취미 생활 중 하나로 시작했다. 힘들고 어렵지만 재밌다. 내년엔 총 네 개 주제를 그리는 걸 목표로 삼았다.&lt;/p&gt;

&lt;iframe width=&quot;420&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/2XKOkWCAD5w&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

</content>
  </entry>
  
  <entry>
    <title>django-filter용 NULLS LAST 정렬 필터.</title>
    <link href="/2020/11/nulls-last-ordering-for-django-filter/"/>
    <updated>2020-11-13T11:00:00+09:00</updated>
    <id>/2020/11/nulls-last-ordering-for-django-filters</id>
    <content type="html">&lt;p&gt;이 글 내용은 PostgreSQL을 기반으로 하며, 다른 RDBMS 에서는 확인 안 해봤다.&lt;/p&gt;

&lt;h3 id=&quot;django-orm으로-nulls-last-정렬&quot;&gt;Django ORM으로 NULLS LAST 정렬&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hannal&lt;/code&gt;이라는 모델이 있고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 필드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;을 허용한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Hannal(models.Model):
    name = models.CharField(max_length=32, null=True, blank=True)
    birthday = models.DateField(null=True, blank=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여러 데이터의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 필드의 값이 다음과 같이 들어갔다고 가정하자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;abc&apos;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;zyx&apos;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;lmn&apos;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 필드로 오름차순(Ascending) 정렬해보자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hannal.objects.order_by(&apos;name&apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;abc&apos;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;lmn&apos;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;zyx&apos;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;결과는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;이 먼저 나온다. 만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;이 아닌 데이터를 먼저 정렬하고 그 이후에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;null&lt;/code&gt;인 데이터를 나열하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULLS LAST&lt;/code&gt;로 정렬해야 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db.models import F

Hannal.objects.order_by(F(&apos;name&apos;).desc(nulls_last=True))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;abc&apos;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;lmn&apos;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;zyx&apos;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우리가 원하는 대로 정렬됐다.&lt;/p&gt;

&lt;h3 id=&quot;django-filter의-orderingfilter&quot;&gt;django-filter의 OrderingFilter&lt;/h3&gt;

&lt;p&gt;이번엔 이를 &lt;a href=&quot;https://django-filter.readthedocs.io/&quot;&gt;django-filter&lt;/a&gt;에 적용해보자. django-filter에 정렬 필터인 &lt;a href=&quot;https://django-filter.readthedocs.io/en/stable/ref/filters.html#orderingfilter&quot;&gt;OrderingFilter&lt;/a&gt;를 사용하면 간편하게 정렬 필터를 적용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import django_filters as filters


class HannalFilter(filters.FilterSet):
    ordering = filters.OrderingFilter(
      fields=(
          (&apos;name&apos;, &apos;name&apos;, ),
          (&apos;birthday&apos;, &apos;saengil&apos;, ),
      ),
    )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;자세한 내용은 공식 문서에 나와있지만, 영문 싫어하는 사람도 많고 공식 문서가 썩 친절하진 않으니 설명하겠다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fields&lt;/code&gt;로 모델의 필드와 HTTP Query String에서 넘겨 받을 필드를 짝지어야 한다. 뒤(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;saengil&lt;/code&gt;)는 Query string으로 받을 값, 앞(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;birthday&lt;/code&gt;)은 모델의 필드/필드표현식을 뜻한다. 보통은 모델 필드명과 동일하게 하는 게 알아보기 좋지만, 다르게 해야 할 경우도 많다.&lt;/p&gt;

&lt;p&gt;우선 요청자(client)측에서 다른 이름을 쓰고 싶은 경우이다. Python 관례에 따르면 snake case 표기를 쓰겠지만, Front-end쪽에서는 camel case 표기를 대개 쓴다. 예를 들어 모델 필드명은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;birth_day&lt;/code&gt;인데 요청자는 굳이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;birthDay&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;saengil&lt;/code&gt;을 쓰고 싶은 경우이다.&lt;/p&gt;

&lt;p&gt;다른 경우가 더 흔한 경우인데, 모델 관계(model relationship)를 필드 표현식으로 다뤄야 하는 경우이다. 예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kay&lt;/code&gt;라는 모델이 있고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hannal&lt;/code&gt; 모델과 1:N 관계를 맺고 있다고 하자.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Kay(models.Model):
    name = models.CharField(max_length=32, null=True, blank=True)


class Hannal(models.Model):
    name = models.CharField(max_length=32, null=True, blank=True)
    birthday = models.DateField(null=True, blank=True)
    related = models.ForeignKey(&apos;Kay&apos;, on_delete=models.CASCADE)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Kay&lt;/code&gt; 모델의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 필드를 기준으로 정렬한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hannal&lt;/code&gt; 모델의 데이터를 가져오려면 다음과 같이 한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hannal.objects.order_by(&apos;related__name&apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;related__name&lt;/code&gt;을 django-filter 에서도 사용할 수 있다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class HannalFilter(filters.FilterSet):
    ordering = filters.OrderingFilter(
      fields=(
          (&apos;name&apos;, &apos;name&apos;, ),
          (&apos;birthday&apos;, &apos;saengil&apos;, ),
          (&apos;related__name&apos;, &apos;kayname&apos;, ),
      ),
    )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fields&lt;/code&gt;를 지정하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ordering&lt;/code&gt;키의 값으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;saengil&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kayname&lt;/code&gt;을 사용할 수 있다. &lt;a href=&quot;https://www.django-rest-framework.org/&quot;&gt;Django REST framework&lt;/a&gt;(이하 DRF)에 적용하면 URL을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?ordering=name&lt;/code&gt;로 하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 필드에 대해 오름차순 정렬하거나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?ordering=-name&lt;/code&gt;로 하여 내림차순 정렬한다. 이 뿐만 아니라 여러 개 필드를 정렬할 수도 있다. 예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 필드는 오름차순, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;birthday&lt;/code&gt; 필드는 내림차순으로 정렬하고자 한다면 HTTP Query String 으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;?ordering=name,-birthday&lt;/code&gt;라고 하면 된다.&lt;/p&gt;

&lt;h3 id=&quot;orderingfilter에-nulls-last-적용&quot;&gt;OrderingFilter에 NULLS LAST 적용&lt;/h3&gt;

&lt;p&gt;편하다. 근데 django-filter &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.4.0&lt;/code&gt; 버전 기준까지는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULLS LAST&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULLS FIRST&lt;/code&gt;를 지원하지 않는다. 그러므로 따로 구현해야 한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderingFilter&lt;/code&gt;가 제공하는 기능은 그대로 쓰되 QuerySet 만들 때 null 정렬만 추가하면 되니 이 클래스를 상속받아 쓴다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.db.models import F
import django_filters as filters


class NullsLastOrderingFilter(filters.OrderingFilter):
    def filter(self, qs, value):
        if not value:
            return qs
        for _v in value:
            is_desc = _v.startswith(&apos;-&apos;)
            field = self.param_map.get(_v[1:] if is_desc else _v)
            if not field:
                continue
            if is_desc:
                qs = qs.order_by(F(field).desc(nulls_last=True))
            else:
                qs = qs.order_by(F(field).asc(nulls_last=True))
        return qs


class HannalFilter(filters.FilterSet):
    ordering = NullsLastOrderingFilter(
      fields=(
          (&apos;name&apos;, &apos;name&apos;, ),
          (&apos;birthday&apos;, &apos;saengil&apos;, ),
          (&apos;related__name&apos;, &apos;kayname&apos;, ),
      ),
    )

    class Meta:
        model = Hannal
        fields = (&apos;name&apos;, &apos;birthday&apos;, )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위에서 설명한 내용을 모두 반영한 코드이다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter()&lt;/code&gt; 메서드는 django-filter 가 넘겨받은 QuerySet 객체이다. DRF에 연동해 사용한다면 DRF가 이런 저런 조치를 취한 QuerySet일테고, 사용자가 만든 filter 들을 거친 QuerySet이기도 하다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULLS FIRST&lt;/code&gt;를 적용하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nulls_last&lt;/code&gt; 대신 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nulls_first&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;로 지정하면 된다.&lt;/p&gt;

</content>
  </entry>
  
  <entry>
    <title>2019년을 마치며</title>
    <link href="/2019/12/closing/"/>
    <updated>2019-12-31T11:00:00+09:00</updated>
    <id>/2019/12/closing</id>
    <content type="html">&lt;p&gt;2019년을 회고하는 글을 쓰려 했는데 2019년엔 블로그에 글을 하나도 안 썼더라. 2019년에 쓴 블로그 첫 글이 2019년 회고 글이라니 웬지 맥이 빠져서 회고 대신 간결하게 정리만 해본다.&lt;/p&gt;

&lt;h3 id=&quot;방송통신대학교-졸업&quot;&gt;방송통신대학교 졸업&lt;/h3&gt;

&lt;p&gt;2016년에 신입생으로 방송통신대학교(이하 방송대)에 입학했고, 얼마 전 마지막 학기의 기말시험을 마쳤다. 목표대로 4년 만에 졸업하여 기쁘다. 매 학기에 여섯 과목 중 한두 과목은 날로 먹었는데, 그래도 성적 중 70%를 차지하는 객관식 기말시험은 부담스러웠다. 성적이 아주 높진 않지만, 장학금도 반 정도 받았고 대학원에 응시할 정도는 달성했다. 물론 대학원엔 안 갈 거지만.&lt;/p&gt;

&lt;p&gt;방송대를 적극 추천한다. 나를 비롯해서 많은 사람이 자신의 의지력을 과대 평가하는데, 방송대는 자신의 의지력을 파악하는 아주 좋은 측정자이다. 커리큘럼과 교수진도 좋으며, MS Office, GitHub 등 학생 혜택도 받는다.&lt;/p&gt;

&lt;h3 id=&quot;프리랜서-생활을-마치다&quot;&gt;프리랜서 생활을 마치다&lt;/h3&gt;

&lt;p&gt;2016년 3분기부터 프리랜서 생활을 시작했다. 만 3년 했는데, 이렇게 오래 할 줄 몰랐다. 프리랜서 생활이 방송통신대학교 학업 진행에 딱히 더 유리하거나 불리한 건 없었다. 직장인에 비해 출석 수업에 나가기 편하긴 했지만, 늘 여러 일을 진행했기 때문에 일정하게 공부할 시간 자체를 확보하기 힘들었다.&lt;/p&gt;

&lt;p&gt;매년 직전 년도 기준으로 평균 30~40%씩 성장했던 건 고객 덕분이다. 유연하고 기민하게 협업하려는 목적으로 진행한 협업 방식이 중장기 프로젝트에서는 기대만큼 잘 동작하지 않았는데, 후반 프로젝트들은 중장기 계획으로 진행하여 나나 고객사들 모두 고생했다. 아쉬운 마음이 많이 남는다.&lt;/p&gt;

&lt;h3 id=&quot;회사-입사&quot;&gt;회사 입사&lt;/h3&gt;

&lt;p&gt;프리랜서 생활을 마치고 &lt;a href=&quot;http://fitpet.co.kr&quot;&gt;핏펫&lt;/a&gt;에 합류했다. 주변 사람들은 내가 1. 프리랜서 생활을 뜬금없이 그리고 갑자기 마치고선 회사에, 2. 그 회사의 사업 분야가 반려동물이라는 점, 3. 개발 실무자가 아니라 관리자로 합류했다는 사실을 놀라워하거나 신기해했다. 공감한다.&lt;/p&gt;

&lt;h3 id=&quot;1년에-3만km&quot;&gt;1년에 3만km&lt;/h3&gt;

&lt;p&gt;테슬라 모델X를 출고하고 만 1년 만에 주행거리 3만km를 돌파했다. 그동안 들어간 에너지 비용이 대략 40만원으로 1km 당 13~14원 정도 들었다. 이전에 타던 차가 디젤이고 리터 당 17~20km 정도 달렸는데, 리터 당 1,400원으로 계산하여 3만km를 달렸다면 대략 230만원 정도 연료비가 들었을 것이다.&lt;/p&gt;

&lt;p&gt;출고 1년 동안 여러 펌웨어 업데이트가 이뤄져 기능과 성능만 놓고 보면 1년 전에 산 그 차가 맞는 지 의심될 수준이다. 배터리는 1% 정도 열화되어 주행거리 20만km까지는 많이 불편하지 않을 것 같다.&lt;/p&gt;

&lt;h3 id=&quot;책&quot;&gt;책&lt;/h3&gt;

&lt;p&gt;한 해를 정신없이 보내서 책은 거의 안 읽었다고 생각했는데, 세보니 40권 정도 읽었다. 개발 관련 책은 필요한 부분만 보다보니 완독한 책은 몇 권 없다. 4분기엔 평일 두 시간씩 운전하다 보니 전자책을 TTS로 듣는다. 처음 읽는 책을 TTS로 들으니 개운하지 않다. 정독하기 전이나 후에 TTS로 듣는 게 나을 것 같다.&lt;/p&gt;

&lt;h3 id=&quot;개발-프로그래밍&quot;&gt;개발, 프로그래밍&lt;/h3&gt;

&lt;p&gt;알고리즘과 자료구조, 수학에 취약하다. 방송대 3학년부터 슬슬 압박을 받는 요인이었다. 공부하고 끝! 하는 게 아니라 그냥 평생 취미로 재미로 붙들고 살아야겠다.&lt;/p&gt;

&lt;p&gt;이런 저런 언어나 도구를 여럿 익혔지만, 별 감흥이 없다. 모래성 위에 깃발 꽂은들.&lt;/p&gt;

&lt;h3 id=&quot;영어&quot;&gt;영어&lt;/h3&gt;

&lt;p&gt;Safari Books online에서 낑낑대며 원서 읽고 있는데 번역서가 나온 적이 있다. 듣고 싶은 강의가 자막도 없이 영어로만 진행된 게 좀 있다. 영어가 발목을 잡은 적이 한두 번이 아니긴 했지만, 최근 유독 영어가 학습하는 데 제약이 되는 빈도가 늘었다. 의도적 수련으로 다시 공부하겠다.&lt;/p&gt;

&lt;h3 id=&quot;건강&quot;&gt;건강&lt;/h3&gt;

&lt;p&gt;중년에 들어섰다는 걸 절감한다. 손목, 어깨, 손가락, 허리 부근 직업병은 갈수록 심해지고, 체력 저하도 심각하다. 집중력과 의지력, 친절과 배려심은 체력에서 나오더라. 크로스핏을 사랑하지만 또 다치고 나서 잠정 중단했다. 체형 교정과 유연성을 개선하기 전엔 재개하면 안 될 것 같다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>테슬라 모델 X 구매기</title>
    <link href="/2018/12/newbies-buying-guide-for-tesla-model-x/"/>
    <updated>2018-12-29T02:00:00+09:00</updated>
    <id>/2018/12/newbies-buying-guide-for-tesla-model-x</id>
    <content type="html">&lt;p&gt;얼마 전에 테슬라 모델 X를 샀다. 전기차 보조금을 받지 못하다보니 조금이라도 저렴하게 사려고 여러 방법을 모색했다. 돌이켜보면 복잡하거나 어려운 건 없으며 이미 여러 곳에 도움이 되는 정보가 많은데, 내 상황을 기준으로 구매 과정을 정리해본다.&lt;/p&gt;

&lt;p&gt;분명 이 글이 구매 과정에 도움이 될 터이니 구매한다면 내 테슬라 리퍼럴 코드를 사용해주시라. :)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ts.la/kyeongmook93899&quot;&gt;https://ts.la/kyeongmook93899&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;구매-방법-별-테슬라-종류&quot;&gt;구매 방법 별 테슬라 종류&lt;/h2&gt;

&lt;p&gt;리스 등을 제외한 구매하는 방법에 따라 테슬라는 크게 세 가지 종류가 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;일반 차량&lt;/li&gt;
  &lt;li&gt;인벤토리 차량&lt;/li&gt;
  &lt;li&gt;테슬라코리아의 플릿카 중고판매 (이하 플릿카)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일반 차량은 정식 경로(?)이자 일반화 된 구매 차량이다. 테슬라 홈페이지에서 차량 옵션을 지정하고 계약하면 공장에서 주문 내용에 맞는 차량을 생산한다. 장점은 옵션을 입맛대로 지정할 수 있고, 단점은 다른 두 종류에 비해 비싸고 출고하는 기간이 길다.&lt;/p&gt;

&lt;p&gt;인벤토리 차량은 여러 이유로 창고에 대기하는 &lt;em&gt;새 차&lt;/em&gt;이다. 그래서 계약하면 일반 차량에 비해 빠르게 출고 받으며, 경우에 따라서는 할인을 조금 해준다. 단점은 옵션이 적용된 완성 차량을 사는 것이므로 내가 원하는 옵션이 적용된 차량을 사지 못할 수 있다.&lt;/p&gt;

&lt;p&gt;플릿카는 법인 등이 한 번에 다수를 구매하는 플릿 판매를 뜻하는데, 전시, 시승 등 여러 용도로 테슬라 차량을 테슬라 코리아도 구매한다. 이런 차량을 판매하는 것이다. 중고차를 파는 것이므로 가격이 저렴한데, 차에 따라 주행 거리, 상태, 옵션이 다르므로 가격은 제각각이다.&lt;/p&gt;

&lt;p&gt;인벤토리 차량과 플릿카는 홈페이지 등에 나오지 않으므로 매장에 전화해서 재고 등을 직접 문의하면 된다.&lt;/p&gt;

&lt;h2 id=&quot;향상된-오토파일럿&quot;&gt;향상된 오토파일럿&lt;/h2&gt;

&lt;p&gt;구매할 때 “향상된 오토파일럿”은 꼭 추가하길 추천한다. 만약 이 옵션을 뺄 것이라면 다른 전기차를 사는 게 가격이나 충전 인프라 등을 고려해 더 낫다. 테슬라 차주 사이에서는 오토파일럿 옵션을 뺄 것이라면 차라리 차량을 빼고 오토파일럿을 사라는 우스개소리가 나올 정도로 테슬라의 오토파일럿(옵션명 : 향상된 오토파일럿)은 만족스럽다.&lt;/p&gt;

&lt;h2 id=&quot;선납금-오토캐시백&quot;&gt;선납금 오토캐시백&lt;/h2&gt;

&lt;p&gt;차량 구매에 들어가는 돈을 카드로 결제하면 일정 비율로 현금을 돌려주는 카드 상품으로 오토캐시백이 있다. 요즘은 1% 중후반에서 2% 초중반까지 돌려주는 것 같다.&lt;/p&gt;

&lt;p&gt;나는 일반 할부로 구매하므로 선납금에 대해 오토캐시백을 활용할 수 있었다. 선납금은 계약금을 포함하는데, 계약금을 먼저 납입한 뒤 출고할 때쯤 나머지 선납금 잔금을 납입한다. 그래서 오토캐시백도 두 번에 걸쳐 나눠서 진행하면 된다. 예를 들어 총 선납금을 3,000만원으로 잡으면 계약금 1,000만원에 대해 오토캐시백 적용하고, 잔금 2,000만원을 납입할 때 오토캐시백을 적용하면 된다.&lt;/p&gt;

&lt;p&gt;오토캐시백은 웹에서 검색하면 여러 업체가 나온다. 혹은 네이버 까페에서 오토캐시백으로 검색하면 활동이 왕성한 까페 몇 개가 나오는데, 그곳에서 상담 신청을 하면 연락이 온다. 주의할 점은 테슬라 코리아가 판매하는 차량에 대해 오토캐시백이 안 되는 카드사가 있다는 점이다. 오토캐시백 상담자에게 꼭 확인하자. 캐시백 비율은 카드사에서 직접 받는 것보다 중개/영업인(?)에게서 받는 것이 더 좋다. 예를 들어 하나카드 오토캐시백은 1% 초중반인데, 중개/영업 업체 끼고 하나카드 오토캐시백을 진행하면 1% 중반 이상 받는다.&lt;/p&gt;

&lt;p&gt;다음과 같이 오토캐시백을 받는 결제가 진행된다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;오토캐시백을 진행할 카드사 선택. 기존에 사용하는 카드로도 가능하나 이 경우 신규 고객 유치가 아니기 때문에 캐시백 비율이 줄어든다.&lt;/li&gt;
  &lt;li&gt;오토캐시백 받을 금액을 정함.&lt;/li&gt;
  &lt;li&gt;자신이 선택한 카드사로부터 가상계좌번호를 받으면 그곳에 계약금을 입금.&lt;/li&gt;
  &lt;li&gt;결제에 사용할 카드에 해당 금액에 대해 특별한도가 승인됨. 자신이 기존에 보유한 카드 한도가 계약금 보다 낮아도 무방하다. 예치한 계약금에 대해 특별한도 처리가 되기 때문이다. 이 금액은 테슬라 코리아쪽에 결제를 할 때 빠져 나간다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;선납금 잔금도 2~4번 과정을 그대로 반복한다. 잔금은 출고 방식에 따라 초기 견적 내용과 달라지므로 최종 잔금 안내를 받고 나서 잔금에 대한 오토캐시백을 진행하자.&lt;/p&gt;

&lt;p&gt;차량 계약금과 선납금은 전화 통화로 결제한다. 결제 금액을 분할할 수 있다. 나는 차량을 직접 등록하는 등 몇 가지 이유로 최종 잔금이 확정될 때까지 잔금 액수가 몇 번 변동되었다. 그래서 변동되지 않을 만한 단위와 나머지 자잘한 금액으로 분할해서 결제했다. 무슨 말이냐면 예를 들어 잔금이 2,XXX만원이 될 것으로 예상된다면 오토캐시백으로 2,000만원을 신청하고, 잔금을 결제할 때 테슬라 코리아에 2,000만원과 나머지 금액으로 나눠서 결제하겠다고 요청한 것이다. 오토캐시백을 받으려면 먼저 오토캐시백을 적용받을 금액을 예치해야 하고 이 과정이 몇 시간 걸릴 수도 있는데, 잔금이 정확하게 최종 확정되는 건 오토캐시백 준비를 마친 이후 단계이기 때문이다.&lt;/p&gt;

&lt;p&gt;당연한 얘기지만 차량 구매 금액에 대한 오토캐시백이다. 등록비나 부대 비용은 오토캐시백 대상이 아니다.&lt;/p&gt;

&lt;h2 id=&quot;차량-자가-등록&quot;&gt;차량 자가 등록&lt;/h2&gt;

&lt;p&gt;차량 등록을 직접 했다. 대행으로 진행하면 차량 번호를 못 고르며 대행비가 들지만, 직접 등록하면 자동차등록소에서 제시하는 후보군 중 하나를 고를 수 있고 대행비도 아낀다. 절차도 간단하다.&lt;/p&gt;

&lt;p&gt;먼저 테슬라 코리아측의 내 담당 OA에게 혹은 차량 출고 담당자에게 차량 등록을 직접 할 것이라고 알려준다. 차량 출고 담당자는 선납금을 모두 치를 때쯤 정해져 연락이 온다. 자가 등록을 한다고 하면 테슬라 코리아에서 필요한 서류를 등기로 보내준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리스 계약서 (리스 구매인 경우, 리스사에서 제공)&lt;/li&gt;
  &lt;li&gt;세금계산서&lt;/li&gt;
  &lt;li&gt;테슬라코리아 위임장&lt;/li&gt;
  &lt;li&gt;테슬라코리아 사용인감계&lt;/li&gt;
  &lt;li&gt;자동차 제작증&lt;/li&gt;
  &lt;li&gt;자동차 배출가스 인증서&lt;/li&gt;
  &lt;li&gt;자동차 소음인증서&lt;/li&gt;
  &lt;li&gt;자동차 제원표&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;구매자는 주민등록등본(법인은 법인등기부등본)과 자동차 보험증권 사본만 준비하면 된다.&lt;/p&gt;

&lt;p&gt;자동차 보험은 차대번호를 테슬라코리아로부터 받으면 가입할 수 있다. 주의할 점은 자동차보험 개시일이 자동차 등록일과 같거나 이전이어야 한다. 나는 자동차 등록을 하려는 날과 출고하는 날이 주말 제외하면 하루 차이라서 보험개시일을 출고일에 맞추는 실수를 했다. 당연히 자동차 등록은 거부되었고 부랴부랴 자동차보험을 해약하고 새로 가입했다.&lt;/p&gt;

&lt;p&gt;자동차등록은 아무 자동차등록소에서 해도 된다. 주민등록 상 거주지에 따라 공채 비용이 발생한다. (2019년 1월 16일 내용 보완)&lt;/p&gt;

&lt;p&gt;자동차등록소에 가서 자동차 신규등록 신청서를 작성하고 제출한다. 접수하는 데 2,000원, 인지료 3,000원 &lt;em&gt;현금&lt;/em&gt;이 필요하다. 임시 번호판은 필요 없다. 자동차 번호는 미리 정해진 후보들 중 하나를 선택하는 것이다. 모두 마음에 들지 않으면 다음 날 등록 신청 과정을 다시 진행해도 된다. 번호를 고르면 등록 신청이 접수된다. 다음은 징수과에 가서 세금(취등록세)을 낸다. 세금은 신용카드로 결제할 수 있다. 약 700만원 정도인데 2019년엔 감면 금액이 줄어들기 때문에 납부할 세금이 더 늘어난다. 징수과에서 징수를 마치고 확인을 받으면 차량 등록이 끝난다.&lt;/p&gt;

&lt;p&gt;차량 등록이 끝나면 선택한 차량 번호를 들고 번호판 제작과에 가서 번호판을 만든다. 일반 하얀 색 번호판과 전기차에 사용하는 파란 색 번호판이 가격이 다른데, 파란 색 번호판이 더 비싸다. 전기차이므로 반드시 파란 색 번호판을 만들 필요는 없어서 일부러 차량 외관 색에 어울리게 흰색 번호판을 고르는 경우도 있다. 번호판이 파란 색이어야만 친환경 차량 혜택을 받는 것이 아니며, 친환경 차량이라는 걸 알아보기 용이한 장점이 있다.&lt;/p&gt;

&lt;p&gt;…고 알고 있었는데, 잘못된 내용이다. 내 경우 흰색 번호판으로 만들었다가 찝찝해서 파란색 번호판으로 변경/제작했다. 알고보니 이는 행정 착오이며, 2017년 6월 9일 이후 출고된 전기차는 파란색 번호판 장착이 의무이다. (2019년 1월 16일 내용 보완)&lt;/p&gt;

&lt;p&gt;번호판은 긴 것으로 만들어야 한다. 번호판과 나사, 저공해 차량 스티커를 받으면 모든 과정이 끝난다. 번호판 가드(가이드)는 테슬라에서 제공하므로 받지 않아도 되며, 당연히 번호판도 테슬라 코리아에서 달아준다.&lt;/p&gt;

&lt;h2 id=&quot;자동차-보험&quot;&gt;자동차 보험&lt;/h2&gt;

&lt;p&gt;자동차 보험은 사람 마다 조건이 천차만별이므로 자동차보험 견적 업체를 이용해 비교 견적을 받으면 된다. 내 경우 가장 비싼 견적과 가장 저렴한 견적의 금액이 약 20만원 가까이 차이났다. 적용할 수 있는 할인 항목이 있으니 보험사 별로 견적을 받을 때 해당 항목으로 할인이 얼마나 되는 지 확인한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;차선유지장치&lt;/li&gt;
  &lt;li&gt;긴급제동장치 (전방충돌방지)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;테슬라 차량 펌웨어 v9에는 블랙박스 기능이 추가됐지만, 이걸로 블랙박스 할인이 가능한지는 모르겠다. 차선유지장치는 현재(2018년 12월) 기준으로 대부분 보험사에 할인 항목으로 있는 것으로 보이고, 긴급제동장치는 일부 보험사에서만 할인해주는 것 같다. 해당 기능은 차량에 부가 설치한 것이 아닌 기본 탑재라고 대답하면 된다. 나는 블랙박스, 만 6세, 차선유지장치, 대중교통이용에 대해 할인을 받아 20% 가까이 할인 받았다. 또 보험사에 따라서는 특정 결제 방법에 대해 캐시백을 해주는데, 난 이 부분에서도 3만원을 캐시백 받았다.&lt;/p&gt;

&lt;p&gt;보험 가입할 때 블랙박스 장착 증빙, 차선유지장치 증빙을 할 수 없으므로 할인 항목에서 제외한다. 출고 후 전화를 걸어 증빙자료인 사진을 보내서 할인 받을 금액을 환급 받는다.&lt;/p&gt;

&lt;p&gt;자동차 보험 가입 담보 중 “자기신체손해”와 “자동차 손해”를 선택하는 부분이 있는데, 자동차 상해가 보험비는 좀 더 높지만 조건이 좋다. 자기신체손해는 진단에 따른 부상 급수에 따라 보험금이 지급되고 자동차 상해는 실비 100%를 지급하기 때문이다. 그런데 내가 가입한 보험사에서는 다른 실손보험과 중복 보상을 하지 않는다. 이미 나는 실손보험에 가입했기 때문에 고민 끝에 자기신체손해를 선택했다. 이 부분은 보험사와 상담해보길 권한다.&lt;/p&gt;

&lt;h2 id=&quot;전기차에-유용한-결제-카드와-전기차-충전-카드&quot;&gt;전기차에 유용한 결제 카드와 전기차 충전 카드&lt;/h2&gt;

&lt;p&gt;결제에는 크게 두 가지 카드를 많이 사용한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BC그린카드&lt;/li&gt;
  &lt;li&gt;신한EV카드&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 부분에 대한 자세한 내용은 &lt;a href=&quot;https://cafe.naver.com/teslaownersclub&quot;&gt;한국 테슬라 오너스 클럽&lt;/a&gt;에 잘 정리된 글, &lt;a href=&quot;https://cafe.naver.com/teslaownersclub/2274&quot;&gt;충전 카드와 할인용 신용 카드에 대한 이해
충전 카드와 할인용 신용 카드에 대한 이해&lt;/a&gt;를 참고하자. 이 글에서는 내 상황에 맞춘 내용만 정리하자면,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;거주지 주차장에 공용 완속 충전기(파워큐브)가 있어서 이 충전 시설 이용하는 데 신한EV 카드 사용&lt;/li&gt;
  &lt;li&gt;이외 공용 충전 서비스에 결제 카드로 BC그린카드 사용&lt;/li&gt;
  &lt;li&gt;하이패스 결제 카드로 신한EV 카드 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;신한EV카드의 경우 신한EV카드 + 신한하이패스로 신청해야 한다. 두 카드를 따로 따로 신청해도 되지만 번거롭다.&lt;/p&gt;

&lt;p&gt;BC그린카드는 BC카드에서 발행하므로 입맛에 맞는 금융권 카드사의 카드로 신청하면 된다. 나는 연회비가 없는 하나BC그린카드 v1 으로 신청했다. 주의할 점은 이 카드는 하나카드 모바일 앱에서는 검색이 안 되므로 웹에서 검색해서 주문하면 된다.&lt;/p&gt;

&lt;p&gt;충전용 카드는 환경부에서 발급하는 카드와 한국전기차충전서비스(줄여서 한전충)에서 발급하는 해피차저 카드를 주로 사용한다. 전기차 충전 업체가 다양하므로 자신의 환경과 상황에 맞는 카드를 발급 받으면 되는데, 환경부 카드와 한전충 카드로 대부분 불편을 겪지 않고 소화할 수 있다.&lt;/p&gt;

&lt;p&gt;해피차저 카드와 환경부 카드 모두 차량 등록하기 전, 그러니까 차량 번호를 발급 받기 전에 해당 카드를 발급 받을 수 있다. 해피차저 카드는 아무 차량 번호로 카드를 먼저 발급 받고, 이후에 차량 번호가 나오면 기존에 입력한 차량 번호를 실제 차량 번호로 수정하면 된다. 환경부 카드의 경우 웹페이지에서 차량 번호를 변경할 수 없는데, 전화(1661-9408)해서 변경해달라고 하면 된다. 카드를 신청하면 실물 카드가 우편으로 배송되는데, 실물 카드 수령 전에 카드번호가 먼저 나온다.&lt;/p&gt;

&lt;h2 id=&quot;하이패스&quot;&gt;하이패스&lt;/h2&gt;

&lt;p&gt;전기차 할인이 되는 하이패스는 차량 등록을 해야 구매할 수 있다. 주로 AP 500과 AP 700 제품을 사용하는 것 같은데, 난 하이패스 카드를 언제든 꼈다 뺐다 할 수 있는 AP 500을 샀다. 정리하면 나는 AP 500 기기에 신한 하이패스 카드를 꽂으며, 후불형인 이 하이패스 카드에 신한EV 카드를 연동하였다. 이렇게 조합하면 톨게이트 비용 50%를 캐시백 받는데, 전기차는 50% 할인을 받으므로 결국 톨게이트 비용이 0원인 셈이다. 아쉬운 점은 이 프로모션이 2019년 2월에 종료된다는 점인데, 소문에 따르면 기간이 연장될 것을 기대하고 있는 분위기이다.&lt;/p&gt;

&lt;p&gt;민자 고속도로의 경우 전기차 할인이 안 되는 곳이 있다(많이 혹은 대부분).&lt;/p&gt;

&lt;h2 id=&quot;충전-어댑터&quot;&gt;충전 어댑터&lt;/h2&gt;

&lt;p&gt;일부 플릿카를 제외하면 요즘 구매하는 차량은 거의 모두 북미형 충전 포트이다. 테슬라 독자 포트이므로 테슬라에서 운영하는 충전소 외엔 충전하지 못하는데, 국내 충전 시설을 이용하려면 충전기와 테슬라를 연결해주는 어댑터를 따로 마련해야 한다. 이 어댑터를 테슬라 코리아에서 판매할 수 없는 상황이어서 차량 구매 시 어댑터 가격을 빼주는데, 테슬라 온라인 스토어 등에서 직접 구매해야 한다.&lt;/p&gt;

&lt;p&gt;급속 충전 어댑터는 차데모를 사야 한다. 문제는 2018년 4월에 공표된 우리나라의 표준 충전 방식에 차데모 어댑터를 사용할 수 없으며, 차데모 어댑터를 사용할 수 있던 기존 충전기도 점차 줄어든다는 점이다. 즉 차데모 어댑터는 시한부이다. 꽤 비싸기 때문에 구매 여부를 잘 생각해야 한다. 나는 고민 끝에 안 샀다.&lt;/p&gt;

&lt;p&gt;완속 충전은 J1772 어댑터를 사면 된다. 차데모와 마찬가지로 테슬라 온라인 스토어에서 판매한다.&lt;/p&gt;

&lt;p&gt;테슬라 온라인 스토어는 테슬라 웹페이지에서 국가를 북미로 선택하면 접근할 수 있다. 직구는 되지 않으므로 배송 대행 서비스를 이용해야 한다. 배송은 매우 느려서 테슬라 온라인 스토어에서 배송 대행지까지 물품이 도착하는 데 10~14일 정도 소요된다. 나는 블랙 프라이데이 등 연말 상황이라서 배송 대행지에서도 7일 넘게 시간이 소요됐다. 차데모나 J1772 어댑터가 필요하다면 넉넉잡아 출고 전에 한 달 정도 시간을 염두에 두고 일찌감치 주문하길 추천한다.&lt;/p&gt;

&lt;h2 id=&quot;블랙박스&quot;&gt;블랙박스&lt;/h2&gt;

&lt;p&gt;차체가 워낙 커서 주차 상태에서 테러 당할 여지가 있다. 모델 X를 주차면이 좁은 곳에 세우면 주차면을 거의 꽉 채우고도 앞으로 머리가 빼꼼 나와서 문콕이나 범퍼 충돌을 당하는 경우가 많아 보인다. 그래서 블랙박스를 주차 중에도 동작하는 상시전원으로 사용하고자 했다. 상시 전원으로 블랙박스를 사용하려면 OBD 2에 연결하거나 보조 배터리를 사용하는데, 나는 고민 끝에 보조 배터리를 추가하여 블랙박스를 상시로 켜둔다. 테슬라의 12V 배터리는 여느 내연차 보다 용량이 작다고 한다. 그래서 자칫 12V 배터리를 과용하다 방전시키는 경우가 있다고 한다. 거대한 배터리를 품고 있는 전기차인데 정작 상시전원으로 12V 배터리를 사용하는 건 내연차 보다 더 제약을 받을 수 있다니 모순되게 느껴진다.&lt;/p&gt;

&lt;p&gt;OBD 2에 연결하여 사용하는 데 성공한 차주에 따르면 아직 별 문제는 없다고 한다.&lt;/p&gt;

&lt;h2 id=&quot;커뮤니티&quot;&gt;커뮤니티&lt;/h2&gt;

&lt;p&gt;테슬라 관련 커뮤니티가 몇 곳 있는데, &lt;a href=&quot;https://cafe.naver.com/teslaownersclub&quot;&gt;한국 테슬라 오너스 클럽&lt;/a&gt;은 기본으로 가입하길 추천한다. 이름처럼 꼭 테슬라 차주가 아니더라도 가입하고 활동할 수 있으며, 유용한 정보가 많다.&lt;/p&gt;

&lt;h2 id=&quot;출고&quot;&gt;출고&lt;/h2&gt;

&lt;p&gt;미리 잡은 출고 일시에 출고지(강서 서비스센터)로 가면 된다. 신분증과 차량 등록증을 가져가면 되며, 차량을 직접 등록했다면 번호판도 가져간다. 강서 서비스센터 인근에 딱히 식사할 만한 곳이 많진 않으니 출고 전후에 식사를 할 것이라면 시간 여유를 둘 필요가 있다.&lt;/p&gt;

&lt;p&gt;테슬라 차량의 마감은 악명이 높다. 단차나 도장 등 문제를 꼼꼼히 살펴보자. 인도했다고 해서 모르쇠로 대응하지 않으며, 언제든 친절하게 단차 등 마감 문제에 대해 대응하고 해결해준다고 한다. 테슬라 키팝(간단히 말해서 차 열쇠) 두 개, 모바일 충전 커넥터, 월 커넥터, 인도 확인증 받으면 출고는 끝난다. 모델 X 7인승엔 작은 차량용 소화기가 제공되는데, 국민권익위원회에 따르면 &lt;a href=&quot;https://www.acrc.go.kr/acrc/board.do?command=searchDetail&amp;amp;menuId=050505&amp;amp;method=searchDetailViewInc&amp;amp;boardNum=71229&amp;amp;currPageNo=1&amp;amp;confId=4&amp;amp;conConfId=4&amp;amp;conTabId=0&amp;amp;conSearchCol=BOARD_TITLE&amp;amp;conSearchSort=A.BOARD_REG_DATE+DESC%2C+BOARD_NUM+DESC&quot;&gt;2019년 하반기부터 모든 차량에 의무 설치하도록 한다&lt;/a&gt;고 한다.&lt;/p&gt;

</content>
  </entry>
  
  <entry>
    <title>생각 출력거름망</title>
    <link href="/2018/02/the-filters/"/>
    <updated>2018-02-05T02:00:00+09:00</updated>
    <id>/2018/02/the-filters</id>
    <content type="html">&lt;p&gt;말을 하거나 글을 쓰는 게 갈수록 힘에 부친다. 출력거름망이 늘어가기 때문이다. 사소하게는 오타 확인부터 시작해 맞춤법과 단어 뜻을 확인한다. 글이나 말 내용과 무관하지만 나와 조금이라도 연관된 이해관계자를 2008년부터 의식하고, 몇 년 전부터는 아직 몸과 머리에 익지 않은 정치적 올바름이나 꼰대성억제 거름망도 덧붙였다.&lt;/p&gt;

&lt;p&gt;말 한 마디, 문장 하나 쓰는 데 이렇게까지 해야 하나 생각하기도 했다. 그런데 그렇게까지 해서 굳이 생각을 출력하지 않아도 괜찮더라. 아니다. 괜찮은 정도가 아니라 더 낫다. 그렇게까지 하지 않은 말이나 글을 남발했다. 내 말과 글 대다수는 세상에 그렇게까지 가치있는 영향을 끼치지 않는다. 그래서 출력하는 것과 출력하지 않는 차이가 크지 않다. 질과 양을 꾸준하고 일정하게 유지한다면 의미있게 차이나겠지만, 거름망 여러 겹을 거치는 의지력이 너무 많이 든다.&lt;/p&gt;

&lt;p&gt;내가 말하거나 글로 쓰려는 생각을 표현하는 사람이 많다. 내 취향에 안 맞고 미묘하게 내 생각과는 다르곤 하지만, 그 차이 때문에 굳이 비싼 의지력을 들일 필요는 없다. 예전엔 들였는데 이제는 의지력이 달려서 아껴 써야 한다.&lt;/p&gt;

&lt;p&gt;내가 바라는 해결책이 아니긴 하다. 여러 겹으로 작용하는 거름망에 익숙해져 거름망 모두를 한두 겹 거름망에 들어가는 의지력만으로도 통과하며 생각을 표현하고 싶다. 그런데 각 출력거름망은 고정되지 않아서 꾸준히 들여다보고 갱신해야 한다. 거름망을 통과하는 것도 벅찬데, 거름망 관리도 해야 한다.&lt;/p&gt;

&lt;p&gt;개인 홈페이지부터 시작해 20년 넘게 유지한 개인 공간을 앞으로 어떡할 지 고민해본다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>소울부스터 개발 후기</title>
    <link href="/2018/01/soulbooster-production-story/"/>
    <updated>2018-01-10T02:00:00+09:00</updated>
    <id>/2018/01/soulbooster-production-story</id>
    <content type="html">&lt;p&gt;최근에 1년 동안 여성 맞춤 속옷을 제조하고 판매하는 소울부스터와 함께 일했다. 지난 1년을 돌아보는 후기를 적어본다. 참고로 기술 얘기 보다는 개발 과정(production)을 이야기하는, 말 그대로 개발 후기이다.&lt;/p&gt;

&lt;p&gt;이 글은 글자가 많다. 다 읽기 귀찮으면 “세 줄 요약”과 “마무리”만 봐도 된다.&lt;/p&gt;

&lt;h2 id=&quot;세-줄-요약&quot;&gt;세 줄 요약&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;소울부스터에 임시 개발 총괄자로 참여하여 프로젝트를 개시하고, 출시하여 운영했다.&lt;/li&gt;
  &lt;li&gt;함께 개발팀도 구축했다.&lt;/li&gt;
  &lt;li&gt;소울부스터는 연 이륙하기 시작했고 개발자를 충원하고 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-첫-만남&quot;&gt;1. 첫 만남&lt;/h2&gt;

&lt;p&gt;2년 다닌 회사를 퇴사한 지 얼마 안 되어 지인 소개로 &lt;a href=&quot;https://www.soulbooster.co.kr&quot;&gt;소울부스터&lt;/a&gt;를 만났다. 여성 맞춤 속옷을 직접 제조하고 판매하는 사업으로 창업한 지 얼마 안 된 시기였고, 온라인 서비스를 직접 개발하기 위해 소프트웨어 개발팀(이하 개발팀) 구축을 모색하고 있었다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.soulbooster.co.kr&quot;&gt;&lt;img src=&quot;/assets/uploads/2018/01/soulbooster-image.png&quot; alt=&quot;사진 출처 : 소울부스터&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://www.soulbooster.co.kr&quot;&gt;사진 출처 : 소울부스터&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;많은 회사가 소프트웨어 개발자(이하 개발자)를 뽑기 힘들고 어렵다며 아우성이다. 그들 말엔 온도 차가 있긴 하다만, 어쨌든 인력 시장이라는 측면에서 수요자는 다양해지고, 수는 늘고, 수요자의 사업 환경은 급변하여 수요는 빠르게 늘고 있는 데 반해 아직 공급은 수요를 못따라간다. 특히 괜찮은(?) 개발자 공급은 더욱 더 그렇다.&lt;/p&gt;

&lt;p&gt;난 자체 개발하지 말고 쇼핑몰 제품을 구입하거나 쇼핑몰 호스팅 서비스로 먼저 서비스를 출시하는 걸 조심스레 권했다. 대개는 잘 만든 솔루션을 쓰는 것이 낫다. 일정이 변수가 아닌 상수에 가깝게 명확해져서 장사라는 쇼핑몰의 사업 본질을 실행하고 가설을 검증하는 데 필요한 기간이 짧고 예측 가능하기 때문이다. 물론 입맛에 딱 맞지 않은 부분도 있겠지만, 대개 그런 부분은 사업 운용에 핵심이 아닌 경우가 많다. 핵심은 팔려는 제품이 고객에게 가치를 전달하는 것이다.&lt;/p&gt;

&lt;p&gt;소울부스터 박수영 대표는 소울부스터가 제공하는 가치는 고객 마다 다른 체형을 진단하여 몸에 잘 맞는 속옷을 제안하는 것이라 했다. 체형 진단을 위한 퀴즈 알고리즘을 중요한 사용자 경험으로 제공하고, 그러한 고객 경험을 서비스 시작부터 내재화해야 하기 때문에 개발팀을 초기부터 구축해야 한다고 했다. 동의했다.&lt;/p&gt;

&lt;p&gt;합류 논의는 서로 신중했다. 난 소울부스터가 추구하는 가치와 그 가치에 접근하는 방법에 공감했지만, 내가 잘 모르는 사업 아이템이어서 목표에 이르는 과정이 잘 그려지지 않아 조심스러웠다. 박수영 대표 역시 첫 개발자 영입을 신중하고 조심스러운 입장으로 진행하고 있었다. 서로 조심스러웠지만, 박수영 대표는 마냥 개발을 미룰 순 없다고 생각했는지 실행 방법을 논의하자고 했다. 우리는  고심한 끝에 실행 계획을 수립했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;체형 진단 퀴즈 서비스와 쇼핑몰 개발을 내가 총괄하여 목표 일정에 맞춰 출시한다.&lt;/li&gt;
  &lt;li&gt;소울부스터는 개발자 구인을 계속 진행한다.&lt;/li&gt;
  &lt;li&gt;우리의 목표는 소울부스터에 개발팀이 구축되고 연이륙하는 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;내가 정식으로 합류할 지 여부는 프로토타입 버전을 개발한 뒤에 다시 논의하기로 했다. 그렇게 우리의 협업은 시작되었다.&lt;/p&gt;

&lt;h2 id=&quot;2-소울부스터-개발-과정&quot;&gt;2. 소울부스터 개발 과정&lt;/h2&gt;
&lt;p&gt;구현에 사용할 도구(기술 스택)를 선택하는 중요한 기준은 개발 공정과 개발팀 두 가지를 구축한다는 목표에 근간을 두었다.&lt;/p&gt;

&lt;h3 id=&quot;back-end&quot;&gt;Back-end&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Application Server : Python 3, Django&lt;/li&gt;
  &lt;li&gt;DBMS, Storage : MySQL 5.7, Redis&lt;/li&gt;
  &lt;li&gt;OS : Ubuntu 16 LTS&lt;/li&gt;
  &lt;li&gt;Infrastructure : Amazon Web Service&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;소울부스터는 나와 처음 만나기 전에 체형을 진단하는 퀴즈 알고리즘을 이미 상당히 설계한 상태였다. 데이터 관계와 논리 체계가 상당히 정형화 되어 있었는데, 향후 더 확장해서 활용할 가능성과 의도가 보였다.&lt;/p&gt;

&lt;p&gt;아니, 가능성과 의도가 보인 정도가 아니라 출시 버전에 넣기엔 너무 스펙이 크니 줄이자고 제안할 정도였다. 난 글자로 길게 설명하고 떠드는 걸 좋아하는데 박수영 대표는 나보다 더했다. 정말 온갖 정보를 고객에게 주고 싶어했다. 그 마음은 좋지만, 서비스 기획자 경험 상 우리만 힘들지 고객은 제대로 읽지 않을 가능성이 컸다. 박수영 대표 주변에서도 비슷한 피드백을 줬는지 알고리즘을 초기 기획에 비해 좀 더 압축하고(줄인 게 아니라 압축이다) 글자 양도 줄였는데, 여전히 내 기준으로는 너무 많았다. 너무 친절한데… 이것도 팀이 성장하는 과정이라 생각하고 더 잔소리(?)하지 않고 기획대로 구현하기로 했다.&lt;/p&gt;

&lt;p&gt;그런 점에서 Back-end 프로그래밍 언어로 &lt;a href=&quot;https://www.python.org&quot;&gt;Python&lt;/a&gt;이 적합했다. Python은 쉽고 실용적이며 생산성이 좋다. 생태계가 활발하여 좋은 도구도 많으며, 다양한 용도로도 사용할 수 있다. 특히 최근엔 데이터 처리나 분석에 적극 활용되고 있다. 그래서 쇼핑몰과 퀴즈 서비스를 만들기에도 적절하고, 퀴즈 알고리즘이 더 고도화되고 데이터가 많아졌을 때에도 유용하며, 데이터 욕심이 많고 고객이 원하면 재빨리 제공하고 싶어 몸이 달아오르는 박수영 대표의 요청에 대응하려면 쉽고 유연한 Python이 제격이었다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.djangoproject.com&quot;&gt;Django&lt;/a&gt;는 Python으로 웹 애플리케이션 서버를 개발할 때 많이 사용된다. 나는 Django의 여러 기능 중 Admin 기능을 무척 좋아하는데, Django Admin 기능을 이용하여 손쉽고 빠르게, 그리고 확장성 있게 서비스 관리 도구를 개발할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.facebook.com/hello.kaycha/photos/a.1543127105756752.1073741829.439007509502056/1542628302473299/&quot;&gt;&lt;img src=&quot;/assets/uploads/2018/01/django-admin-speech-on-djangogirls-seoul-2017.png&quot; alt=&quot;DjangoGirls Seoul 2017 11월 세미나에서 발표한 “날로 먹는 Django Admin 활용”&quot; /&gt;&lt;/a&gt;
&lt;a href=&quot;https://www.facebook.com/hello.kaycha/photos/a.1543127105756752.1073741829.439007509502056/1542628302473299/&quot;&gt;DjangoGirls Seoul 2017 11월 세미나에서 발표한 “날로 먹는 Django Admin 활용”&lt;/a&gt; 중에서&lt;/p&gt;

&lt;p&gt;서비스를 첫 출시할 때엔 관리 도구가 없더라도 당장 문제는 없다. 여차하면 개발자가 출동하여 해결해도 된다. 그러다보니 관리 도구 개발은 후순위로 밀리고 서비스 출시일까지 사용단 기능을 개발하는 데 일정을 맞추기 일쑤이다. 그래도 시간이 촉박하니 이해할 수 있긴 하지만, 달려야 할 때 관리 도구가 미비하여 발목을 잡을 우려가 있다. 서비스 사용량이 늘고 다뤄야 할 자료가 많아지면 협업과 분업이 중요하다. 잘 만든 서비스 관리 도구는 팀의 업무 효율을 높이고 안정성을 높이며, 팀에 필요한 정보를 유통하는 데 기여한다. 그래서 관리 도구를 제대로 준비해놓지 않으면 사업이 성장하느라 한창 바쁠 때 티도 안 나고 개발할 맛도 별로 없는 관리 도구 만드느라 개발팀이 병목이 되기 십상이다.&lt;/p&gt;

&lt;p&gt;물론 서비스 관리 도구를 고도화하는 건 한도 끝도 없다. 저기 앉아 있는 개발자에게서 여유가 느껴지면 막 이것 저것 추가하고 고쳐달라고 말하고 싶다. 하다 못해 차트라도 그려주거나 버튼이라도 예쁘게 해달라고 하고 싶지 않던가. 하지만 한정된 자원으로 높은 실행력을 내야 하는 스타트업은 적정선에서 끊어야 한다. 그 적정선 수준까지는 Django Admin으로도 충분히 빠르고 강력하게 만들 수 있다.&lt;/p&gt;

&lt;p&gt;이외 환경은 사용자가 많거나 자료가 많거나 개발 편의성이 좋은 점을 기준으로 선택했다.&lt;/p&gt;

&lt;h3 id=&quot;front-end&quot;&gt;Front-end&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Web browser : IE 9 이상&lt;/li&gt;
  &lt;li&gt;HTML 5, CSS 3, JavaScript(ECMA 6), Vue.js 2 + Webpack 2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Front-end 기술스택은 기준이 명확했다. 인터넷 익스플로러 8(IE 8) 이하 버전은 지원하지 않는다. 2017년에도 여전히 한국에선 IE 8 점유율을 쓰는 시대 저항 세력이 있지만, 한정된 자원으로 서비스를 개발해야 하는 스타트업의 현실적인 한계가 있었다. 그리고 서비스 이용자 중 모바일 사용자가 훨씬 많을 것이라 확신했다. 난 서비스 출시 버전에선 IE 8를 지원하지 않는 대신 좀 더 나은 기술로 고객의 서비스 사용 경험을 증대시키고 개발 효율을 높이자고 제안했고, 박수영 대표는 흔쾌히 수용했다. 실은 제발 IE 8은 지원하지 맙시다! 에 가까웠다. 😭&lt;/p&gt;

&lt;p&gt;소울부스터는 의류 쇼핑몰이라는 점과 박수영 대표의 성향을 고려 했을 때 사용단 UI 수정이 많을 거라 예상했다. 실제로 매우 많았다. 그래서 현대 UI 프로그래밍에 적합한 도구가 필요했는데, 지금이나 그 당시나 React.js, Angular가 주요 축이다. 난 React.js와 Angular의 장점을 제공하면서도 학습과 활용이 상대적으로 쉬운 &lt;a href=&quot;https://vue.js&quot;&gt;Vue.js&lt;/a&gt;를 선택했다. React.js와 Angular에 비해서는 사용자 층이나 생태계가 크진 않았지만, 빠르게 성장하고 있었고 사용하기 쉬웠으며, 무엇보다도 친절하고 다정한 한국어 자료가 잘 정리되어 있었다. React.js나 Angular 숙련자를 영입하기 쉽지 않다면 구인한 Front-end개발자가 학습해서라도 활용할 상황을 염두에 뒀다. React.js나 Agnular 경험자라면 어렵지 않게 Vue.js를 사용할 수 있으며, 이 셋과 관련된 기술을 모르더라도 Vue.js는  React.js나 Angular에 비해 쉽게 입문할 수 있다고 판단했다. 왜냐하면 내가 그랬으니까.&lt;/p&gt;

&lt;p&gt;시행착오는 있었지만, Vue.js는 만족스러웠다. 부분적으로 그리고 보수적으로 도입했는데, 기술 스택이 너무 복잡해지지 않으면서도 개발 효율이 상승했으며 성능과 기능도 만족스러웠다. 그리고 반짝 두각을 드러내다 사라지지 않고 빠르게 점유율이 늘어서 Vue.js 경험자도 빠르게 늘고 있어서 면접 자리에서 Vue.js를 사용해봤거나 학습 중인 개발자를 만나는 빈도도 늘고 있다.&lt;/p&gt;

&lt;h3 id=&quot;기타&quot;&gt;기타&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Slack/Jandi&lt;/li&gt;
  &lt;li&gt;Trello&lt;/li&gt;
  &lt;li&gt;Bitbucket&lt;/li&gt;
  &lt;li&gt;MailChimp&lt;/li&gt;
  &lt;li&gt;아임포트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;나는 주로 원격 근무를 한다. 제품이나 서비스를 운영하고 있거나 개발 총괄자가 있는 프로젝트에서 원격 근무는 해봤지만, 프로젝트 시작부터 원격 근무를 해본 적은 없었다. 프로젝트 초기엔 팀과 소통을 많이 하기 때문에 다소 걱정이 들었다. 하지만 소프트웨어 개발자는 나 한 명이니 개발 관련하여 얼굴 맞대고 논의하는 일은 바보같은 코드를 짠 3일 전의 나를 오늘의 내가 구박하는 그런 경우가 대부분이었다. 그래서 일주일에 1~2회 정도 사무실에 출근하고, 소통 채널을 적극 활용하여 원격 근무를 해도 협업에 큰 지장이 없도록 노력했다.&lt;/p&gt;

&lt;p&gt;이슈 빈도가 빈번하지 않거나 외부 상황에 의존하는 일이 일정할 땐 원격 근무가 별 문제는 없었다. 물론 비동기로 소통을 나누기 때문에 동기식 소통에 익숙한 사람에겐 불편할 수도 있다. 다행히 박수영 대표는 팀에 엄청 많은 일을 할당했고, 동기식으로 협업해서는 도저히 일정을 맞출 수 없었다. 각자 알아서 업무 맥락(context)을 관리하며 비동기로 업무를 해치워야 했고, 뜻하지 않게 비동기식 협업이 동작했다. 😂&lt;/p&gt;

&lt;p&gt;나는 온라인 협업 도구 사용으로 비동기로 협업하더라도 효율이 떨어지지 않게 유도하려고 노력했다. 그렇다고 엄격하게 도구 사용 규칙을 정하거나 강제하지 않았다. 핵심 원칙을 하나 정하고, 그 원칙을 지키도록 유도했다. 그 원칙이란 바로 공개와 개방이다. 되도록이면 &lt;a href=&quot;https://trello.com&quot;&gt;Trello&lt;/a&gt;와 &lt;a href=&quot;https://slack.com&quot;&gt;Slack&lt;/a&gt;/&lt;a href=&quot;https://www.jandi.com&quot;&gt;Jandi&lt;/a&gt;를 사용하여 이슈를 팀 내에서는 누구나 확인할 수 있게 공개했다. Slack/Jandi나 email, Trello 어디에도 기록이 남지 않은 업무 요청을 가끔 반려하기도 했다.&lt;/p&gt;

&lt;p&gt;박수영 대표는 서비스 기획자 역할도 하고 있었으므로 사소한 이슈라도 거의 모든 email에 참조자에 참여시켰다. 그래도 정보 불일치 상황을 피하고자 출근할 땐 진행 상황과 주요 이슈를 동기화했다. 몇 가지 아쉬운 점은 있지만, 아직 출시하지 않은 제품이나 서비스를 개발하는 단계에서도 원격 근무가 동작할 수 있는 가능성을 발견하기도 했고, 해결해야 할 문제도 발견했다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://iamport.kr&quot;&gt;아임포트&lt;/a&gt;는 결제 대행(Payment Gateway) 서비스 연동을 대신해주는 중개 서비스이다. 대행을 대신한다니 뭔가 복잡하게 보이는데, 아임포트를 사용하면 번거롭고 짜증나는 PG연동 작업을 아주 간편하게 해치울 수 있다. 게다가 PG를 하나만 연동할 경우 무료이며, 복수 개 PG를 연동하더라도 한 번만 결제하면 되므로 사용하지 않을 이유가 없었다. 게다가 아임포트는 결제 기능 구현 일정에 영향을 미치는 외부 의존도를 상당히 낮춰줬다. 외부 의존도가 높은 이슈가 많을수록 일정 추정이 어려워지고 팀 스트레스를 높이기 때문에 우린 아임포트에게 많은 도움을 받은 셈이다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mailchimp.com&quot;&gt;MailChimp&lt;/a&gt;는 Non-paid 마케팅 채널 중 하나인 email 마케팅을 하는 데 매우 유용하다. 개발자의 지원이 없이도 email 마케팅을 수행하고 운영하는 데 필요한 기술 요소를 활용할 수 있으며, MailChimp가 머신러닝으로 최적화하여 제안하는 여러 가설과 실행 방법은 비숙련자의 가설과 계획보다 나은 경우가 많다. 그래서 email 마케팅에 필요한 기술 지원에 내가 손을 쓸 일은 없었으며, 회원가입, 주문 안내 등 안내 email을 발송하는 용도로 MailChimp의 서비스 중 하나인 Mandrill사용했다.&lt;/p&gt;

&lt;h2 id=&quot;3-소프트웨어-개발팀-구축&quot;&gt;3. 소프트웨어 개발팀 구축&lt;/h2&gt;
&lt;p&gt;소프트웨어 개발을 해본 적이 없거나 모르는 창업자는 어떤 분야 개발자가 팀에 필요한 지, 경력은 어느 정도여야 하는 지, 어떤 사람이어야 하고, 어떤 기술을 다룰 줄 알아야 하는 지 궁금해하곤 한다. 모두 챙겨야 할 요건이긴 하다. 하지만 전제해야 할 것이 두 가지 있다. 스타트업 팀 구축(building)을 주제로 강연할 때 마다 일관된게 주장하는 내용이기도 하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;창업자가 해결하고자 하는 문제를 풀고 싶어 하는 사람이어야 한다.&lt;/li&gt;
  &lt;li&gt;회사와 함께 성장하는 지속 가능한 팀을 함께 만들어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;많은 창업자가 개발팀이 필요하다고 하지만 대화를 나눠보면 실제로는 개발팀이 목표가 아니라 제품이나 서비스가 목표인 경우가 많다. 사업의 목적과 목표가 소프트웨어 개발이 아니라면 틀린 생각은 아니지만, 개발팀이 필요한 것과 개발팀이 만들어낼 결과물이 필요한 것은 구분해야 한다. 후자라면 꼭 내부 개발팀을 고집할 필요가 없다. 오히려 내부 개발팀을 구축해서 실행력이 더뎌지거나 품질 낮은 제품을 만들기도 하고, 적지 않은 돈과 시간과 정신 에너지를 쓰고 개발팀을 해체하는 경우가 무척 많다.&lt;/p&gt;

&lt;p&gt;개발팀과 함께 창업의 이유(why)를 함께 고민하고, 그 문제를 풀 방법을(how) 모색하여 고객에게 적합한 제품이나 서비스(what)가 나와야 한다. 그래서 개발자 개개인은 전문 기술 분야를 갖고 있더라도 팀은 문제를 해결하는 데 필요한 기술 스택을 어떻게든 소화할 수(풀스택) 있어야 한다. 풀스택이라 함은 능력이나 경력이 될 수도 있지만 더 중요한 건 문제를 풀겠다는 태도(마음)이다.&lt;/p&gt;

&lt;p&gt;그런 점에서 소울부스터는 개발자 영입이 쉽진 않았다. 아무래도 여성 맞춤 속옷 사업 아이템에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;여성&lt;/code&gt;이 큰 인상을 끼치고, 적어도 내 지인이나 인터뷰를 본 남성 개발자 중에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;여성&lt;/code&gt; 속옷과 관련된 주제에 문제를 고민하는 경우는 없었다. 그래서 인터뷰를 볼 때 소울부스터가 해결하고자 하는 문제는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;맞춤&lt;/code&gt;이라는 것에 초점을 두고자 했다. 박수영 대표가 내게 들려준 비전과 창업 이유를 최대한 기술과 개발로 풀어서 전달하려 노력했다.&lt;/p&gt;

&lt;p&gt;인터뷰 볼 때 중요시 여긴 또다른 요소는 서비스 운영 경험이었다. 박수영 대표는 실행력이 좋고, 또 성격도 급한 편이다. 필요하거나 중요한 일이면 설령 그게 하기 싫거나 까다로운 일이라도 망설이지 않고 기꺼이 직접 실행하는 사람이다. 이런 대표자의 실행력은 서비스를 운영하여 사업 실적이 바로 바로 발생하는 실 운영 환경에서 개발자에게 압박과 부담으로 작용한다. 그런 상황에 일정 기간 노출된 경험이 필요했다.&lt;/p&gt;

&lt;p&gt;개발팀의 중요 고객 중 하나인 내부 고객, 그러니까 개발팀이 만든 도구를 사용하는 비개발팀 동료을 위한 관리 도구를 고도화하는 업무도 지루하고 재미없는 경우가 많다. 잘 드러나지 않는달까? 그래서 새로운 제품이나 기능을 만드는 건 좋아하지만 서비스 운영에 필요한 개발 업무는 싫어하는 개발자도 있다. 먹고 살아야 하니 일은 하지만 발휘하는 집중력에 차이가 크면 개발자 개인과 개발팀 혹은 회사 모두 불행한 상황에 놓인 것이나 마찬가지이다. 인내할 줄 알아야 한다. 더 나아가 그런 환경에서도 같은 문제에 대해서 더 나은 해결책을 모색하는 호기심을 유지하고 실행하는 체력과 자기 관리를 할 수 있어야 한다. 그걸 넘어서 아예 서비스 운영 개발을 좋아하면 더 좋고.&lt;/p&gt;

&lt;p&gt;박수영 대표에게 이런 생각을 피력했고, 이럴 경우 생각보다 개발팀 구축에 시간이 오래 걸릴 수 있다는 걸 일러두었다. 그 생각보다 오래 걸린 시간이 그 생각보다 더 오래 걸리긴 했지만, 마침내 Front-end와 Back-end 각 한 명씩 구인하는 데 성공했다.&lt;/p&gt;

&lt;p&gt;서비스를 출시한 이후 한결 개발자 구인 기회가 많아졌다. 출시 전에는 아무리 잘 설명해봐야 실제로 동작하는 눈에 보이는 실체가 없으니 회사 정체성은 여성 속옷 쇼핑몰에 그쳤다. 소울부스터에서 고심 끝에 만들고 계속 진보하는 체형 진단 퀴즈 알고리즘이 고객에게 어떤 가치를 주는 지 입사 지원자에게 확신시키기 어려웠다. 하지만 서비스를 출시하고 직접 공장에서 제조한 제품을 고객에게 팔고, 퀴즈 알고리즘을 사용하는 고객 경험과 고객 응대 경험이 쌓이자 팀의 정체성은 더 뚜렷해졌다. 나는 그런 점들이 어우러져 입사 지원 수도 늘고 회사의 비전을 미리 살펴보고 관심있는 사람이 지원하는 빈도가 늘었다고 생각한다.&lt;/p&gt;

&lt;h2 id=&quot;마무리&quot;&gt;마무리&lt;/h2&gt;
&lt;p&gt;함께 프로젝트를 하기로 한 지 만 1년이 됐다. 나는 시간 당 비용을 청구했는데, 서비스 안정화 이후 내가 프로젝트에 들이는 시간이 확 줄었고 그만큼 내 수입도 (무척) 줄었다 😔. 그렇다. 박수영 대표와 함께 정한 우리의 목표에 도달한 것이다. 개발팀을 구축했고, 회사와 팀은 성장하고 매출도 상승하며 연 이륙을 시작하고 있었다.&lt;/p&gt;

&lt;p&gt;얼마 전 우리는 계약을 공식 종료했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2018/01/soulbooster-product-unboxing.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;소울부스터 팀은 여전히 실행력을 유지하고 있고, 제품에 만족하는 고객도 계속 늘고 있는 것 같다. 직접 돈 주고 제품을 산 내 아내도 소울부스터 제품에 만족하고 있다. 그래서 두 번 샀다. 난 프로젝트를 개시하여 출시하고, 운영하며 안정화하고, 개발팀 구축도 함께 하며 작지만 야무지고 단단하게 성장하는 팀을 곁에서 보았기에 여러모로 소울부스터에 정이 간다. 소울부스터의 성공을 기원하며 개발 후기를 마쳐본다.&lt;/p&gt;

&lt;p&gt;아참, 소울부스터에서 시니어 개발자를 충원하고 있다고 한다. 소프트웨어적 상상력을 발휘하기 좋은 사업 아이템이자 사업 비전이라 생각한다. 관심있는 개발자는 recruit@soulbooster.co.kr 로 문을 두드려 보길 추천해 본다. 추천인 코드는 hannal (농담). 아니면 내게 자리를 마련해달라고 연락을 해도 좋다. 위에 명기된 기술 스택을 경험했다면 좋겠지만, 그렇지 않더라도 서로 적합하다면 문제 될 것 없다. 문제가 안 된다는 건 현 소울부스터 개발팀이 살아있는 사례라서 말할 수 있다.&lt;/p&gt;

&lt;p&gt;One more thing. 소울부스터처럼 서비스 개발부터 개발팀 구축, 운영까지, 혹은 프로젝트를 의뢰나 문의하실 분은 kay@hannal.net 으로 문의하세요. 😍&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;2018년 1월 12일 추가 : 소울부스터에서는 샘 방지 위생 팬티인 시즈더데이를 전문으로 취급하는 쇼핑몰인 &lt;a href=&quot;http://www.seizetheday.co.kr/&quot;&gt;시즈더데이&lt;/a&gt;를 2017년 12월에 출시했다. 팬티 제품은 브레지어와 달리 가슴 체형 진단을 하지 않아도 되고, 회원가입을 하지 않아도 손쉽게 주문할 수 있도록 별도 쇼핑몰을 구축한 것인데, 흥미로운 점은 쇼핑몰 호스팅 서비스를 사용한 점이다. 개발팀을 보유한 회사의 대표가 이런 판단을 실제로 실행하는 게 생각보다 쉽지 않다. 정말 사업 측면에서 놀라운 실행력이다. 개발자로서 이런 사업 실행력과 판단에 박수를 보내본다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>일하는 방식 고민.</title>
    <link href="/2018/01/thinking-of-how-to-work/"/>
    <updated>2018-01-06T10:00:00+09:00</updated>
    <id>/2018/01/thinking_of_how_to_work</id>
    <content type="html">&lt;p&gt;난 하루에 집중해서 6~8시간, 일주일에 3~4일만 일하는 게 좋을 것 같다.&lt;/p&gt;

&lt;p&gt;딴짓하지 않고 자신을 몽땅 짜낼만큼 높은 집중력을 내면서 항상성을 유지할 수 있는 하루 최대 근무 시간은 6시간이 최대치인 것 같다. 8시간도 큰 부담은 없는데, 사람이 언제나 전력 질주하듯 집중력을 발휘할 수 있는 건 아니니 기준은 하루 6시간 집중하는 데 맞추고 좀 여유를 내고 싶은 날은 8시간 일하면 될 것 같다.&lt;/p&gt;

&lt;p&gt;자신을 짜내듯 일하면 업무 탈진한다. 탈진했다고 퇴사해서 충전하는 건 업무 맥락, 팀웍 구축 비용이 너무 아깝다. 그러므로 평소에(?) 일하듯이 평소에 공부하고 경험하며 충전해야 한다. 나는 느리고 시간을 많이 투입해야 해서 하루에 3시간은 학습에 쓰고, 일주일에 하루 정도는 온전히 경험성 활동에 써야 하는 것 같다. 이것도 멍하니 읽고 감상하는 게 아니라 의식하고 의도한 활동으로 해야 한다. 안 그러면 남는 게 없는 것 같다.&lt;/p&gt;

&lt;p&gt;주 중에 일과 학습에 집중해서 달리려면 그 주를 회고하고 다음 주를 계획하는 데 하루 정도는 써야 한다. 물론 노는 것도 포함해서. 그리고 온전히 쉬는 날은 최소 하루 보장하고.&lt;/p&gt;

&lt;p&gt;이렇게 해서 먹고 살 수 있을까? 일주일에 100시간씩 일해야 성공할 기회가 생긴다고 한다. 성공하거나 시간과 자본에서 어느 정도 자유를 얻은 지인을 보면 그런 것 같다. 물론 죽도록 일해서 결국 죽거나 동력을 잃거나 실패하는 사람은 있다. 그런데 느슨하게(?) 일해서 성공한 경우는 적어도 내 주변엔 없고, 사회에 알려진 사례도 못본 것 같다.&lt;/p&gt;

&lt;p&gt;실은 나 혼자라면 그런 삶에 곧 도달할 것 같다. 문제는 언제까지 지속할 수 있느냐이다. 1~2년이 아니라 5년, 10년, 20년 이후에도 이렇게 일해서 먹고 살 수 있을까? 자본 소득이 뒷받쳐주지 않는 현 상황에서는 낙관하지 못한다.&lt;/p&gt;

&lt;p&gt;나 혼자가 아니라 팀이라면 장기 지속할 가능성이 클 것 같다. 한 사람이 하는 일을 두 사람이 하면 된다. 팀 복잡도가 올라가서 발생하는 누수를 감안하면 두 사람이 소화하는 것보다 한 사람이 하는 게 더 나을지도 모른다. 하지만 예측 가능한 일정과 높은 질을 꾸준하게 내려면 한 사람이 하는 일을 두 사람이 하루 6~8시간, 주 3~4일 근무하며 처리해야 가능할 것 같다. 물론 팀원의 프로 의식과 그런 문화를 지키고 발전시키려는 태도와 마음을 서로 강하게 믿어야 가능하다. 결국 누구와 함께 하느냐가 가장 중요한 문제이다.&lt;/p&gt;

&lt;p&gt;그렇다고 같은 일을 많은 사람이 한 팀으로 모이는 건 아니다. 오히려 일을 쪼개고 쪼갠 일에 대해 온전히 위임하고 권한을 발휘하도록 하여 개개인 간 의존성을 낮춰야 한다. 팀은 다른 조직에 비해 오히려 큰데 일은 다른 조직보다 더 원자화 되어 동작하는 그런 조직을 어떻게 만들어야 할 지 아직은 잘 모르겠다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Django 템플릿에서 VariableDoesNotExist 예외 오류 대응하기</title>
    <link href="/2017/06/django-template-variabledoesnotexist-exception/"/>
    <updated>2017-06-26T00:00:00+09:00</updated>
    <id>/2017/06/django_template_variabledoesnotexist</id>
    <content type="html">&lt;p&gt;한 줄 요약 : Django 템플릿 엔진은 템플릿 필터에 대해서 항상 조용한 실패 처리(silent failure)를 하진 않는다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Django Template은 없는 템플릿 변수나 템플릿 변수의 속성, 키, 색인이 없어도 오류 상황을 일으키지 않고 조용히 오류 상황을 잠재운다. 일명 Silent failure 동작이다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{{ lorem.ipsum.hello.world }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lorem&lt;/code&gt;이라는 템플릿 변수가 없든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lorem&lt;/code&gt; 템플릿 변수는 있는데 이 객체에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ipsum&lt;/code&gt;이라는 키나 속성이 없다고 가정하자. 최종 템플릿 맥락이 출력(치환)이면 Django는 변수나 키, 속성이 없다는 오류 상황을 일으키지 않으며, 저 템플릿 변수 위치엔 아무것도 출력되지 않는다. 템플릿 변수를 출력(render)하거나 템플릿 태그에서 사용할 때는 이처럼 Silent failure로 동작한다.&lt;/p&gt;

&lt;p&gt;하지만 템플릿 필터를 거치는 경우엔 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VariableDoesNotExist&lt;/code&gt; 예외(exception)가 발생한다. 예외 이름에서 드러나듯이 템플릿 변수가 없다는 뜻이다.&lt;/p&gt;

&lt;p&gt;예를 들어, 존재하지 않는 템플릿 변수인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;not_exist_var&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;divisibleby&lt;/code&gt; 템플릿 필터에 사용하면 예외 오류가 발생한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{{ &apos;1234&apos;|divisibleby:not_exist_var }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이에 대해 Django 공식 문서에서는 다음과 같이 설명한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thus, filter functions should avoid raising exceptions if there is a reasonable fallback value to return. In case of input that represents a clear bug in a template, raising an exception may still be better than silent failure which hides the bug. ( 출처 : &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/howto/custom-template-tags/#writing-custom-template-filters&quot;&gt;custom-template-tags - writing-custom-template-filter&lt;/a&gt; )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;간단히 말해서 템플릿 필터 함수에서는 버그를 숨기는 Silent failure 보다는 예외를 일으키는 게 낫다고 한다. 실제로 Django 내장 템플릿 필터를 보면 대체물을 대신 반환해도 될 만한 경우엔 Exception 처리를 잡아내서 오류 상황을 피하지만, 그 외의 경우엔 Exception이 발생하게 냅둔다. 문제는 그 정책이 예상을 벗어나는 경우에 발생한다. 난 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt; 템플릿 필터에서 조용한 실패 처리를 하지 않는 상황을 만났다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt; 템플릿 필터는 대개 다음과 같이 사용한다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{{ empty_var|default:&apos;비었수다&apos; }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;나도 비슷하게 사용했다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{{ apple.attr3|default:lemon.attrdict.color }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django 템플릿 엔진 동작에 익숙하다면 다음과 같이 동작하길 기대(예상)한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apple.attr3&lt;/code&gt;가 없으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lemon.attrdict[&apos;color&apos;]&lt;/code&gt;를 대신 출력&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lemon.attrdict&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;color&lt;/code&gt; 키가 없으면 결국 아무것도 출력하지 않고 Silent failure.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;딱히 Exception이 발생할만한 로직이 아니고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt; 필터 함수를 봐도 인자 두 개 받아서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return value or arg&lt;/code&gt;로 동작하는 것 뿐이다. 다시 말해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt; 템플릿 필터인 Python 함수는 두 개 인자를 받는데, 첫 번째 인자로 받는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;|&lt;/code&gt; 앞에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apple.attr3&lt;/code&gt;가 있으면 해당 객체를 반환하고, 없으면 두 번째 인자로 받는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:&lt;/code&gt; 뒤에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lemon.attrdict.color&lt;/code&gt;를 반환한다.&lt;/p&gt;

&lt;p&gt;하지만 실제로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;VariableDoesNotExist&lt;/code&gt; 예외 오류가 발생한다. 이 예외는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; 템플릿 태그로 해결하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://gist.github.com/hannal/9de33b54a749457d7f29c5f30c5e9136&quot;&gt;with 템플릿 태그로 VariableDoesNotExist 예방&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; 템플릿 태그는 Silent failure 처리를 해주니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; 템플릿 태그로 만든 임시 템플릿 변수인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;colour&lt;/code&gt;엔 출력할(render) 게 없는 빈 객체가 할당이 된다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;with&lt;/code&gt; 템플릿 태그를 안 쓴 경우엔 Silent failure를 해주는 놈이 없다보니 Exception이 그대로 나버린 것이다. 이 문제가 까다로운 이유는 Django 디버깅 화면에서는 문제가 있는 템플릿 줄(line)을 가리키지 않고 Exception이 발생한 Django 소스를 보여주는 데 있다. 평범한 속성명이나 키 이름을 쓰다가는 고생하기 십상이다.&lt;/p&gt;

&lt;p&gt;흔히 겪는 상황은 아닐 것 같다. 나는 모델에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSONField&lt;/code&gt;를 썼고, 이 모델필드의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dict&lt;/code&gt; 객체에 특정 키(위 예제 기준으로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;colour&lt;/code&gt;키)가 없어서 발생한 거였다. 뷰 함수에서 넘겨주는 템플릿 변수 이름대로라면 금방 발견했을 것 같다.&lt;/p&gt;

&lt;p&gt;삼천포 요약 : 변수 네이밍을 괴랄하게 하면 디버깅에 도움이 된다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>시트로엥 C4 칵투스 두 달 소감.</title>
    <link href="/2016/11/citroen-c4-cactus/"/>
    <updated>2016-11-28T11:00:00+09:00</updated>
    <id>/2016/11/citroen-c4-cactus</id>
    <content type="html">&lt;p&gt;올해 한국에 출시한 시트로엥 C4 칵투스를 샀다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;운행 기간 : 두 달&lt;/li&gt;
  &lt;li&gt;운행 거리 : 약 1,600km&lt;/li&gt;
  &lt;li&gt;평균 연비 : 리터 당 18~19km&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;총평&quot;&gt;총평&lt;/h3&gt;

&lt;p&gt;재밌는 차다. 개성이 강해서 호불호가 극명하게 갈릴 것 같다. 난 선호에 가깝다. 점수를 매기자면 5점 만점에 4점. 30대 3~4인 가정에 추천한다.&lt;/p&gt;

&lt;h3 id=&quot;특성&quot;&gt;특성&lt;/h3&gt;

&lt;h4 id=&quot;1-연비&quot;&gt;1. 연비&lt;/h4&gt;

&lt;p&gt;도심 내 평속 40~60km 정도일 때 연비는 리터 당 17~18km정도로 측정된다. 고속도로 타서 평속 80~90km로 달리면 연비는 22~25km까지 찍는다. 2016년 11월 기준으로 서울 시내 버스 요금이 기본 요금 1,200원에 10km 초과 시 5km 마다 100원씩 가산되고 경유가 리터 당 대략 1,200~1,300원이니까 연비만 놓고 보면 버스 요금보다 저렴하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2016/11/c4-cactus-fuel-efficient.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연비 효율을 높이려는 노력이 곳곳에서 보인다. 먼저 차가 멈추면 엔진을 껐다가 출발할 때 다시 켜는 기능을 들 수 있다. 차량 동작을 완전히 끈 게 아니라 엔진만 끄고, 제동 페달에 발을 떼는 순간 빠르게 다시 시동을 건다. 반응성이 좋아서 불편하진 않다. 하루에 두세 시간 정도 운전하면 에코 유지 시간이 몇 십 분 정도 된다. 몇 십 분 주행을 안 한 셈이니 꽤 연류를 아낀 것이다.&lt;/p&gt;

&lt;h4 id=&quot;2-디자인&quot;&gt;2. 디자인&lt;/h4&gt;

&lt;p&gt;눈에 띄는 디자인이다. 선이 또렷하고 야무지게 생겼다. 특히 얼굴이 재밌게 생겨서 사람들이 흘깃 눈길 한 번씩은 보낸다. (｀^´) 이렇게 생겼달까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2016/11/c4-cactus-front.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자동차 외관에 플라스틱류 소재가 이렇게 많이 사용된 건 처음 본다. 그 유명한(?) 옆면 에어범퍼도 그렇고, 차 전면부나 후면부 곳곳에도 다소 말랑한 플라스틱 소재가 붙어 있다. 좋고 나쁘고를 떠나서 특이하긴 하다. 색깔도 다양하고 강렬한데, 외형이 워낙 특이해서 난 무난하게 흰색을 골랐다. 흰색이 예쁘다.&lt;/p&gt;

&lt;p&gt;내부 인테리어도 아늑하고 귀여운 편이다.&lt;/p&gt;

&lt;h4 id=&quot;3-공간-크기&quot;&gt;3. 공간, 크기&lt;/h4&gt;

&lt;p&gt;차체는 작은 편이다. 키나 덩치가 큰 사람에겐 다소 좁게 느껴질 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2016/11/c4-cactus-size.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 안쪽 공간은 생각보다 여유롭다. 넓다기 보다는 여유감이 있어 답답하지 않다는 뜻이다. 앞좌석은 자잘한 조작 장치를 버튼식으로 바꾸고 대시보드 디스플레이에 몰아 넣어서 변속 레버 부근 공간이 여유롭다. 보조석은 에어백을 상단으로 옮기고, 앞쪽 가방식 수납 공간에 소지품을 넣을 수 있다.&lt;/p&gt;

&lt;p&gt;뒷좌석은 다소 좁게 느껴질 여지가 있는데, 자잘한 장치를 쳐내서 공간이 깔끔하고(휑하고) 전방과 상향 시야가 탁 트여서 심리상 편안함을 준다. 하지만 키가 큰 사람이 앉기엔 좁은 건 어쩔 수 없다. 뒷좌석엔 isofix 방식인 유아 카시트를 두 대 장착할 수 있으며, 고리 구멍이 표시되어 있어 연결하기 쉽다. 카시트 두 개 놓으면 뒷좌석은 사실상 공간이 남지 않는다.&lt;/p&gt;

&lt;p&gt;트렁크는 생활 물품을 담고 다니기 괜찮은 정도이며 넓은 편은 아니다. 나는 유모차, 자동차 용품 등을 넣고 다니는데, 장 본 물품을 상자 하나에 담아서 트렁크에 담을 정도는 된다. 유모차를 넣고 다니기엔 괜찮지만, 유모차를 싣고 장을 많이 본 날엔 좁다.&lt;/p&gt;

&lt;p&gt;뒷좌석 창문은 바깥쪽으로 살짝 열린다. 싫어하는 사람이 꽤 있을 것 같은데, 난 오히려 마음에 든다. 뒷좌석엔 유아 카시트 장착하고 꼬맹이를 앉히기 때문에 아예 꼬맹이가 활짝 열지 못하는 게 마음 편하다. 아이가 타지 않을 때에는 대부분 나 혼자 차를 타거나 동승자 한 명이 보조석에 앉기 때문에 뒷좌석 창문 열 일이 없다. 뒷좌석 창문이 아래로 열리지 않아서 뒷좌석 문짝 안쪽의 수납 공간이 넓다. 어느 정도로 넓냐면 하루 외출하는 데 쓸 아이 기저귀, 소형 우유팩, 간식통을 담을 수 있다. 아이가 용변을 봐서 돌돌 만 기저귀 서너 개는 넉넉히 들어간다.&lt;/p&gt;

&lt;h4 id=&quot;4-에어범퍼&quot;&gt;4. 에어범퍼&lt;/h4&gt;

&lt;p&gt;예쁜 외관에 눈에 띄게 전혀 다른 재질로 된 에어범퍼가 차 옆면에 꽤 넓게 자리잡고 있다. 내 차는 흰색이고 에어범퍼는 검정색인데, 흰색 몸체는 유광이고 에어범퍼는 무광이라 더 이질감이 크다. 딱 문콕 당할 위치에 에어범퍼가 있어서 문콕 스트레스가 거의 사라진다. 실제로 문콕을 몇 번 당한 것 같은데, 에어범퍼와 바퀴 부근 플라스틱류 소재에 찍힌 자국이 생겼더라. 차체 철판 면은 깨끗하고.&lt;/p&gt;

&lt;p&gt;차 옆면이 어딘가에 닿을 때 가장 먼저 에어범퍼가 닿아서 차체 흠집에 대응할 여지가 있다. 좁은 공간을 우회전하며 들어가다 차 오른쪽 부위가 입구 기둥에 닿는 사고(?)가 발생한 적이 있다. 차체가 뭔가에 닿는 느낌이 들자마자 더 진입하지 않고 후진해서 차를 뺐는데, 에어범퍼가 닿아서 차체엔 아무런 흠집이 생기지 않았다. 에어범퍼가 없었다면 흠집이 생겼거나 최악의 경우 찌그러졌을 것이다.&lt;/p&gt;

&lt;h4 id=&quot;5-편의-기능&quot;&gt;5. 편의 기능&lt;/h4&gt;

&lt;p&gt;크루즈 기능을 처음 써봤는데 설명으로 들었을 때보다 편했다. 일정 속도로 꾸준히 달리는 장거리 이동 중에 무척 유용했지만, 피곤한 운전 상황은 도심 운전인데 도심 안에서는 쓸모가 없어서 아쉬웠다. 크루즈 기능을 쓰면서 자동운전 기능을 더 기대하게 됐다. 다음 차는 자동운전 기능이 있는 걸로 사야겠다.&lt;/p&gt;

&lt;p&gt;주유구는 차 열쇠로 열어야 한다. 실내에서 원격으로 열지 못한다. 이건 호불호가 갈리지 않을 것 같다. 매우 불편하다. 열쇠를 빼서 주유원에게 주면 시동이 꺼졌으므로 창문을 닫지 못한다. 그래서 직접 주유하는 셀프 주유소를 이용하는 편인데, 그래도 싫다.&lt;/p&gt;

&lt;p&gt;하드웨어 조작 장치가 몇 개 없다. 대부분 대시보드에 터치 방식으로 옮겨 넣었다. 그래서 공간이 여유로운데, 날씨가 추워지면 터치를 제대로 인식 못하는 경우가 있다. 운전 중엔 가능한 다른 조작을 해서는 안 되긴 하지만 그래도 운전 중에 냉난방을 조절하는 등 뭔가를 조작하는 경우가 왕왕 있는데, 화면 터치로 해야해서 불편한 경우가 생기곤 한다.&lt;/p&gt;

&lt;p&gt;변속 관련 하드웨어 조작 장치도 마찬가지여서 변속 막대가 아예 없다. 대신 운전(D), 후진(R), 정차(N) 변속 제어를 큼직한 버튼 세 개가 맡는다. 발렛 파킹하는 사람들이 당황하곤 한다.&lt;/p&gt;

&lt;p&gt;벤치식 좌석과 패브릭 시트(?)가 꽤 편안하다. 몸이 푹 잠기는 편안함은 아니고 배기는 부위 없이 안정된 편안함이다.&lt;/p&gt;

&lt;p&gt;창문을 세척할 때 분무액은 와이퍼에서 직접 분사하는 방식인데, 세척액이 시야를 가리는 시간이 매우 짧다. 처음엔 세척액이 제대로 분무되지 않은 줄 알 정도이다.&lt;/p&gt;

&lt;p&gt;Apple Carplay 기능이나 Android Auto 기능을 지원하지 않는다. 아쉽다.&lt;/p&gt;

&lt;h4 id=&quot;6-주행&quot;&gt;6. 주행&lt;/h4&gt;

&lt;p&gt;내가 좋아하는 소리를 내진 않는다. 난 조용하고 얌전한 차를 좋아하며, 다소 묵직한 운전감을 선호한다. 이 차는 가볍다. 차체가 가벼운 편이기도 하지만, 엔진 소리나 운전감이 좋게 말하면 경쾌하고 나쁘게 말하면 가볍다. 차가 가볍다보니 고속 주행 시 바닥에서 올라오는 진동과 소리가 크다. 더욱이 정차 시 에코 상태로 전환되어 엔진이 꺼져서 아주 조용한 상황을 경험하게 되기 때문에 더 비교된다.&lt;/p&gt;

&lt;p&gt;완전 자동 변속 장치가 아니고, 수동 변속을 기반으로 자동 변속을 해주는 변속 방식이다. 연비는 좋은데, 변속될 때 차가 꿀렁거리는 수동 변속의 단점을 안고 있다. 잘 운전하면(?) 꿀렁거림을 줄일 수 있지만, 변속 중 꿀렁거리는 상황을 피하기 힘든 경우도 있다. 1단으로 오르막길 오르는데 RPM이 상승해서 2단으로 바뀌면 순간 꿀렁, 그런데 곧 힘이 부쳐서 다시 1단으로 바뀌면 또 꿀렁. 고속도로에서 6단으로 달리던 중 추월하려고 가속 페달을 밟으면 RPM이 부족해서 5단으로 변속되어 꿀렁, 근데 평지라서 금방 RPM이 진정되면 다시 6단으로 바뀌어서 또 꿀렁. 수동 변속 차량을 오래 운전해서 수동 변속을 좋아하는데도 이 변속 패턴은 짜증나곤 한다.&lt;/p&gt;

&lt;p&gt;보기보다 힘이 괜찮다. 수동 변속 특유의 RPM 장난질로 튀어나가는 힘도 제법이고, 시속 130km까지는 뻗어나가는 힘도 괜찮다. 근데 고속 주행에 적합한 차는 아니긴 하다.&lt;/p&gt;

&lt;p&gt;방향 전환과 제동하는 느낌도 묵직해서 밀리지 않아 안전감 있다. 급곡선을 돌 때는 차 중안 부근이, 급제동을 걸 때는 차 엉덩이 부근이 땅으로 꾹 눌리는 느낌이 든달까? 주행감은 상당히 가벼워서 과속 방지턱도 퉁퉁 튀듯 넘는 기분이 드는데, 방향 전환과 제동은 묵직해서 비교되어 재밌다. 상대적으로 묵직한 게 아니라 정말 묵직하다. 새 차라 그런가? 마음에 든다.&lt;/p&gt;

&lt;p&gt;사람은 자신의 몸이 움직이는 공간을 인지하고 있다. 부딪히지 않고 좁은 틈을 지나갈 수 있는지, 줄넘기를 하는 저 사람과 어느 정도 떨어져야 안전한지 무의식 중에 파악한다. 운전석에 앉으면 자신의 몸을 기준으로 인식된 개인 공간이 차체만큼 확장된다. 마치 차체가 내 몸이 된 것처럼. 이 인지와 실제 차체와 동기화되는 비율이 높을수록 마음이 편하고 안정되는데, 동기화 수준을 떨어뜨리는 요소가 몇 가지 있다. 운전석 기준으로 사각, 후사경에서 인식되는 차 뒷쪽 공간과 실제 차 엉덩이 위치의 위치 차이, 운전석에서 보이는 후드(보닛) 거리와 실제 후드 길이 차이 등이다. 이 차는 내 체형에 잘 맞아서 시야가 좋다. 차체가 SUV에 비해선 낮고, 세단보다는 아주 조금 더 높아서 운전석 높이가 적당하다. 그리고 사각(죽은 시야각)이 거의 없다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>책, Flask 기반의 파이썬 웹 프로그래밍 소감</title>
    <link href="/2016/07/book-python-web-programming-with-flask/"/>
    <updated>2016-07-08T01:00:00+09:00</updated>
    <id>/2016/07/book-python-web-programming-with-flask</id>
    <content type="html">&lt;p&gt;Flask 입문서가 국내 집필서로 나왔다. &lt;a href=&quot;http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=83637353&quot;&gt;Flask 기반의 파이썬 웹 프로그래밍&lt;/a&gt;인데 국내 집필서로는 처음으로 보인다.&lt;/p&gt;

&lt;p&gt;Flask는 경량 웹 프레임웍이다. 경량이라지만 꼭 필요한 건 갖춰져 있어서 바퀴 재발명하는 재미(?)를 만끽하기에도 좋고, 유연해서 확장하기도 좋다. 나도 애용하는데, 한 가지 아쉬운 점이 있고 한 가지 궁금한 점이 있다.&lt;/p&gt;

&lt;p&gt;아쉬운 점은 공식 문서가 불친절하다는 것이다. 방향 제시 수준으로만 설명하고 나머지는 알아서 하라는 식이다. 그래서 종종 flask 소스 코드를 까보곤 하며, 내가 VIM이나 Sublime text를 쓰다가 PyCharm을 쓰게 된 것도 구현체 이동 기능으로 Flask 소스 코드를 편하게 까보기 위해서이다. 문서 보다 Flask 소스 코드 보는 경우가 더 많다. 그래서 Python으로 웹 프로그래밍에 입문하려는 사람에겐 Django를 추천한다. 도구 자체를 익히기엔 Flask가 간결해서 좋지만, 입문자가 독학하는 데 도움이 될 만한 친절한 문서가 많지 않다.&lt;/p&gt;

&lt;p&gt;궁금한 점은 다른 사람은 어떻게 구조를 잡고 쓰고 있는가 이다. 자기 입맛대로 쓰면 그만인 웹 프레임웍이긴 하지만, 그래도 궁금하긴 하다. &lt;a href=&quot;https://github.com/teampopong/pokr.kr&quot;&gt;팀 포퐁의 pokr 소스 코드&lt;/a&gt;를 본 뒤로는 더 궁금해졌다. Django는 구조가 그래도 고만고만한 경향이 있는데, Flask는 정말 다양하겠다는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;이 책은 두 가지 중 하나는 꽤 충족시켜 준다. 공식 문서보다 친절한데 그렇다고 막 장황하지도 않다. 공식 문서를 보고 “설명이 이게 끝?”이라 생각이 든다면, 이 책은 거기서 한 수준 정도 더 설명한다. 설명을 하는 기반 코드가 대체로 공식 문서에 나온 예제이고 거의 동일한데, 그래서 좋은 점은 공식 문서를 볼 때 좀 더 친근하게 느낄 것이고 정석(?) 활용을 학습한다는 점이다. 아쉬운 점은 내가 궁금해하는 걸 해소하진 않는다는 점이다.&lt;/p&gt;

&lt;p&gt;Flask이든 Django이든 잘 활용하려면 각 도구가 지향하는 철학이나 방향을 공감하고 이해해야 한다고 본다. 이 책은 그런 공감을 일으키기엔 얕지만, 얕아서 편하게 읽기에 좋다. 자취생을 위한 간편 요리법을 다루는 책 같다. 입문자를 위한 책인지는 잘 모르겠고, 웹 프로그래밍을 해본 사람이 Flask에 얼른 입문해서 써먹을 때 더 유용해 보인다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이 책은 출판사 &lt;a href=&quot;http://www.jpub.kr&quot;&gt;제이펍&lt;/a&gt;에서 내게 증정해준 것이다. 내게 리뷰 같은 걸 요구하지 않고 보내준 것이지만, 국내에 Flask를 다루는 국내 집필서가 없어서 반가운 마음에 나 스스로 쓴 비대가성 글이다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>프로그램 짜는 세탁소집 첫째 아들.</title>
    <link href="/2016/06/who-starts-up-o2o-service/"/>
    <updated>2016-06-06T07:00:00+09:00</updated>
    <id>/2016/06/who-starts-up-o2o-service</id>
    <content type="html">&lt;p&gt;오프라인 영역에서 이뤄지던 세차, 세탁, 주차, 배달 등 다양한 서비스가 O2O(online to offline) 서비스로 등장하고 있다. 창업자나 창업팀을 보면 자신이 하던 오프라인 직업에 IT 기술을 접목하거나 창업자가 IT 분야 개발자인데 특정 오프라인 분야의 덕후인 경우가 많다. 온라인과 오프라인을 함께 이해하고 활용할 줄 알고 접목하기 때문에 기존 온라인에서만 혹은 오프라인에서만 일을 하던 사람과 다른 접근을 하거나 좀 더 빠른 실행이 가능한 것이라 본다.&lt;/p&gt;

&lt;p&gt;스스로 판과 규칙을 짜는 주도성을 갖는 경향이 강한 온라인 분야와는 달리 오프라인 영역은 오랜 세월 쌓인 사용자 경험칙이 강하다. 오프라인 특유의 사용자 경험칙은 대를 이어온 손맛과 비슷하다. 감성 영역이란 얘기다. 그 감성은 세대나 정서 차이로 취향에 안 맞기도 하지만, 요는 기계가 엄청나게 많은 차원으로 학습해도 파악하기 어려운 미세한 감성 영역을 이해하고 접근한다는 데 있다.&lt;/p&gt;

&lt;p&gt;그래서 나는 다음 세대 O2O 서비스는 세탁소집 아들, 자동차 정비소 딸, 미용실 둘째 아들이 일으키는 모습을 기대한다. 단, 조건이 있다. 이들은 소프트웨어를 이해하고 당연히 활용한다는 사고 체계를 갖춰야 한다. 무선인 전화기, 터치 인터페이스, 사회 관계는 온라인에서도 지속된다는 당연한 인식이 기본으로 깔려 있으며, 기계가 할 일을 쉽게 시키는 사고 방식과 체계를 갖춘 세대. 세탁소에서 바삐 움직이는 &lt;strong&gt;콤퓨타&lt;/strong&gt; 세탁기를 보며 콤퓨타와 세탁 너머를 상상할 수 있는 세대.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>프로그래밍 입문자를 위한 몇 가지 조언</title>
    <link href="/2016/01/how-to-study-programming/"/>
    <updated>2016-01-13T10:45:00+09:00</updated>
    <id>/2016/01/how-to-study-programming</id>
    <content type="html">&lt;p&gt;2014년 11월 4일부터 &lt;a href=&quot;http://www.fastcampus.co.kr/&quot;&gt;패스트캠퍼스&lt;/a&gt;에서 웹 서비스 개발을 주제로 강의하여 얼마 전에 네 번째 기수를 마쳤다. Python과 Django를 이용해 웹 서비스 개발 공정을 겪는 것이 커리큘럼 주제인데, 1기에 대한 이야기는 &lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;Python과 Django 강의&lt;/a&gt;라는 글로 작성했다. 이번 글에선 어떻게 Python과 Django를 공부하면 좋을 지 1년 간 강의하며 고민했고 몇 가지 원리에 대해서는 정리되어 공유해 본다. 내가 강의한 주제가 Python과 Django, 그리고 웹 프로그래밍이어서 그렇지, 프로그래밍에 대한 공부 방법이라고 해도 무방하다고 생각한다.&lt;/p&gt;

&lt;h3 id=&quot;강의-개요&quot;&gt;강의 개요&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;이름 : &lt;a href=&quot;http://www.fastcampus.co.kr/dev_camp_wsd/&quot;&gt;웹 서비스 개발 캠프&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;주제
    &lt;ul&gt;
      &lt;li&gt;Python과 Django를 강사의 경험을 담아 심도있게 다룬다.&lt;/li&gt;
      &lt;li&gt;웹 서비스를 개발하는 공정을 Back-end 중심으로 경험하며 웹 프로그램을 개발하여 배치(deployment)한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수강 대상자
    &lt;ul&gt;
      &lt;li&gt;다른 언어나 프레임워크를 써봤고, Django에 입문하려는 사람&lt;/li&gt;
      &lt;li&gt;Python이나 웹 프로그래밍 중급 과정에 진입하려는 사람&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;강의 시간
    &lt;ul&gt;
      &lt;li&gt;1기 : 90시간&lt;/li&gt;
      &lt;li&gt;2기 : 64시간&lt;/li&gt;
      &lt;li&gt;3기 : 48시간&lt;/li&gt;
      &lt;li&gt;4기 : 40시간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;손으로-반복-반복-그리고-또-반복&quot;&gt;손으로 반복, 반복, 그리고 또 반복&lt;/h3&gt;

&lt;p&gt;뭔가 만들려 하면 막막해서 시작을 떼지 못하겠다는 입문자가 무척 많다.&lt;/p&gt;

&lt;p&gt;책을 보거나 강의를 듣는 중엔 다 안다. 물어보면 대답도 한다. 근데 막상 코드를 짜라고 하면 힘겨워한다. 질문하며 코드 흐름을 자연스레 유도하면 대답은 하는데, 그 대답을 코드로 옮기질 못하기도 한다. 커리큘럼 초반엔 잘 따라오는데, 중반에 접어들어 학습하는 주제와 범위가 늘면 눈에 띄게 힘들고 어려워 하는 경우도 있다.&lt;/p&gt;

&lt;p&gt;그에 반해 빈 파일에 코드를 채워넣는 걸 주저하지 않는 사람도 있다. 원래 다른 분야에서 프로그래밍을 했거나 다른 언어로 웹 프로그래밍을 한 사람이야 그렇다 쳐도, 사실상 입문자여서 이 강의를 듣기엔 다소 무리하는 수강자인데도 곧잘 코드를 작성한다. 입문자여서 프로그래밍이나 Python, Django에 대한 지식과 경험이 부족하여 이론을 설명하면 이해는 못하는데 코드는 어쨌든 작성해 간다. 심지어 자신이 무슨 코드를 짰는지 이해하지 못하면서도 말이다.&lt;/p&gt;

&lt;p&gt;이런 차이는 반복량에 있다. 눈으로는 코드와 이론을 알지만, 손은 모른다. 프로그래밍 언어도 언어의 한 종류이다. 아무리 영어 단어나 문법을 외워도 말을 하지 않고 글을 쓰지 않으면 표현하기 어렵다. 마찬가지로 눈으로 이론을 공부하고 코드를 읽어도 손으로 코드를 짜지 않으면 코딩은 되지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://scienceon.hani.co.kr/34106&quot;&gt;시시하고 아는 코드라도 직접 손으로 쳐야 한다. 한 번 쳐보고 넘어가지 말고, 다양하게 응용하며 여러 번 쳐봐야 한다&lt;/a&gt;. 손에도 코드를 새겨야 한다. 코드를 손에 새기는 가장 쉽고 좋은 방법은 딱 세 개이다. 반복, 반복, 그리고 또 반복하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;복습&quot;&gt;복습&lt;/h3&gt;

&lt;p&gt;학습한 건 가능한 빨리 복습해야 학습 효과가 크다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;우선 배운 걸 그대로 따라하는 복습을,&lt;/li&gt;
  &lt;li&gt;시간이 있다면 응용하는 복습을&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하는 게 좋다. 나는 첫 번째 복습 방법을 교재에 반영하여 수강자가 수업 내용을 떠올리도록 유도한다. 큰 주제 별로 교재를 구성하되, 작은 주제는 강의 흐름에 맞추어 배치하여 스토리텔링을 하려 한다. 중요한 내용은 몇 번 반복 등장하고, 가끔 다른 주제가 먼저 등장하기도 하는데 교재를 한 장 한 장 읽어 나가도록 구성하여 교재를 그대로 따라 복습하면 강의를 떠올리도록 한 것이다.&lt;/p&gt;

&lt;p&gt;두 번째 복습 방법은 과제를 내서 유도한다. 아무리 의지가 가득해도 입문자에게 독학이 어려운 이유 중 하나는 학습한 내용을 응용하여 복습하기 어렵기 때문이다. 과제 풀이를 열심히 한 수강자는 커리큘럼 후반으로 가며 다루는 주제가 다양해 질수록 과제를 푼 효과를 보는데, 새 주제가 등장하더라도 이전 주제와 연계되거나 응용하기 때문이다. 책이나 교육 웹사이트로 학습하는데 실습 문제나 과제가 나오면 꼭 풀기를 권한다.&lt;/p&gt;

&lt;p&gt;강의 시간은 기수를 거듭할수록 줄어 들었는데, 수강자가 복습하지 않으면 강의 시간이 아무리 길어도 별 효과가 없었기 때문이다. 실제로 4기는 강의 시간이 1기의 반도 안 됐지만 진도와 강의 주제의 깊이는 별 차이가 없었다.&lt;/p&gt;

&lt;h3 id=&quot;질문&quot;&gt;질문&lt;/h3&gt;

&lt;p&gt;공부하고 있는 걸 머리에 선명하게 새기는 또 다른 방법은 학습자가 질문하는 것인데, 복습한 사람이 질문을 하는 편이었다. 내 경우는 과제에 함정(?)을 심어 놓는데, 과제를 제출한 사람 중 함정에 대해 질문한 사람 없이 문제를 잘 해결했다면 수강자들이 진도를 잘 따라오고 있다고 판단하여 수업에서 좀 더 깊은 내용을 다루거나 더 많은 양을 다룬다. 함정에 빠진 피해자는 질문을 하게 되는데, 함정에 빠진데다 질문을 하여 답변을 받기 때문에 기억에 남을 가능성이 높다고 본다.&lt;/p&gt;

&lt;p&gt;독학할 때엔 이러한 피드백 과정을 겪기 어렵다. 혼자서 웹에서 검색하여 문제를 해결해도 문제의 앞뒤 맥락을 이해하기 보다는 답에 초점을 맞추어 넘어가기 십상이기 때문이다. 나는 문제에 부딪혀서 스스로 해결하지 못하여 웹에서 해결 방법을 찾으면 반드시 따로 갈무리 하여 쌓아놓고, 일정 시간 뒤에 갈무리 한 자료들의 범주를 나누고 복기한다. 갈무리 당시엔 개별 문제이지만, &lt;a href=&quot;http://scienceon.hani.co.kr/33793&quot;&gt;시간이 흘러 쌓인 문제들을 분류해놓고 보면 각 문제가 서로 연결되어 문제 상황과 맥락을 이해&lt;/a&gt;하게 된다.&lt;/p&gt;

&lt;p&gt;질문과 답변을 주고 받는 소통은 피드백 과정이기도 하다. &lt;a href=&quot;http://scienceon.hani.co.kr/33829&quot;&gt;피드백을 받지 못하면 실력은 늘지 않는다&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;질문하고 답을 찾자. 질문 하려면 질문할 준비가 돼야 한다. 그 준비란 바로 실습과 복습이다.&lt;/p&gt;

&lt;h3 id=&quot;함께-공부하기&quot;&gt;함께 공부하기&lt;/h3&gt;

&lt;p&gt;팀은 1기 때부터 계속 조성하려 애썼다. 1기 때는 강사 입장에선 운좋게도 수강자들이 스스로 팀을 짜서 팀 프로젝트를 수행했었다. 2기 때는 권유를 해봤고, 3기 때는 오리엔테이션 때 아예 팀 조성 시간을 갖고 팀 프로젝트를 정해주었으며 팀장에겐 작은 사례(?)를 하기도 했다. 4기 때는 3기 때와 거의 같으나 수시로 팀 프로젝트를 상기시키며 좀 더 독려했다. 하지만 팀 운영은 잘 안 됐다. 복습과 과제 수행도 버거운데 팀 활동은 더 시간 내기 어려웠다는 수강자가 많았다.&lt;/p&gt;

&lt;p&gt;하지만 여전히 팀 조성과 활동을 하도록 관심을 투자할 가치가 있다. 팀은 아니지만 지인과 나란히 앉아 공부하거나 서로 도우며 공부한 수강자는 혼자서 수업에 참여한 수강자에 비해 실패나 난관에 흔들리는 정도가 덜했다. 질문도 왕성하게 하고 붙임성 있게 다른 수강자와 교류하며 수업에 왕성하게 참여하는 수강자는 그 자신이 수업에서 거둬가는 게 많기도 하지만, 다른 수강자에게도 영향을 많이 끼친다. 그런 참여 활동이 &lt;a href=&quot;http://scienceon.hani.co.kr/33907&quot;&gt;당사자 뿐만 아니라 동료 수강자에게 피드백을 주고 받는 과정&lt;/a&gt;이기 때문이다.&lt;/p&gt;

&lt;p&gt;입문자일 수록 함께 공부할 동료를 구하라고 권하고 싶다.&lt;/p&gt;

&lt;h3 id=&quot;마치며&quot;&gt;마치며&lt;/h3&gt;

&lt;p&gt;재작년에 &lt;a href=&quot;http://blog.hannal.com/2014/5/principles_for_efficient_training/&quot;&gt;근거기반훈련 워크샵에 참석해 효과적 훈련의 원리&lt;/a&gt;를 배웠다. 막상 내게 제대로 활용하지 않았는데, 1년 여 강의하며 몇 가지 원리는 뚜렷하게 효과를 체험했다. &lt;a href=&quot;http://www.fastcampus.co.kr/dev_camp_wpb/&quot;&gt;웹 프로그래밍 입문&lt;/a&gt;과 &lt;a href=&quot;http://www.fastcampus.co.kr/dev_camp_wsd/&quot;&gt;웹 서비스 개발&lt;/a&gt;을 주제로 강의하긴 하지만, 꼭 내 강의가 아니더라도 혼자 공부하거나 지인과 공부하며 활용하면 충분히 효과를 볼 것이라 생각한다.&lt;/p&gt;

</content>
  </entry>
  
  <entry>
    <title>2016년을 맞이하며 20년 전 판을 생각하다</title>
    <link href="/2016/01/hello_2016/"/>
    <updated>2016-01-02T16:00:49+09:00</updated>
    <id>/2016/01/hello_2016</id>
    <content type="html">&lt;h3 id=&quot;게임-개발&quot;&gt;게임 개발&lt;/h3&gt;

&lt;p&gt;20년 전에 첫 게임을 만들었다. 내 &lt;a href=&quot;http://blog.hannal.com/profile/&quot;&gt;필명인 한날은 이 게임 이름에서 비롯&lt;/a&gt;된 것이다. 어설프고 재미없고 허섭했지만, 내 게임을 만들어 친구들과 내 게임 얘기를 나누었다. 내 고교 시절 생활기록부를 보니 장래 희망이 컴퓨터 프로그래머라 적혀 있었다. 당시엔 게임 개발이라는 직업이 사회에 인식되기 전이라서 편의상 게임 개발자 대신 컴퓨터 프로그래머라 적은 것인데, 20년이 지난 지금은 정말 게임 개발자가 아니라 컴퓨터 프로그래머가 되어 있다.&lt;/p&gt;

&lt;p&gt;가끔 언제 다시 게임 업계에 돌아오냐는 안부성 질문을 받곤 한다. 게임 업계에 돌아갈 지 안 갈 지 아직은 모르겠다. 하지만 난 게임을 만들어 왔고, 앞으로도 게임을 만들 것이다.&lt;/p&gt;

&lt;h3 id=&quot;홈페이지&quot;&gt;홈페이지&lt;/h3&gt;

&lt;p&gt;20년 전에 내 홈페이지를 처음 열었다. 1997년부터는 게임 개발, 프로그래밍 등을 주제로 운영하다 &lt;a href=&quot;https://web.archive.org/web/19991012051013/http://dimanche.co.kr/index-kr.html&quot;&gt;1998년에 도메인을 사서 나 나름대로 브랜드&lt;/a&gt;를 만들고 유지하려 했다. 꾸준하진 않지만 완전히 놓지 않고 계속 운영해 온 지난 20년을 스스로 대견하게 여긴다.&lt;/p&gt;

&lt;p&gt;나를 표현하는 익숙한 방법이 내 홈페이지 또는 블로그이다. 앞으로도 내 공간에 글을 쓸 것이다.&lt;/p&gt;

&lt;h3 id=&quot;판&quot;&gt;판&lt;/h3&gt;

&lt;p&gt;작더라도 내 판을 만들어야 한다는 생각을 해왔다. 아무리 잘하고 위협스러워도 남의 판에서는 승산이 없다. 판의 주인이 판을 엎고 새 규칙을 짜면 그만이다. 주인이 판 엎지 않게 아양 떨고 비위 맞추고, 규칙을 바꾸면 바꿀 규칙을 예측하며 그 판에 길들여지면 더이상 희망이 없다. 차라리 판의 주인이 한 짓에 삐쳐서 그 판을 떠나는 게 낫다. 내 판을 만들어 사람들이 내 판에 들어오고, 그 판을 키워야 한다. 그래야 내가 바라는 진정한 독립이 이뤄진다.&lt;/p&gt;

&lt;p&gt;하지만 난 그동안 준비되지 않았으며 진심으로 독립을 갈망한 것이 아니었을지도 모른다는 생각을 했다. 내 판을 만들어야 한다고 주창했지만 정작 말로만 고민했을 뿐, 실행할만큼 고민하지 않았다. 여전히 남의 판에 기대어 마이너 버전 수준에서 내 몸뚱아리를 업그레이드 하려 아둥바둥거렸다.&lt;/p&gt;

&lt;p&gt;앞으로 3~4년 뒤부터는 갈수록 내 판을 만드는 데 들이는 노력이 비싸질 것이라 예상한다. 내 판을 만드는 비용이 비싸질수록 포기할 가능성이 커지고, 포기하는 그때부터 남의 판에서 움직이는 장기말이자 노예가 될 것이다.&lt;/p&gt;

&lt;p&gt;20년 전에 막연히 내 판을 만들어야 한다는 생각을 한 것 같다. 능력도 없으면서 게임 만들자며 사람들 꼬셔 게임개발팀을 만들었고, 하루 방문자가 몇 명이더라도 내 홈페이지에 내 글을 남기려 했다. 내 스토리를 갖고 싶었고 만들려 애썼다. 길들여지지 말자. 내 판의 20년 전 원시형을 잊지 말고 포기하지 말자.&lt;/p&gt;

&lt;p&gt;그렇게 다짐하며 각오를 세운다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>내 개발 환경.</title>
    <link href="/2015/12/my-dev-envs/"/>
    <updated>2015-12-18T14:45:00+09:00</updated>
    <id>/2015/12/my_dev_envs</id>
    <content type="html">&lt;p&gt;프로그래밍 입문자, 또는 새로 프로그래밍이나 도구에 입문하는 사람과 얘기를 나누다 보면 다른 사람, 기왕이면 그 언어나 도구에 익숙한 사람이 사용하는 개발 환경을 무척 궁금해 한다는 걸 느꼈다. 그냥 공식 홈페이지에 있는 걸 내려 받아서 설치하면 되는 거 아닌가? 생각하며 관련 자료를 찾아보니 사람들은 공식 홈페이지에 소개되지 않은 방법으로 개발 환경을 꾸린다는 걸 발견하면 더 혼란이 빠져서 아예 입문 자체를 부담스러워 하는 사람도 많다.&lt;/p&gt;

&lt;p&gt;그래서 내가 쓰는 개발 환경을 정리해 본다.&lt;/p&gt;

&lt;h3 id=&quot;공통-환경&quot;&gt;공통 환경&lt;/h3&gt;

&lt;h4 id=&quot;pc&quot;&gt;PC&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Macbook Pro 13인치 (2015년 early)&lt;/li&gt;
  &lt;li&gt;Macbook Pro 15인치 (2014년 early)&lt;/li&gt;
  &lt;li&gt;iMac 20인치 (2011년 mid)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;운영체제&quot;&gt;운영체제&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;주 환경 : OS X. 내가 주로 활동하는 분야는 윈도우 보다는 리눅스나 OS X에서 개발하기 더 편하다.&lt;/li&gt;
  &lt;li&gt;보조 환경 : Ubuntu. 주로 실 서버에 올리기 전에 시험 동작하려고 사용하거나 라즈베리 파이용 뭔가를 만들 때 쓰는 환경이지만, 집에 있는 리눅스 박스가 저사양이라서 평소엔 잘 안 쓴다.&lt;/li&gt;
  &lt;li&gt;쉘(shell) : bash를 주로 써왔지만, 2015년 11월부터 zsh을 쓰고 있다. &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh&quot;&gt;oh-my-zsh&lt;/a&gt;을 쓰고 설정은 기본값으로 쓰고 있으며, plugin만 git, virtualenv, virtualenvwrapper를 설정했다.&lt;/li&gt;
  &lt;li&gt;터미널은 OS X에 기본 내장된 것을 사용한다.&lt;/li&gt;
  &lt;li&gt;맥 패키지는 &lt;a href=&quot;http://brew.sh&quot;&gt;Homebrew&lt;/a&gt;로 관리한다.&lt;/li&gt;
  &lt;li&gt;파일, 디렉터리 구조는 &lt;a href=&quot;http://mama.indstate.edu/users/ice/tree/&quot;&gt;tree&lt;/a&gt;을 쓴다. OS X는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;brew install tree&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;원격에 있는 파일은 &lt;a href=&quot;https://www.gnu.org/software/wget/&quot;&gt;wget&lt;/a&gt;로 받는다. OS X는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;brew install wget&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;글꼴&quot;&gt;글꼴&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://sourcefoundry.org/hack/&quot;&gt;Hack&lt;/a&gt;을 사용한다.&lt;/p&gt;

&lt;h4 id=&quot;vcs-client&quot;&gt;VCS client&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; : 기본 클라이언트를 터미널에서 쓴다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.sourcetreeapp.com/&quot;&gt;sourcetree&lt;/a&gt; : 커밋이 복잡하게 꼬였을 때 쓰지만, 느려서 가끔 쓴다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/karan/joe&quot;&gt;joe&lt;/a&gt; : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 파일을 다룰 때 쓴다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;python&quot;&gt;Python&lt;/h3&gt;

&lt;h4 id=&quot;에디터&quot;&gt;에디터&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jetbrains.com/pycharm/&quot;&gt;PyCharm&lt;/a&gt; : 2015년 11월부터 쓰고 있다. 아직 익숙하지 않다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.sublimetext.com/&quot;&gt;Sublime text 3&lt;/a&gt; : 평소에 주로 써왔는데, 최근엔 조금씩 빈도를 줄이고 있다.
    &lt;ul&gt;
      &lt;li&gt;SublimeLinter + Python Flake8 lint : 코드 검사기는 &lt;a href=&quot;https://flake8.readthedocs.org&quot;&gt;Flake8&lt;/a&gt;을 SublimeLinter에 연동해 쓴다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;VIM : 급히 간단히 편집할 때 쓴다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;python-관련&quot;&gt;Python 관련&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Python 3, 2.7 : 최근엔 3 버전으로 시작하는 프로젝트가 늘고 있지만, 아직은 2.7로 동작하는 게 더 많다.&lt;/li&gt;
  &lt;li&gt;PyPy : 실 사용 환경에서 사용하고 있긴 한데, 여전히 제한되게 쓰고 있다.&lt;/li&gt;
  &lt;li&gt;virtualenv/virtualenvwrapper : 주로 사용하는 Python 환경 격리 도구.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;golang&quot;&gt;Golang&lt;/h3&gt;

&lt;h4 id=&quot;에디터-1&quot;&gt;에디터&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt; : 2015년 11월부터 쓰고 있다. 느려서 답답한데, 편하긴 하다. golang 정식 plugin이 출시되었다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.sublimetext.com/&quot;&gt;Sublime text 3&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;plugin : Goimports, GoSublime, SublimeLinter-contrib-golint&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;문서와-자료&quot;&gt;문서와 자료&lt;/h3&gt;

&lt;h4 id=&quot;편집&quot;&gt;편집&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;markdown : 로컬에서 문서를 작성하는 경우엔 대부분 markdown으로 작성한다. 편집은 &lt;a href=&quot;https://atom.io/&quot;&gt;Atom&lt;/a&gt;으로 하는데, 한글이 많으면 어느 에디터든 무척 느려지기 때문에 코딩 할 땐 사용하지 않는 Atom을 markdown 문서 편집용으로 쓴다.&lt;/li&gt;
  &lt;li&gt;google drive : 다른 사람과 협업하거나 공유해야 하는 경우에 사용한다. 주로 google docs, spreadsheet.&lt;/li&gt;
  &lt;li&gt;dropbox paper : 베타판부터 쓰고 있긴 한데, dropbox의 최근 선택과 집중 행보를 보자니 오래 유지 안 하고 종료할 것 같아서 이젠 별로 사용하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;자료-관리&quot;&gt;자료 관리&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;웹 스크래핑 : 모바일 환경에선 &lt;a href=&quot;https://getpocket.com/&quot;&gt;pocket&lt;/a&gt;, PC 환경에선 pocket과 &lt;a href=&quot;http://www.devontechnologies.com/products/devonthink/overview.html&quot;&gt;devonthink&lt;/a&gt;로 스크랩한다. evernote + clearly를 썼는데, 갈수록 구려져서 안 쓴다.&lt;/li&gt;
  &lt;li&gt;PDF : devonthink에 담아서 관리하며, dropbox에도 올려서 모바일 환경에서 접근한다.&lt;/li&gt;
  &lt;li&gt;bookmark : 구글 크롬에 북마크한다. 구글 계정 동기화를 해놔서 내가 사용하는 장비 모두와 북마크 동기화가 늘 되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;이외&quot;&gt;이외&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Google chrome : 느리고 뚱뚱하지만, 구글 계정 연동이 편해서 여전히 쓴다.&lt;/li&gt;
  &lt;li&gt;이외 도구는 가장 기본 설정대로 사용한다.
    &lt;ul&gt;
      &lt;li&gt;R Studio, Apache spark, React, Jupyter, …&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>10. 이용자가 올린 사진 목록 보기</title>
    <link href="/2015/10/start_with_django_webframework_10/"/>
    <updated>2015-10-02T12:45:00+09:00</updated>
    <id>/2015/10/start_with_django_webframework_10</id>
    <content type="html">&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/category/start-with-django-webframework/&quot;&gt;날로 먹는 Django 웹프레임워크 강좌 목차&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;마지막 갱신일시 : 2017년 1월 30일 1시 10분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사진을 게시하였으니 저장된 사진을 가져와 나열하는 기능이 필요합니다. 로그인한 이용자가 사진을 게시하는 기능을 만들었으니 이용자 단위로 사진을 가져와 보여주는 개인 프로필 공간을 만들어 보겠습니다. 이번 편은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 이용해 데이터를 찾는 방법을 다룹니다.&lt;/p&gt;

&lt;h3 id=&quot;개인-프로필-기능용-앱-만들기&quot;&gt;개인 프로필 기능용 앱 만들기&lt;/h3&gt;

&lt;p&gt;강좌 &lt;a href=&quot;http://blog.hannal.com/2014/8/start_with_django_webframework_01/&quot;&gt;1편 Pystagram 기획&lt;/a&gt;에서 개인 프로필 공간(이하 프로필 페이지)은 다음 기능을 포함합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;간단한 소개&lt;/li&gt;
  &lt;li&gt;팔로잉, 팔로워&lt;/li&gt;
  &lt;li&gt;이용자가 올린 사진&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로필 페이지를 비롯해서 이용자의 대외 노출 기능은 모두 별도 Django 앱을 만들어 다루겠습니다. 꼭 앱으로 나누지 않아도 되지만, 같은 목적이나 맥락끼리 기능을 구분하여 앱으로 묶어 관리하는 게 낫습니다. 터미널 쉘에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;manage.py&lt;/code&gt; 파일을 이용해 앱을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python manage.py startapp profiles
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;url-패턴-만들기&quot;&gt;URL 패턴 만들기&lt;/h3&gt;

&lt;p&gt;이번 편에서는 “이용자가 올린 사진”을 나열하는 기능을 구현하는데, 페이지 URL은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/users/&amp;lt;이용자 ID&amp;gt;/&lt;/code&gt; 패턴입니다. 이전 편까지는 URL 패턴을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일이 있는 시작 패키지의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에 등록하였는데, 프로필 공간에 들어가는 기능이나 페이지에 필요한 URL은 따로 분리하여 연결하는 방식을 쓰겠습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 만들어서 이 모듈에 프로필 관련 URL을 등록하고, 시작 패키지의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에서는 앱 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;include()&lt;/code&gt; 함수로 포함시키는 방식입니다. Django Admin에 사용하는 URL 패턴을 이 방식으로 포함시켜 사용합니다.&lt;/p&gt;

&lt;p&gt;먼저 시작 패키지, 그러니까 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일이 있는 디렉터리에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 열고 다음 내용을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.conf.urls import include

urlpatterns = [
    # 생략
    url(r&apos;^users/&apos;, include(&apos;profiles.urls&apos;)),
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;include&lt;/code&gt; 함수를 이용해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;users/&lt;/code&gt;로 시작하는 URL들은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;profiles.urls&apos;&lt;/code&gt;에 있는 포함시킵니다. 이는 실제로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리 안에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 만들어 사용하는데, 좀 더 정확하게는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;urlpatterns&lt;/code&gt; 이름을 갖는 객체를 만들어야 합니다.&lt;/p&gt;

&lt;p&gt;이번엔 include 대상인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profiles.urls&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;urlpatterns&lt;/code&gt;를 만듭니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리 안에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 새로 만들고, 그 안에 다음 내용을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.conf.urls import url

from . import views

urlpatterns = [
    url(
        r&apos;^(?P&amp;lt;username&amp;gt;[\w.@+-]+)/$&apos;,
        views.profile,
        name=&apos;profile&apos;
    ),
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그동안 봐온 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 내용과 다를 바 없습니다. 단지 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱에서 사용하는 URL을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profiles.urls&lt;/code&gt;에 만든 것 뿐입니다.&lt;/p&gt;

&lt;h3 id=&quot;뷰-함수와-템플릿-뼈대-만들기&quot;&gt;뷰 함수와 템플릿 뼈대 만들기&lt;/h3&gt;

&lt;p&gt;이번엔 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;views.py&lt;/code&gt; 파일에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile()&lt;/code&gt; 뷰 함수를 추가합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.shortcuts import render

def profile(request, username):
    ctx = {}
    return render(request, &apos;profile.html&apos;, ctx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에서 이용자 이름(ID) 문자열을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt;으로 받아내어 뷰 함수로 전달하도록 하였으므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile()&lt;/code&gt; 함수에서도 두 번째 인자로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt;을 지정해야 합니다.&lt;/p&gt;

&lt;p&gt;뷰 함수는 뼈대부터 만들 것이므로 뷰 함수에서 사용할 뷰 함수 템플릿을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;profile.html&apos;&lt;/code&gt;로 지정합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일은 앱용 템플릿 디렉터리(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;APP_DIRS&lt;/code&gt;)에 만듭니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리 안에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;templates&lt;/code&gt; 디렉터리를 새로 만들고, 그 안에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일을 만든 뒤 다음 내용을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% extends &apos;layout.html&apos; %}

{% block content %}
profile page
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;드디어 뼈대를 만들었습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;manage.py runserver&lt;/code&gt;로 개발용 내장 웹서버를 구동하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:8000/users/hannal/&lt;/code&gt;과 같은 URL로 접근하면 프로필 페이지가 나타납니다.&lt;/p&gt;

&lt;p&gt;하지만, 이 글 내용 그대로 수행했다면 반갑지 않은 화면이 나타납니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hannal.com/assets/uploads/2015/10/10-not_exist_template_file_error.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일이 존재하지 않는다는 내용입니다. 이 파일이 분명히 있는데 저 오류가 발생한다면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt; 설정에 우리가 새로 생성한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱을 추가하지 않아서 그렇습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일은 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리&lt;/strong&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;templates&lt;/code&gt; 디렉터리에 있습니다. 앱 디렉터리에 있다는 의미는 Django가 앱 디렉터리라는 걸 인식해야 한다는 의미입니다. 그래서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt;에 추가하는 것입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt; 항목에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;profiles&apos;&lt;/code&gt; 문자열을 추가하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSTALLED_APPS = (
    &apos;django.contrib.admin&apos;,
    &apos;django.contrib.auth&apos;,
    &apos;django.contrib.contenttypes&apos;,
    &apos;django.contrib.sessions&apos;,
    &apos;django.contrib.messages&apos;,
    &apos;django.contrib.staticfiles&apos;,
    &apos;photos&apos;,
    &apos;profiles&apos;,
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;접속한-페이지의-이용자-정보-가져오기&quot;&gt;접속한 페이지의 이용자 정보 가져오기&lt;/h3&gt;

&lt;p&gt;접속한 프로필 페이지의 이용자 이름은 뷰 함수에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt; 인자로 전달됩니다. 우리는 Django에서 제공하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델을 사용하므로 이 모델의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt; 모델 필드를 검색(lookup)하는 데 사용하여 이용자를 찾습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.shortcuts import get_object_or_404
from django.contrib.auth import get_user_model

def profile(request, username):
    User = get_user_model()
    user = get_object_or_404(User, username=username)
    ctx = {
        &apos;user&apos;: user,
    }

    return render(request, &apos;profile.html&apos;, ctx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_user_model()&lt;/code&gt; 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 모듈의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AUTH_USER_MODEL&lt;/code&gt; 설정 항목을 기준으로 Django 프로젝트가 사용하는 이용자 모델을 가져옵니다. 자세한 내용은 &lt;a href=&quot;http://blog.hannal.com/2015/06/start_with_django_webframework_08/&quot;&gt;8편 로그인, 로그아웃 하기&lt;/a&gt; 편을 참고하세요.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_object_or_404()&lt;/code&gt; 함수는 지정한 모델과 검색 조건으로 데이터를 가져오려 해보고 없으면 HTTP 404 오류를 일으키는 함수입니다. 두 종류 인자를 필요로 하는데, 첫 번째 인자는 데이터를 찾고 가져올 대상 모델 클래스를 받고, 나머지 인자는 검색에 사용합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_object_or_404(User, username=username)&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt; 모델 필드의 값이 뷰 함수에 인자로 전달된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt;과 같은 것을 찾는 내용입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/users/hannal/&lt;/code&gt; URL로 접근하면 뷰 함수의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt; 인자의 값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;hannal&apos;&lt;/code&gt; 문자열이므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_object_or_404(User, username=&apos;hannal&apos;)&lt;/code&gt;을 실행합니다. 이 함수는 데이터 하나를 특정 지어 반한하므로 여러 데이터가 조건에 해당되선 안 됩니다. 데이터가 없는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.http&lt;/code&gt; 모듈에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Http404&lt;/code&gt; 예외 오류를 일으킵니다.&lt;/p&gt;

&lt;p&gt;데이터가 있는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;에 할당하고, 이 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿에 템플릿 맥락 요소(context)로 전달하며, 템플릿 안에서 템플릿 변수로 사용할 이름은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;이번엔 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일을 수정합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% extends &apos;layout.html&apos; %}

{% block content %}
&amp;lt;h1&amp;gt;님의 프로필 페이지&amp;lt;/h1&amp;gt;

&amp;lt;ul&amp;gt;
{% for photo in user.photo_set.all %}
    &amp;lt;li&amp;gt;&amp;lt;img src=&quot;&quot; /&amp;gt;&amp;lt;/li&amp;gt;
{% empty %}
    &amp;lt;li&amp;gt;게시한 사진이 없습니다.&amp;lt;/li&amp;gt;
{% endfor %}
&amp;lt;/ul&amp;gt;

{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;눈 여겨 볼 부분은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user.photo_set.all&lt;/code&gt;입니다. 이 부분은 Python 코드로 표현하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user.photo_set.all()&lt;/code&gt;입니다. Django 템플릿 엔진은 Python의 함수나 클래스와 같이 호출 가능한(callable) 객체를 템플릿 안에서 소괄호를 쳐서 직접 호출하는 걸 허용하지 않습니다. 객체 이름이나 메서드 이름만 명시하면 Django가 대상의 자료형을 검사해서 호출 가능한 객체인 경우 대신 호출하여 수행합니다. 소괄호를 사용하지 못하므로 함수나 메서드에 인자를 전달하지도 못합니다. 인자를 전달하려면 Django 템플릿 필터나 태그를 직접 만들어 사용해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;queryset-객체&quot;&gt;QuerySet 객체&lt;/h3&gt;

&lt;h4 id=&quot;연관-객체-참조-related-objects-reference&quot;&gt;연관 객체 참조 (related objects reference)&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user.photo_set.all()&lt;/code&gt;는 접속한 프로필 페이지의 이용자(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;)가 소유한(own) 모든 사진 게시물을 가져오는 코드입니다. 하나씩 살펴 보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;는 뷰 함수에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; &lt;strong&gt;모델&lt;/strong&gt; 클래스로 데이터를 가져와 연결시켜(mapping) Python 인스턴스 객체로 생성한 것입니다. 그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델은 우리가 앞서 만든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photo&lt;/code&gt; 앱의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;로 연결되어 있습니다. 이용자 한 명이 사진을 여러 개 가지므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델이 1, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델은 다수(n) 관계라서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델 기준으로는 1:N(OneToMany) 관계입니다.&lt;/p&gt;

&lt;p&gt;이 관계가 중요한데요. Django는 모델이 관계(relationship)를 맺고 있으면 연결 당한 쪽에 &lt;strong&gt;연관 객체 참조 속성&lt;/strong&gt;이라는 특별한 속성을 만듭니다. 연결하는 쪽은 모델 필드로 연결하는 대상 모델을 가리키고 있지만, 연결 당하는 쪽은 Python 코드상으로는 알 도리가 없습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델을 놓고 보면, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델엔 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user = models.ForeignKey(settings.AUTH_USER_MODEL)&lt;/code&gt; 모델 필드를 만들어서 연결하는 모델이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델이라는 것이 드러나지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델엔 아무런 조치를 취하지 않으므로 Python 코드만으로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델이 자신을 연결하는지는 알지 못합니다. 하지만 Django는 모델 관계를 파악하여 연결 당하는 쪽에 연결하는 모델에 대한 접근 경로를 객체 속성(attribute)으로 만들어 줍니다.&lt;/p&gt;

&lt;p&gt;일 대 다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;)나 다 대 다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;) 관계는 연결 당하는 특정 데이터에 연결하는 쪽의 여러 데이터가 관계를 맺습니다. 이처럼 &lt;strong&gt;1&lt;/strong&gt;쪽에 &lt;strong&gt;N&lt;/strong&gt;으로 연결되는 경우, &lt;strong&gt;1&lt;/strong&gt;쪽에 N쪽 모델 이름을 참조하여 속성을 만듭니다. 이 속성은 따로 지정하지 않으면 N쪽 모델 이름을 소문자 Snake case 표기로 만들고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_set&lt;/code&gt;을 덧붙인 이름을 갖습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델로 놓고 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델의 인스턴스 객체에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photo_set&lt;/code&gt; 속성이 만들어 집니다.&lt;/p&gt;

&lt;h4 id=&quot;queryset-객체-1&quot;&gt;QuerySet 객체&lt;/h4&gt;

&lt;p&gt;연관 객체 참조 속성은 Django 모델의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;은 이름에서 드러나듯이 Query 집합(set)입니다. Django model manager는 크게 두 종류 객체를 반환하는데, 하나는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체이고 다른 하나는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체가 아닌 객체입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;엔 다음과 같은 특징이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Model manager의 API를 포함 (정확히는 QuerySet API를 manager가 상속 받아 사용)&lt;/li&gt;
  &lt;li&gt;꼬리에 꼬리를 무는 연산(evaluation). 일명 chaining 연산.
    &lt;ul&gt;
      &lt;li&gt;단 QuerySet(또는 model manager)의 메서드가 반환하는 객체가 QuerySet이어야 함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;지연 평가 연산과 캐쉬 처리&lt;/li&gt;
  &lt;li&gt;순서열(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;str&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;tuple&lt;/code&gt;) 연산 지원&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 특성은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;의 역할에 기인합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;은 사용자의 요청을 받아 질의(query)를 생성합니다. 이 요청이 데이터베이스에서 데이터를 가져와야만 하는 것이면 생성한 질의를 데이터베이스로 보냅니다. 그렇지 않으면 생성한 질의는 그대로 보관한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 복제하여 새로 반환합니다. 이 경우 반환한 객체도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체이므로 또 다시 model manager API를 이용해 요청을 보낼 수 있습니다. 이런 과정을 반복합니다. 데이터베이스에 질의를 보내 데이터를 가져오면 그 데이터를 보관해두며, 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체의 데이터를 사용하는 경우 보관된 데이터를 사용합니다. 몇 번을 접근하더라도 보관된 데이터를 그대로 재사용합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;지연 평가 연산 : 데이터베이스에 접근해야 할 때까지 질의를 보내지 않고 질의를 생성해 조합하며 쌓는 동작&lt;/li&gt;
  &lt;li&gt;캐쉬 처리 : 보관한 데이터를 재사용해 데이터에 접근할 때마다 데이터베이스에 질의를 요청하지 않음&lt;/li&gt;
  &lt;li&gt;chaining : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 반환하는 경우, 그 객체를 이용해 요청을 이어나감&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우리가 앞서 만든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델 클래스로 예를 들겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;qs = Photo.objects.filter(pk__in=(1, 2, 3, 4, ))  # 첫 번째 요청.
qs = qs.filter(content__contains=&apos;te&apos;)  # 두 번째 요청.
qs.count()  # 세 번째 요청.
qs.count()  # 네 번째 요청.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;총 네 번 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체의 메서드를 호출했습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;첫 번째 요청은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pk&lt;/code&gt; 모델 필드(기본키, primary key)가 1, 2, 3, 4인 데이터를 가져오라는 질의를 만듭니다. SQL 질의문으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT * FROM &quot;photos_photo&quot; WHERE &quot;photos_photo&quot;.&quot;id&quot; IN (1, 2, 3, 4)&lt;/code&gt;을 생성한 채 일단 기다립니다.&lt;/li&gt;
  &lt;li&gt;두 번째 요청은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;content&lt;/code&gt; 모델 필드로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;te&lt;/code&gt; 문자열을 포함하는 데이터를 가져오라는 질의를 만듭니다. 기존 질의문을 조합한 만드므로 질의문은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SELECT * FROM &quot;photos_photo&quot; WHERE (&quot;photos_photo&quot;.&quot;id&quot; IN (1, 2, 3, 4) AND &quot;photos_photo&quot;.&quot;content&quot; LIKE %te% ESCAPE &apos;\&apos;)&lt;/code&gt;가 됩니다. 여전히 데이터베이스에 질의를 보내지 않고 기다립니다.&lt;/li&gt;
  &lt;li&gt;세 번째 요청은 여태까지 누적한 탐색(lookup) 조건에 해당하는 모든 데이터의 개수를 가져오는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count()&lt;/code&gt; 메서드입니다. 데이터베이스에 질의를 보내야만 확인 가능한 데이터입니다. 여태까지 만든 질의문을 비로소 데이터베이서에 요청합니다.&lt;/li&gt;
  &lt;li&gt;네 번째 요청도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count()&lt;/code&gt; 메서드입니다. 이미 캐쉬된 데이터가 있어서 데이터베이스에 질의하지 않고 보관하고 있는 데이터에서 개수를 가져와 반환합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count()&lt;/code&gt; 메서드는 개수를 숫자로 반환하며, 숫자는 정수형(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt;) 객체여서 더이상 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체의 특성을 사용하지 못합니다. 이렇게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 반환하지 않는 model manager API는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;메서드&lt;/th&gt;
      &lt;th&gt;반환하는 객체&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;조건에 해당하는 특정 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 보관된 데이터 중 첫 번째 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;last()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 보관된 데이터 중 마지막 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;earliest()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;인자로 전달해 지정한 모델 필드를 기준으로 가장 첫 번째 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;latest()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;인자로 전달해 지정한 모델 필드를 기준으로 가장 마지막 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;count()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt; 객체&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 보관된 질의를 기준으로 개수를 가져오거나 보관된 데이터의 개수를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exists()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bool&lt;/code&gt; 객체&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 보관된 질의 또는 보관된 데이터를 기준으로 데이터가 존재하는 지 여부를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_or_create()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;조건에 해당하는 특정 데이터를 가져오고 없으면 인자로 전달한 내용으로 데이터를 저장한 후 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;update_or_create()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;특정 데이터를 수정하고, 그 데이터가 없으면 인자로 전달한 내용으로 데이터를 저장한 후 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이외에도 몇 가지 더 있는데 강좌 진행 중 사용하면 자세히 다루겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 반환하는 메서드도 살펴 보겠습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;메서드&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;all()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;전체 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;인자로 전달한 조건에 해당하는 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;exclude()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;인자로 전달한 조건에 해당하지 않는 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_by()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 모델 필드로 정렬하여 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reverse()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 저장된 데이터를 뒤집어서 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;select_related()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;N:1(ManyToOne, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForeginKey&lt;/code&gt;)으로 연결된 데이터를 함께 가져온다. 데이터베이스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JOIN&lt;/code&gt; 처리.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prefetch_related()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;N:N(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;)으로 연결된 함께 데이터를 가져온다. 데이터베이스의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JOIN&lt;/code&gt; 처리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;using()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 데이터베이스에서 데이터를 가져온다. 기본은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt;로 지정된 데이터베이스.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이번 편에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;all()&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter()&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_by()&lt;/code&gt;을 다루며, 다른 메서드는 사용할 때 자세히 다루겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;filter-메서드&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter()&lt;/code&gt; 메서드&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photo_set&lt;/code&gt;을 설명하려고 먼 길 다녀왔네요. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photo_set&lt;/code&gt; 속성은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체입니다. 그냥 객체는 아니고 조건이 걸려있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photo_set&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델의 인스턴스 객체에서 사용하는데, 이 말은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델로 가져온 이용자 데이터를 담고 있는 인스턴스 객체, 즉 특정 이용자에 연결된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photo_set&lt;/code&gt;입니다. 이를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델로 풀어쓰면 다음 코드와 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user = User.objects.get(username=&apos;hannal&apos;)
photos = Photo.objects.filter(user=user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;hannal&apos;&lt;/code&gt;인 이용자를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;에 할당하고, 소유주(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;)가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;인 모든 사진 게시물(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt;)을 찾아서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photos&lt;/code&gt;에 할당합니다. 간단히 말해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt;이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;hannal&apos;&lt;/code&gt;인 이용자의 모든 사진 게시물을 가져오는 것이지요.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter()&lt;/code&gt; 메서드는 검색(lookup) 조건을 &lt;a href=&quot;http://blog.hannal.com/2015/03/keyword-only-arguments_and_annotations_for_python3/&quot;&gt;키워드 인자&lt;/a&gt;를 받습니다. 인자 이름(key)는 모델 필드의 탐색 방식이고 전달하는 객체(value)는 검색할 값입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter(content=&apos;hannal&apos;)&lt;/code&gt;로 키워드 인자를 전달하면 모델 필드 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;content&lt;/code&gt;의 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hannal&lt;/code&gt;과 일치하는 데이터를 찾습니다.&lt;/p&gt;

&lt;p&gt;하지만 검색 방식이 이렇게 단순하진 않습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hannal&lt;/code&gt; 문자열과 일치하는 게 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hannal&lt;/code&gt; 문자열을 포함한다든지 지정한 숫자보다 큰 값을 갖는 데이터를 찾는 식으로 다양한 검색 방식이 필요한데, Django는 모델 필드 이름에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__탐색키워드&lt;/code&gt;를 덧붙인 인자 이름으로 이러한 검색을 지원합니다. 예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hannal&lt;/code&gt; 문자열을 포함하는 데이터를 찾는 조건이라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter(content__contains=&apos;hannal&apos;)&lt;/code&gt;와 같이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__contains&lt;/code&gt;를 모델 필드인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;content&lt;/code&gt;에 덧붙입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;탐색 키워드&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;contains&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 문자열을 포함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;in&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;리스트나 튜플에 담긴 값들에 해당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gt&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 값을 &lt;strong&gt;초과&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gte&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 값 &lt;strong&gt;이상&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lt&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 값 &lt;strong&gt;미만&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lte&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 값 &lt;strong&gt;이하&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;year&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 연도. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DateField&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DateTimeField&lt;/code&gt; 필드에 한함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;month&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 월. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DateField&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DateTimeField&lt;/code&gt; 필드에 한함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;day&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 일. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DateField&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DateTimeField&lt;/code&gt; 필드에 한함&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;탐색 키워드 역시 자주 쓰는 것만 소개하였으며, 이외 탐색 키워드는 사용할 때 자세히 다루겠습니다.&lt;/p&gt;

&lt;p&gt;여러 탐색 조건을 지정해도 되는데, 함수에 키워드 인자 여러 개를 넣는 방법과 동일합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Photo.objects.filter(user=user, content__contains=&apos;te&apos;)
Photo.objects.filter(user=user).filter(content__contains=&apos;te&apos;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;두 코드는 동일한 역할을 합니다. 이 코드는 사진 게시물의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;이고(AND), &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;content&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;te&apos;&lt;/code&gt; 문자열이 포함된 모든 데이터를 가져옵니다. 쉼표로 구분해 여러 키워드 인자를 전달하든 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;filter()&lt;/code&gt; 메서드를 체인으로 반복해서 부르든 동일하게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AND&lt;/code&gt; 조합으로 데이터를 찾습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OR&lt;/code&gt; 조합으로 찾으려면 별도 조치를 취해야 하는데, 나중에 다루겠습니다.&lt;/p&gt;

&lt;p&gt;정리하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델 클래스의 인스턴스 객체에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photo_set&lt;/code&gt; 속성은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델 클래스와 연결되어 만들어졌으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체로 만들어졌는데 이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photo_set&lt;/code&gt; 속성이 속한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 인스턴스 객체의 데이터를 기반으로 합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photo_set&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체이므로 체인 연결하듯이 후속 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;의 메서드를 사용할 수 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user.photo_set.all()&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;all()&lt;/code&gt; 메서드를 쓴 것입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo.objects.filter(user=user).all()&lt;/code&gt;과 동일한 역할을 합니다.&lt;/p&gt;

&lt;h3 id=&quot;사진-정렬하여-나열하기&quot;&gt;사진 정렬하여 나열하기&lt;/h3&gt;

&lt;p&gt;프로필 페이지에서 사진은 저장된 등록된 순서대로 나열됩니다. 별도로 지정하지 않으면 기본키(primary key)를 기준으로 하여 순서대로 나열되기 때문입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;으로 가져오는 데이터를 정렬하는 방법은 크게 두 가지입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_by()&lt;/code&gt; 메서드로 정렬할 모델 필드 이름 지정&lt;/li&gt;
  &lt;li&gt;모델에 정렬할 기본(default) 기준을 지정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_by()&lt;/code&gt;는 &lt;a href=&quot;http://blog.hannal.com/2015/03/keyword-only-arguments_and_annotations_for_python3/&quot;&gt;위치 인자&lt;/a&gt;로 정렬 기준으로 삼을 모델 필드 이름을 문자열로 받습니다. 여러 개를 지정하면 정렬 우선순위에 따라 정렬합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Photo.objects.order_by(&apos;created_at&apos;)  # created_at 순서대로.
Photo.objects.order_by(&apos;-created_at&apos;)  # created_at 역순으로.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;첫 번째 구문은 전체 사진 게시물을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created_at&lt;/code&gt; 모델 필드 기준으로 하여 순서대로 가져옵니다. 역순으로 가져오려면 모델 필드 이름 앞에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&lt;/code&gt;를 덧붙이면 되며 두 번째 구문이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created_at&lt;/code&gt; 역순으로 정렬하는 것입니다. 만약 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;created_at&lt;/code&gt;, 즉 생성일시가 완전히 동일한 경우에는 기본키 역순으로 정렬하도록 하려면 인자를 추가하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Photo.objects.order_by(&apos;-created_at&apos;, `-pk`)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;무작위 순서로 정렬하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo.objects.order_by(&apos;?&apos;)&lt;/code&gt;처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;?&apos;&lt;/code&gt;를 인자로 전달하면 되는데, 주의할 점은 상당히 느립니다. 되도록이면 쓰지 않길 권합니다.&lt;/p&gt;

&lt;p&gt;모델에 정렬할 기본 기준을 정하려면 모델에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Meta&lt;/code&gt; 클래스를 만들고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Meta&lt;/code&gt; 클래스 안에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ordering&lt;/code&gt; 속성을 만들어 정렬할 모델 필드 이름을 나열하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Photo(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL)
    image = models.ImageField(upload_to=&apos;%Y/%m/%d/orig&apos;)
    filtered_image = models.ImageField(upload_to=&apos;%Y/%m/%d/filtered&apos;)
    content = models.TextField(max_length=500, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = (&apos;-created_at&apos;, &apos;-pk&apos;, )

    # 후략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;나중에 자세히 다루겠지만, 템플릿에서는 함수 호출하듯이 소괄호(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;(&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;)&lt;/code&gt;)를 사용하여 객체 호출을 직접 하지 못합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{% for photo in user.photo_set.all %}&lt;/code&gt;와 같은 구문을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{% for photo in user.photo_set.order_by(&apos;-created_at&apos;, &apos;-pk&apos;) %}&lt;/code&gt;와 같이 쓰지 못합니다. 그래서 정렬하려면 뷰 함수에서 정렬한 데이터를 별도 변수에 할당하여 이 변수를 템플릿에 전달해야 합니다. 예를 들겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# photos/views.py

def profile(request, username):
    User = get_user_model()
    user = get_object_or_404(User, username=username)
    photos = user.photo_set.order_by(&apos;-created_at&apos;, &apos;-pk&apos;)

    ctx = {
        &apos;user&apos;: user,
        &apos;photos&apos;: photos,
    }

    return render(request, &apos;profile.html&apos;, ctx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{# photos/templates/profile.html #}
&amp;lt;ul&amp;gt;
{% for photo in photos %}
    &amp;lt;li&amp;gt;&amp;lt;img src=&quot;&quot; /&amp;gt;&amp;lt;/li&amp;gt;
{% empty %}
    &amp;lt;li&amp;gt;게시한 사진이 없습니다.&amp;lt;/li&amp;gt;
{% endfor %}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또는 모델에서 정렬 기준을 정의하여 따로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;order_by()&lt;/code&gt; 메서드를 쓰지 않더라도 기본으로 지정한 기준대로 정렬되도록 처리해도 됩니다.&lt;/p&gt;

&lt;p&gt;이 강좌에서는 명시한 정렬 기준이 코드에 드러나는 차원에서 뷰 함수에서 정렬하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;강좌 10편을 마칩니다. 정말 오랜만에 연재했네요. 이제 몇 회만 더 연재하면 강좌 1부가 끝납니다. 강좌 분량이 많아지면서 처음 계획을 바꿨습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1부 : Django 전반을 두루 겪기&lt;/li&gt;
  &lt;li&gt;2부 : 1부에서 다루지 않은 내용을 더 자세히 다루기&lt;/li&gt;
  &lt;li&gt;3부 : 앞단 만들고 배포하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;올해 안에 1부를 마치도록 노력하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hannal/start_with_django_webframework/tree/l10&quot;&gt;10편까지 진행한 전체 소스 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
  </entry>
  
  <entry>
    <title>Celery의 Subtask 기능을 이용하여 Chord와 Chain로 작업 분산해서 다루기</title>
    <link href="/2015/07/celery_chord_and_chain/"/>
    <updated>2015-07-08T17:25:00+09:00</updated>
    <id>/2015/07/celery_chord_and_chain</id>
    <content type="html">&lt;h3 id=&quot;웹페이지-긁어오기&quot;&gt;웹페이지 긁어오기&lt;/h3&gt;

&lt;p&gt;Python으로 웹페이지 열 곳을 긁어와서 하나로 합쳐 보겠습니다. Python HTTP library인 &lt;a href=&quot;http://docs.python-requests.org/en/latest/&quot;&gt;requests&lt;/a&gt;를 쓰면 아주 간단합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import requests

def fetch_page_by_url(url):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text

merged_text = []
for i in range(0, 10):
    result = fetch_page_by_url(
        &apos;http://localhost:8000/{}.html&apos;.format(i)
    )

    if result is not None:
        merged_text.append(result)

do_something(merged_text.join(&apos;&apos;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;celery를-이용해-비동기-방식으로-긁어오기&quot;&gt;Celery를 이용해 비동기 방식으로 긁어오기&lt;/h3&gt;

&lt;p&gt;차례대로 긁어오니 열 개 페이지를 모두 가져오기 전까지는 결과를(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;do_something(merged_text.join(&apos;&apos;))&lt;/code&gt;) 확인하지 못합니다. &lt;a href=&quot;https://docs.python.org/3/library/multiprocessing.html&quot;&gt;multiprocessing&lt;/a&gt;을 이용해 여러 프로세스로 동시성을 확보해도 되지만, 분산 작업 큐 시스템인 &lt;a href=&quot;http://celery.readthedocs.org/en/latest/&quot;&gt;Celery&lt;/a&gt;로 쉽고 간편하게 비동기 처리하기도 합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from celery import Celery

app = Celery(__name__)

@app.task
def fetch_page_by_url(url):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text

merged_text = []
for i in range(0, 10):
    result = fetch_page_by_url.apply_async(
        &apos;http://localhost:8000/{}.html&apos;.format(i)
    )

    if result is not None:
        merged_text.append(result)

do_something(merged_text.join(&apos;&apos;))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드에는 문제가 있습니다. Celery 작업 수행 객체로 장식된(decorated) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_page_by_url&lt;/code&gt; 객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;apply_async()&lt;/code&gt; 메서드를&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 이용하여 &lt;strong&gt;비동기&lt;/strong&gt;로 작업을 수행하는데, 이 메서드가 반환하는 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;res.text&lt;/code&gt;가 아니라 Celery 결과 작업을 다루는 객체입니다. 게다가 비동기로 작업을 수행하고 바로 프로그램 수행 제어권을 호출자에게 반환하므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_page_by_url.apply_async(...)&lt;/code&gt; 호출이 되자마자 바로 다음 구문을 수행하는데, 웹 페이지를 가져오는 작업이 끝났는지 여부는 알지 못 합니다.&lt;/p&gt;

&lt;p&gt;이 문제를 피하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get()&lt;/code&gt; 메서드를 이용합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if result.get() is not None:
        merged_text.append(result)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get()&lt;/code&gt; 메서드는 비동기로 수행하는 작업 객체(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;)가 작업을 마치고 값을 반환하기를 &lt;strong&gt;동기식&lt;/strong&gt;으로 기다려서 반환합니다. 어?! 이렇게 할 거라면 굳이 Celery를 쓸 필요가 없지요. Celery에게 여러 작업을 맡겨서 비동기로 처리하고, 비동기로 처리한 결과를 받아다 뭔가를 하려면 다른 방법을 써야 합니다. 이 글에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chain&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chord&lt;/code&gt;을 사용하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;chain-기능&quot;&gt;chain 기능&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chain&lt;/code&gt; 기능은 이름에서 전해지듯이 작업을 체인처럼 줄줄이 수행합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from celery import chain

@app.task
def fetch_page_by_url(url, append_text=None):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        if append_text is None
            return res.text
        else:
            res.text + append_text

tasks = []
for i in range(0, 10):
    tasks.append(
        fetch_page_by_url.subtask(
            &apos;http://localhost:8000/{}.html&apos;.format(i)
        )
    )

result = chain(tasks)()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;subtask()&lt;/code&gt;는 Celery 작업 객체를 하위 작업으로 수행하는 메서드입니다&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_page_by_url&lt;/code&gt; 객체를 하위 작업으로 수행하는 작업 열 개를 담아 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chain()&lt;/code&gt;에 전달하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chain()&lt;/code&gt;은 순서대로 작업을 수행합니다. 각 작업이 반환하는 객체는 다음 작업자에게 인자로 전달합니다. 첫 번째 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt; 함수가 반환하는 웹페이지 문자열을 두 번째 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;는 두 번째 인자로 받는 것이죠. 그래서 두 번째 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;부터는 앞 작업자가 반환하는 결과를 넘겨 받는 것이지요.&lt;/p&gt;

&lt;p&gt;다른 예를 들어 보겠습니다. 숫자 두 개를 인자로 전달하면 두 숫자를 더하는 작업자를 쓰겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;첫 번째 셈은 1 + 1 입니다.&lt;/li&gt;
  &lt;li&gt;두 번째 셈은 첫 번째 덧셈 결과를 받아서 10을 더합니다.&lt;/li&gt;
  &lt;li&gt;세 번째 셈은 두 번째 덧셈 결과를 받아서 100을 더합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이걸 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chain()&lt;/code&gt;을 이용하면 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;do_chain_tasks = chain(add.s(1, 1), add.s(10), add.s(100))
do_chain_tasks()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chain()&lt;/code&gt;도 바로 작업을 수행하는 게 아니라 Celery 작업 객체를 반환하며&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;, 이 작업 객체를 실행해야 합니다. 바로 위 코드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chain(...)()&lt;/code&gt;라는 구문을 나눈 것입니다.&lt;/p&gt;

&lt;p&gt;재밌는 점은 Celery는 비트 연산으로도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chain()&lt;/code&gt; 작업 객체를 만들어 준다는 점입니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(
    fetch_page_by_url.s(&apos;http://localhost:8000/0.html&apos;) |
    fetch_page_by_url.s(&apos;http://localhost:8000/1.html&apos;) |
    fetch_page_by_url.s(&apos;http://localhost:8000/2.html&apos;) |
    fetch_page_by_url.s(&apos;http://localhost:8000/3.html&apos;)
).apply_async()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참 꼼꼼하게 만들어 놨어요. :)&lt;/p&gt;

&lt;h3 id=&quot;chord-기능&quot;&gt;chord 기능&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chain()&lt;/code&gt;을 이용해 비동기로 열 개 작업을 수행하고 그 결과를 합쳤는데, 아쉬운 마음이 듭니다. 전체 작업 자체는 분명 비동기로 시작한 게 맞지만, 웹페이지를 긁어오는 작업도 동시에 분산해서 처리하면 더 효율이 좋을 겁니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chord()&lt;/code&gt;는 하위 작업을 동시에 수행하고, 각 작업자가 반환하는 값을 callback 실행 객체로 전달해줍니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from collections import MutableSequence
from celery import chord

@app.task
def fetch_page_by_url(url):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text

@app.task
def merge_text(texts):
    assert(isinstance(texts, MutableSequence))
    return texts.join(&apos;&apos;)

tasks = []
for i in range(0, 10):
    tasks.append(
        fetch_page_by_url.s(&apos;http://localhost:8000/{}.html&apos;.format(i))
    )

do_chain_tasks = chord(tasks)
do_chain_tasks(merge_text.s())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt; 함수가 원래대로(?) 돌아왔고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt; 함수가 새로 추가됐습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt;는 전달받은 인자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;texts&lt;/code&gt;를 합치는 일을 하는데, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;가 반환하는 문자열을 담은 리스트형(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;list&lt;/code&gt;) 객체입니다. 맨 처음에 비동기로 작성한 코드에서 웹페이지 문자열을 리스트로 담은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merged_text&lt;/code&gt;와 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chord()&lt;/code&gt;는 각 작업자(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;)가 반환하는 값을 리스트형으로 모아서 callback 객체에게 인자로 전달합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chord()&lt;/code&gt;로 만든 Celery 작업 객체로 callback 객체를 전달할 때 인자를 지정하지 않아도 됩니다. 알아서 넣어 줍니다.&lt;/p&gt;

&lt;p&gt;근데 이 코드엔 사소하다면 사소하고 심각하다면 심각한 문제가 있습니다. 작업들을 비동기로 수행하다보니 웹페이지 문자열이 우리가 원하는 순서대로 담겨져 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt;로 전달된다는 보장이 없습니다. 작업이 먼저 끝나는 순서대로 결과가 담기니 0 - 1 - 2 - 3 … 순서가 될 지 9 - 4 - 7 - 1 순서가 될 지는 아무도 모릅니다.&lt;/p&gt;

&lt;p&gt;여러 해결책이 있겠지만, 각 작업자마다 순번을 주고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt;는 이 순번대로 문자열을 합치면 되겠네요.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@app.task
def fetch_page_by_url(url, num):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text, num

@app.task
def merge_text(texts):
    assert(isinstance(texts, MutableSequence))
    texts.sort(key=lambda x: x[1])
    return texts.join(&apos;&apos;)

tasks = []
for i in range(0, 10):
    tasks.append(
        fetch_page_by_url.s(
            &apos;http://localhost:8000/{}.html&apos;.format(i), i
        )
    )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;에 두 번째 인자로 순번(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;i&lt;/code&gt;)을 전달하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;는 받은 순번을 웹페이지 문자열과 함께 그대로 반환합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt;가 전달받은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;texts&lt;/code&gt;엔 각 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt; 결과가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[(문자열, 0), (문자열, 3), ...]&lt;/code&gt; 형태로 담깁니다. 그래서 각 항목의 두 번째(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[1]&lt;/code&gt;) 값으로 정렬하고 나서 한 문자열로 합친 것입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://celery.readthedocs.org/en/latest/userguide/canvas.html#the-primitives&quot;&gt;Canvas: Designing Workflows : The primitives&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://celery.readthedocs.org/en/latest/userguide/tasks.html#avoid-launching-synchronous-subtasks&quot;&gt;Tasks : Avoid launching synchronous subtasks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;대개는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delay()&lt;/code&gt;라는 메서드로 줄여서 수행합니다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;대개는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;s()&lt;/code&gt;로 줄인 메서드 이름을 씁니다. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chain&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;chord&lt;/code&gt;는 함수처럼 생겼지만 클래스입니다. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  
  <entry>
    <title>9. 로그인한 이용자만 사진 게시물 게시하기</title>
    <link href="/2015/06/start_with_django_webframework_09/"/>
    <updated>2015-06-28T01:20:00+09:00</updated>
    <id>/2015/06/start_with_django_webframework_09</id>
    <content type="html">&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/category/start-with-django-webframework/&quot;&gt;날로 먹는 Django 웹프레임워크 강좌 목차&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;마지막 갱신일시 : 2017년 1월 30일 0시 50분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;지난 편에서는 Django 이용자 인증 체계을 알아봤으니 이번 편에서는 인증 기능을 이용하여 로그인한 이용자만 사진 게시물을 게시하는 기능을 만들어 보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;1-사진-게시물에-이용자-정보-연결&quot;&gt;1. 사진 게시물에 이용자 정보 연결&lt;/h3&gt;

&lt;h4 id=&quot;1-기본키-primary-key&quot;&gt;(1) 기본키 (Primary Key)&lt;/h4&gt;

&lt;p&gt;로그인한 이용자만 사진 게시물을 게시한다면 각 사진 게시물엔 사진을 게시한 이용자 정보를 담아야 합니다. 누가 게시한 사진인지 알아야 하니까요. 이용자 ID(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt;)을 문자열로 담아도 되지만, 대개는 고유하며 변하지 않을 정보인 기본키(Primary Key)를 담습니다.&lt;/p&gt;

&lt;p&gt;이용자가 따로 기본키 역할을 하는 모델 필드를 지정하지 않으면 Django는 관례대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;라는 모델 필드를 알아서 만들고 이를 기본키로 사용합니다. 사진 모델인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt;로 사진 게시물 데이터를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photo01&lt;/code&gt;이라는 인스턴스 객체로 할당하면 이 객체엔 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;라는 멤버 변수가 속성으로 존재하고 이 속성에 정수(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;int&lt;/code&gt;) 값이 할당되어 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; photo01 = Photo.objects.last()
&amp;gt;&amp;gt;&amp;gt; print(photo01.pk)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;모델의 인스턴스 객체엔 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pk&lt;/code&gt; 속성도 존재하는데, 이 속성은 기본키를 가리키고 있습니다. 이용자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 모델 필드를 기본키로 하지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uuid&lt;/code&gt;라는 모델 필드를 만들어 이 필드를 기본키로 지정하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pk&lt;/code&gt;는 이 모델 필드를 가리킵니다. 우리는 각 모델의 기본키로 설정된 모델 필드의 이름이 무엇인지 신경쓰지 않고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pk&lt;/code&gt; 속성을 사용하면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;2-모델-관계-필드-relationship-fields&quot;&gt;(2) 모델 관계 필드 (relationship fields)&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델로 데이터베이스에 저장할 데이터에 이용자 모델의 기본키 값을 저장하려면 다음과 같이 하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Photo(models.Model):
    user_id = models.IntegerField()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그런 뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델로 데이터를 저장하는 과정에서 이용자의 기본키 값을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user_id&lt;/code&gt;에 할당하면 됩니다. 각 게시물을 게시한 이용자가 누구인지 아니까 각 사진 게시물 정보를 가져오면서 이용자 정보도 함께 가져오면 좋겠군요.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.contrib.auth import get_user_model
User = get_user_model()

class Photo(models.Model):
    # 중략
    def get_user(self):
        return User.objects.get(pk=self.user_id)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드들엔 문제가 있습니다. 모델의 기본키 모델 필드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IntegerField&lt;/code&gt;가 아닌 경우에 제대로 대응하지 못하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_user()&lt;/code&gt; 메서드를 호출할 때마다 매번 이용자 모델에서 이용자 데이터를 탐색해 반환하며, 이용자 모델과 연결하는 모델마다 매번 저런 구현을 중복 적용해야 합니다. 이런 문제들에 대응하는 구현체를 만들어야 하는데, Django는 &lt;a href=&quot;https://docs.djangoproject.com/en/1.8/ref/models/fields/#module-django.db.models.fields.related&quot;&gt;관계 모델 필드&lt;/a&gt;로 제공합니다. 총 세 종류입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt; : 1 대 다(1 to n) 관계&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt; : 1 대 1 관계&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt; : 다 대 다(n to n) 관계&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이용자와 사진 게시물 관계로 세 관계 필드를 살펴 보겠습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;는 이용자는 오직 사진 게시물을 하나만 게시하고 소유합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;는 이용자가 사진 게시물을 여러 개 올릴 수 있는데, 각 사진 게시물을 여러 이용자가 소유하는 게 가능합니다. 1번 사진을 Hannal 이용자 뿐만 아니라 Kay, Yuna 이용자가 소유하는 관계가 맺어지므로 소유한 누구나 사진 게시물을 변경하거나 지울 수 있습니다. 마지막으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;는 한 이용자가 여러 사진 게시물을 게시하고 소유하는 관계입니다. 우리에게 필요한 모델 관계군요. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;에 대한 건 본 편 “2. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt; 모델 필드”를 참고하시고, 연결부터 해보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;3-photo-모델에-이용자-기본키-정보-연결하기&quot;&gt;(3) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델에 이용자 기본키 정보 연결하기&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.conf import settings

class Photo(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL)
    # 후략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt; 모델 필드(클래스)는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.db.models&lt;/code&gt; 모듈에 있어서 다른 모델 필드처럼 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;models&lt;/code&gt; 객체에서 접근하여 사용하면 됩니다. 첫 번째 인자로 관계 지을 모델을 모델 객체나 경로를 문자열로 전달합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AUTH_USER_MODEL&lt;/code&gt; 설정 항목은 현재 프로젝트에서 사용하는 인증용 이용자 모델이 위치한 경로를 문자열로 지정하고 있습니다. &lt;a href=&quot;http://blog.hannal.com/2015/06/start_with_django_webframework_08/&quot;&gt;8. 로그인, 로그아웃 하기&lt;/a&gt;편에서 이에 대한 내용을 참조하세요.&lt;/p&gt;

&lt;h5 id=&quot;마이그레이션-수행&quot;&gt;마이그레이션 수행&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델이 변경됐으니 데이터베이스에 반영해야 합니다. 마이그레이션을 수행합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python manage.py makemigrations photos
You are trying to add a non-nullable field &apos;user&apos; to photo without a default;
we can&apos;t do that (the database needs something to populate existing rows).
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows)
 2) Quit, and let me add a default in models.py
Select an option:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;긴 영어 문장이 나오며 뭔가를 물어 보는데 당황하지 말고 내용을 잘 살펴 보세요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;당신은 Null(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt;)을 허용하지 않는(non-nullable) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;라는 필드를 추가하려 하는데, 값이 주어지지 않는 경우에 기본으로 저장될 기본값(default)이 없다.&lt;/li&gt;
  &lt;li&gt;데이터베이스가 기존에 저장된 데이터(populate existing rows)에 Null 외 값을 필요로 해서 우린(Django) 이 작업을 바로 수행하지 못한다.&lt;/li&gt;
  &lt;li&gt;그러니 뭔가 조치를 취해달라.
    &lt;ol&gt;
      &lt;li&gt;이 자리에서 기본값을 제공해주든&lt;/li&gt;
      &lt;li&gt;마이그레이션 수행 과정에서 빠져 나간 뒤에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;models.py&lt;/code&gt;에 기본값 지정 인자(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt;)를 추가해달라.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 자리에서 기본값을 제공해줄테니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;을 입력합니다. Django가 뭔가를 요구하네요.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Please enter the default value now, as valid Python
The datetime module is available, so you can do e.g. datetime.date.today()
&amp;gt;&amp;gt;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기본값으로 유효한 Python의 객체를 입력하라는 말입니다. 일단 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;을 입력합니다.&lt;/p&gt;

&lt;p&gt;이제야 마이그레이션 수행에 필요한 마이그레이션 작업 파일이 만들어 졌습니다. 두 번째 입력한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;은 이용자 모델의 기본키 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;을 뜻합니다. 기존에 저장한 사진 게시물의 이용자를 기본키 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;인 이용자로 지정한 것입니다. 만약, 기존에 소유자가 없는 사진 게시물을 위해 별도 이용자를 만들어서 연결하고자 한다면, 그 이용자를 만들어서 그 이용자의 기본키 숫자값을 지정하면 됩니다.&lt;/p&gt;

&lt;p&gt;왜 기본키 값을 넣는지 첫 번째 이유는 앞서 설명을 하였고, 두 번째 이유는 “(2) ForeignKey 모델 필드”에서 설명하겠습니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;makemigrations&lt;/code&gt; 명령어로 만든 마이그레이션 작업 내용을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;migrate&lt;/code&gt; 명령어로 데이터베이스에 반영합니다.&lt;/p&gt;

&lt;h3 id=&quot;2-로그인한-이용자만-사진-게시물-게시하기&quot;&gt;2. 로그인한 이용자만 사진 게시물 게시하기&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델에 이용자 모델 연결을 마쳤으니 이번엔 사진 게시물을 저장하는 과정에 로그인한 이용자 정보를 적용하겠습니다. 간단히 말해서 로그인한 이용자만 사진 게시물을 게시하는 것이지요.&lt;/p&gt;

&lt;h4 id=&quot;1-현재-이용자를-사진-게시물에-적용&quot;&gt;(1) 현재 이용자를 사진 게시물에 적용&lt;/h4&gt;

&lt;p&gt;현재 웹 서비스에 연결된(requested) 접속 정보는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request&lt;/code&gt; 객체에 담겨 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request&lt;/code&gt;는 뷰(view) 함수가 첫 번째 인자로 전달받는 객체입니다. 개별 사진을 보는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;detail&lt;/code&gt; 뷰 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def detail(request, pk):&lt;/code&gt;와 같이, 사진 게시물을 새로 저장하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create&lt;/code&gt; 뷰 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;def create(request):&lt;/code&gt;와 같이 첫 번째 인자로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request&lt;/code&gt;를 전달 받습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;reuqest&lt;/code&gt; 객체엔 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 속성이 존재하는데, 이 속성은 접속한 이용자에 정보가 담겨 있습니다. 로그인한 이용자라면 이용자 모델 클래스로 생성한 인스턴스 객체가, 로그인하지 않은 이용자라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AnonymousUser&lt;/code&gt; 모델 클래스로 생성한 인스턴스 객체가 할당됩니다.&lt;/p&gt;

&lt;p&gt;그럼 로그인한 이용자만 사진을 게시하도록 코드부터 작성해 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def create(request):
    if request.method == &quot;GET&quot;:
        form = PhotoForm()
    elif request.method == &quot;POST&quot;:
        form = PhotoForm(request.POST, request.FILES)

        if form.is_valid():
            obj = edit_form.save(commit=False)
            obj.user = request.user
            obj.save()

            return redirect(obj)

    # 후략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;한 줄은 조금 바뀌었고, 두 줄이 추가됐습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if form.is_valid():
    obj = form.save(commit=False)
    obj.user = request.user
    obj.save()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;두 번째 줄 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj = form.save(commit=False)&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;form&lt;/code&gt; 객체는 사진 게시물 생성과 관련된 폼(Form)인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt; 폼 클래스입니다. 첫 번째 줄에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_valid()&lt;/code&gt;로 웹에서 전달받은 자료를 검증한 그 객체입니다. 이 객체가 모델 폼인 경우, 그러니까 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ModelForm&lt;/code&gt; 클래스를 상속받아 만든 폼인 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;save()&lt;/code&gt; 인스턴스 메서드를 포함하고 있는데, 이 메서드는 모델의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드와 동일한 역할을 합니다. 데이터를 모델에 연결된 데이터베이스 테이블에 저장하는 것이지요. 모델의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드와 마찬가지로 저장한 내용이 반영된 모델의 인스턴스 객체를 반환합니다. 즉 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;form.save()&lt;/code&gt;로부터 반환받은 객체를 할당한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj&lt;/code&gt;는 모델 폼의 인스턴스 객체가 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt; 모델 폼 클래스에 연결되어 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델로 생성한 인스턴스 객체입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드에 인자로 전달한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commit&lt;/code&gt;은 실제로 데이터베이스에 반영할 것인지 여부를 정합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;를 전달하면 바로 데이터베이스에 저장하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;라고 하면 모델 클래스로 생성한 인스턴스 객체만 반영하고 데이터베이스에 실제로 반영하진 않습니다. 따로 반영 여부를 정해주지 않으면 기본값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;이어서 바로 데이터베이스에 반영합니다. 데이터베이스에 저장하지 않을 거면서 뭐하러 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드를 호출했으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드엔 실제로 반영할 것인지 여부를 정하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commit&lt;/code&gt; 인자가 필요한 이유는 무엇일까요? 답은 그 바로 다음에 나오는 두 줄에 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj.user = request.user&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj&lt;/code&gt; 객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 속성에 현재 로그인한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request.user&lt;/code&gt; 속성을 할당하는 것입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt; 폼 클래스는 웹에서 폼 양식 자료가 담긴 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request.POST&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request.FILES&lt;/code&gt;만 전달 받았지, 현재 이용자 정보가 담긴 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request.user&lt;/code&gt;를 전달받은 적이 없습니다. 그래서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드가 반환한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj&lt;/code&gt; 인스턴스 객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;에는 이용자 정보가 없습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth.User&lt;/code&gt;에 있는 이용자 모델을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt; 관계로 연결했는데, 뷰 함수에서는 관련 정보를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;에 반영하지 않았습니다.&lt;/p&gt;

&lt;p&gt;만약, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;edit_form.save()&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;edit_form.save(commit=True)&lt;/code&gt;처럼 바로 데이터베이스에 반영하려고 하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IntegrityError&lt;/code&gt; 예외 오류가 발생하며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT NULL constraint failed: photo_photo.user_id&lt;/code&gt;라 안내 받습니다.&lt;/p&gt;

&lt;p&gt;겁먹지 말고 오류 안내말을 잘 보세요. 정확히 이해하지 않은 채 추측만 하려는 태도는 안 좋지만, 여러분은 이 강좌 나머지 내용을 그냥 건너뛰지 않을테니 예외 오류 내용을 보고 상황을 추측해 보겠습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT NULL&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;failed&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photos_photo.user_id&lt;/code&gt; 이 세 가지 표현이 눈에 들어오지요? &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photos_photo&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photos&lt;/code&gt; 앱의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델과 연관되어 보이고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user_id&lt;/code&gt;는 우리가 만든 적이 없지만 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드와 관련되어 보입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT NULL&lt;/code&gt;과 관련된 문제가 발생하여 진행하던 작업(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;save()&lt;/code&gt;)이 실패했다는 뜻이군요. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT NULL&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;이면 안 된다는 의미니까 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NULL&lt;/code&gt;이 들어가서 오류가 생긴 겁니다.&lt;/p&gt;

&lt;p&gt;웹페이지의 폼 양식에서 이용자 모델의 기본키 값을 직접 전달하면 안 됩니다. 예를 들어, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hannal&lt;/code&gt; 이용자의 기본키 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1023&lt;/code&gt;이고 이 값을 웹 폼 양식에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user_id&lt;/code&gt;로 담아서 서버로 전달한다면, 이용자는 기본키 값 숫자를 고쳐서 마치 다른 이용자가 사진 게시물을 올린 것처럼 왜곡할지도 모릅니다. 이런 정보는 서버에서 알아내서 다뤄야 합니다. 그게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request.user&lt;/code&gt;입니다. 아하, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request.user&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt; 폼 클래스에 전달하면 되겠구나.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;form = PhotoForm(request.POST, request.FILES, request.user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request.POST&lt;/code&gt;처럼.&lt;/p&gt;

&lt;p&gt;아닙니다. 그렇게 알아서 동작(magic behaviour)해주지 않고, 그래서도 안 됩니다. 이용자 정보가 필요한 폼 클래스라면 이용자 정보를 따로 전달받도록 처리해야 합니다. Python 클래스는 실행 가능한(callable) 객체이므로 함수처럼 소괄호를 사용하여 실행하고 실행 결과로 인스턴스 객체를 반환 받는데, 인스턴스 초기화를 수행하는 메서드가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__init__()&lt;/code&gt;입니다. 이용자 정보인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request.user&lt;/code&gt;를 인자로 전달 받는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__init__()&lt;/code&gt; 메서드를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt; 폼 클래스에 만들면 됩니다. 이건 Class based view를 다룰 때 살펴보기로 하고, 이번 편에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;commit&lt;/code&gt; 인자를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;로 전달하여 처리합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user = models.ForeignKey(settings.AUTH_USER_MODEL)&lt;/code&gt;로 만들었고, 이 모델 필드는 NULL을 허용하지 않습니다. 데이터베이스 테이블에도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;NOT NULL&lt;/code&gt;로 정의되어 있습니다. 그래서 데이터베이스에 실제로 반영하지 말고 우선 모델로 생성한 인스턴스 객체를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;edit_form&lt;/code&gt; 객체로부터 받으려고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;save(commit=False)&lt;/code&gt; 메서드를 수행했습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt;이 반환하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 인스턴스 객체를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj&lt;/code&gt;에 할당받고, 이 객체의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 속성에 이용자 정보인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request.user&lt;/code&gt;를 할당합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj.user = request.user&lt;/code&gt; 코드입니다. 이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj.save()&lt;/code&gt;를 수행하여 데이터베이스에 저장합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;obj.save(commit=True)&lt;/code&gt;와 동일합니다.&lt;/p&gt;

&lt;p&gt;이제 로그인한 이용자 정보가 사진 게시물에 반영되어 저장됩니다.&lt;/p&gt;

&lt;h4 id=&quot;2-create-뷰-함수에-로그인한-이용자만-접근하도록-제한&quot;&gt;(2) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create&lt;/code&gt; 뷰 함수에 로그인한 이용자만 접근하도록 제한&lt;/h4&gt;

&lt;p&gt;로그인하지 않은 이용자가 사진 게시물을 저장하려 하면 오류가 발생할 겁니다. 로그인하지 않은 이용자는 이용자 모델로 생성한 인스턴스 객체에 기본키 값이 없을테니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IntegrityError&lt;/code&gt; 예외 오류가 발생할 것 같습니다. 이렇게 예상하셨다면 훌륭합니다. 한 번 시도해보세요.&lt;/p&gt;

&lt;p&gt;실제로 발생하는 예외는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ValueError&lt;/code&gt;가 발생하며, 안내말은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델 클래스로 만든 인스턴스여야 한다는 내용입니다. 앞서 설명드린 바와 같이 로그인하지 않은 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request.user&lt;/code&gt;엔 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AnonymousUser&lt;/code&gt; 모델 클래스로 생성한 인스턴스 객체가 할당되어 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth.models&lt;/code&gt;에 있는데, 코드를 보면 아시겠지만 껍데기 역할을 할 뿐입니다.&lt;/p&gt;

&lt;p&gt;로그인한 이용자인지 여부는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request.user&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_authenticated()&lt;/code&gt; 메서드를 실행하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bool&lt;/code&gt; 객체를 반환받아 구분합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;True&lt;/code&gt;이면 로그인한 이용자, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;False&lt;/code&gt;이면 로그인하지 않은 이용자입니다. 코드도 아주 간단합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.conf import settings

def create(request):
    if not request.user.is_authenticated():
        return redirect(settings.LOGIN_URL)
    # 후략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;로그인하지 않은 이용자가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;create&lt;/code&gt; 뷰 함수로 접근하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.LOGIN_URL&lt;/code&gt;에 지정되어 있는 URL로 이동(redirect) 시킵니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOGIN_URL&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;global_settings&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/accounts/login/&lt;/code&gt;으로 기본 지정되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@login_required&lt;/code&gt; 장식자(decorator)를 사용하면 앞서 구현한 부분을 더 명확하고 간결하게 표현할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.contrib.auth.decorators import login_required

@login_required
def create(request):
    # 후략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;더 친절하게도 로그인한 후 이동할 도착지도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt; 인자로 지정됩니다. 로그인 주소를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.LOGIN_URL&lt;/code&gt;에 따로 지정해주면 자동으로 변경한 주소로 이동해 줍니다.&lt;/p&gt;

&lt;h3 id=&quot;3-모델-관계에-더-자세히-알아보기&quot;&gt;3. 모델 관계에 더 자세히 알아보기&lt;/h3&gt;

&lt;p&gt;우리는 이용자 모델을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt; 관계로 연결했습니다. 그리고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드에 이용자 모델로 생성한 인스턴스 객체(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request.user&lt;/code&gt;)를 할당하지 않자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photo_photo.user_id&lt;/code&gt;에 NULL을 저장하려 해서 저장하지 못했다는 예외 오류도 접했습니다. 이 중에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user_id&lt;/code&gt; 정체를 살펴 보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-foreignkey-모델-필드&quot;&gt;(1) ForeignKey 모델 필드&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;, 그러니까 Many to one 관계는 “One”쪽에 “Many”쪽 데이터 여러 개가 연결되는 구조입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hannal.com/assets/uploads/2015/06/09-ManyToOne.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한 이용자가 여러 게시물을 남기거나, 한 글갈래(category)에 여러 글이 속하는 관계입니다. Django 모델로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt; 모델 필드로 모델 클래스를 지정한 것인데, 이 관계 정보를 데이터베이스엔 어떻게 저장할까요?&lt;/p&gt;

&lt;p&gt;일단 각 모델은 데이터베이스에 Django 앱 이름과 모델 이름을 조합하여 테이블로 만듭니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photos_photo&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photos&lt;/code&gt; 앱에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델을 뜻합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hello&lt;/code&gt;라는 앱의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hannal&lt;/code&gt; 모델은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hello_hannal&lt;/code&gt; 테이블을, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;KayCha&lt;/code&gt; 모델은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;hello_kay_cha&lt;/code&gt; 테이블을 만들어 연결합니다. 앞서 발생한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IntegrityError&lt;/code&gt; 예외 오류에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;photos_photo&lt;/code&gt; 정체가 무엇인지 이제 아시겠죠?&lt;/p&gt;

&lt;p&gt;Django의 모델 필드는 데이터베이스의 컬럼(column)이 됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;image&lt;/code&gt; 모델 필드는 같은 이름을 갖는 테이블 컬럼이 됩니다. 모델 필드형(type)은 테이블 컬럼형을 결정합니다. 그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;와 같은 모델 관계 필드는 컬럼 이름이 조금 다릅니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드는 컬럼 이름이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user_id&lt;/code&gt;입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user_id&lt;/code&gt; 정체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드가 맞습니다. 그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;가 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user_id&lt;/code&gt;인 이유는 무엇일까요? 질문 아니니 대답 안 하셔도 됩니다. :)&lt;/p&gt;

&lt;p&gt;이번 9회 초반에 모델 간 연결은 기본키로 한다고 설명했습니다. Django는 Many쪽이 One쪽을 연결하는 경우, Many쪽 모델 필드 이름에 One쪽의 기본키 이름을 덧붙입니다.&lt;/p&gt;

&lt;p&gt;기본키는 관례에 따라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;라는 모델 필드가 되며, 모델 필드는 데이터베이스 테이블 컬럼과 이름이 같으므로 테이블 컬럼도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드는 이용자 모델을 Many to one으로 가리키는데, 이용자 모델의 기본키인 모델 필드도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델 데이터가 Many쪽이고 이용자 모델이 One쪽이므로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드는 이용자 모델 필드의 기본키 모델 필드인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt; 이름을 덧붙여서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user_id&lt;/code&gt;가 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hannal.com/assets/uploads/2015/06/09-foreign_key_db_table_schema.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 기본키 모델 필드 이름이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;id&lt;/code&gt;가 아니라 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;uid&lt;/code&gt;라면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_uid&lt;/code&gt;가 덧붙게 됩니다. Django는 이 데이터베이스 컬럼 값을 참조하여 서로 분리된 모델의 데이터 연결 관계를 알아냅니다.&lt;/p&gt;

&lt;h4 id=&quot;2-모델-관계를-나중에-맺기-lazy-relation&quot;&gt;(2) 모델 관계를 나중에 맺기 (lazy relation)&lt;/h4&gt;

&lt;p&gt;모델 관계를 맺을 대상 모델 클래스 객체를 직접 전달해도 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.contrib.auth import get_user_model
User = get_user_model()

class Photo(models.Model):
    user = models.ForeignKey(User)
    # 후략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;models.ForeignKey(User)&lt;/code&gt;는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt; 클래스에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt;라는 객체를 첫 번째 인자로 전달하여 호출(call)하고, 모델 필드의 인스턴스 객체를 반환받아 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;user&lt;/code&gt;에 할당하는 것입니다. Python은 소스 파일 맨 윗 줄부터 아래로 실행하므로 저 구문을 실행하여 모델 필드를 만드는 시점에 실제로 존재하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 객체를 사용합니다.&lt;/p&gt;

&lt;p&gt;그렇다면 관계 맺을 모델이 있는 경로를 문자열로 담아 인자로 전달하는 경우는 언제일까요? 이용자 모델처럼 상황에 따라 연결할 모델이 바뀌는 경우가 있습니다. 지난 편에서 예를 든 것처럼 이용자 모델이 바꾸면 이 모델을 가져오는(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;import&lt;/code&gt;) 모든 코드에도 영향이 미칩니다. 그러나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.AUTH_USER_MODEL&lt;/code&gt;에 이용자 모델이 있는 위치를 지정하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AUTH_USER_MODEL&lt;/code&gt; 내용을 참조하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_user_model()&lt;/code&gt; 함수로 이용자 모델을 가져오면 &lt;a href=&quot;http://blog.dahlia.kr/post/103101756957&quot;&gt;한 의도를 한 구현체로 정리&lt;/a&gt;할 수 있지요.&lt;/p&gt;

&lt;p&gt;관계 맺을 대상 모델이 아직 만들어지기 전에 연결하려는 경우에도 문자열로 지정합니다. A 모델이(from) B 모델을(to) 관계를 맺는다면 다음과 같이 B 모델을 먼저 만들고 그 &lt;strong&gt;이후&lt;/strong&gt;에 A 모델을 만들어야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class B(models.Model):
    pass

class A(models.Model):
    b = models.ForeignKey(B)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;B 모델은 C 모델을 관계 맺는다면 C 모델을 B 모델에 앞서 만들어야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class C(models.Model):
    pass

class B(models.Model):
    c = models.ForeignKey(C)

class A(models.Model):
    b = models.ForeignKey(B)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그런데 C 모델은 A 모델에 관계를 지어야 한다고 가정하겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class C(models.Model):
    a = models.ForeignKey(A)

class B(models.Model):
    c = models.ForeignKey(C)

class A(models.Model):
    b = models.ForeignKey(B)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문제가 생깁니다. C 모델이 만들어지는 시점에 A라는 객체가 존재하지 않기 때문이죠. A 모델을 C 모델 코드 위로 올리면 안 됩니다. A 모델이 만들어지는 시점에 B 모델이 없기 때문이지요. 이런 경우에, C 모델에서 A 모델을 문자열 인자로 전달하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class C(models.Model):
    a = models.ForeignKey(&apos;A&apos;)

class B(models.Model):
    c = models.ForeignKey(C)

class A(models.Model):
    b = models.ForeignKey(B)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문자열로 관계 맺을 대상 모델을 지정하면 관계 맺을 대상 모델이 만들어졌다는 신호가 오기 전까지 관계를 맺지 않은 채 관계 맺는 연산을 지연시켜 놓습니다. 비유가 아니라 정말로 대상 모델 클래스(예 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A&lt;/code&gt; 모델)가 초기화 되면 모델 신호(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ModelSignal&lt;/code&gt;)인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class_prepared&lt;/code&gt;를 일으키고(fire), 대상 모델을 바라보던 모델은(예 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;C&lt;/code&gt; 모델) 이 신호을 받고선 비로소 실제 관계를 맺습니다.&lt;/p&gt;

&lt;p&gt;이런 연산 특성을 응용하여 관계 맺을 대상 모델로 자기 자신을 지정하는 것도 가능합니다. 순환 관계(recursive relationship)이라고 하는데, 문자열 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;self&apos;&lt;/code&gt;을 지정하면 됩니다. 추후에 기회가 닿으면 순환 관계 모델을 만들어 보겠습니다.&lt;/p&gt;

&lt;p&gt;정리하면, 모델 관계 필드는 관계 맺을 대상을 세 가지 형태로 지정합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;관계 지을 모델 클래스 객체를 직접 인자로 전달&lt;/li&gt;
  &lt;li&gt;관계 지을 모델 클래스 객체가 있는 경로를 문자열로 전달
    &lt;ul&gt;
      &lt;li&gt;형식 : &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Django앱이름.모델이름&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자기 자신을 가리키는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;self&apos;&lt;/code&gt; 문자열 전달&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;강좌 9편을 마칩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hannal/start_with_django_webframework/tree/l09&quot;&gt;9편까지 진행한 전체 소스 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
  </entry>
  
  <entry>
    <title>8. 로그인, 로그아웃 하기</title>
    <link href="/2015/06/start_with_django_webframework_08/"/>
    <updated>2015-06-07T02:45:00+09:00</updated>
    <id>/2015/06/start_with_django_webframework_08</id>
    <content type="html">&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/category/start-with-django-webframework/&quot;&gt;날로 먹는 Django 웹프레임워크 강좌 목차&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;마지막 갱신일시 : 2017년 1월 30일 0시 20분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이번 편에서는 Django 이용자 인증 체계을 알아보고, 이 인증 체계에서 로그인을 어떻게 처리하는지 살펴 보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;1-django-이용자-인증-체계&quot;&gt;1. Django 이용자 인증 체계&lt;/h3&gt;

&lt;p&gt;Django 이용자 인증 체계는 크게 두 가지 요소로 구분합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인증 (Authentication)&lt;/li&gt;
  &lt;li&gt;권한 (Authorization)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인증은 “나 누구인데 확인 좀…”이라면 권한은 “나 이거 해도 돼요?”라 보면 됩니다. 누구인지 신원이 확인되지 않은 존재에게 권한을 세밀하게 부여하진 못합니다. 신원이 확인된, 즉, 인증된 이용자인지 아닌지로 구분하는 정도로 권한을 부여합니다. 그래서, 권한 체계를 비롯하여 이용자 인증 체계 자체는 인증(Authetication)을 바탕으로 합니다.&lt;/p&gt;

&lt;h4 id=&quot;1-django-내장-인증-기능&quot;&gt;(1) Django 내장 인증 기능&lt;/h4&gt;

&lt;p&gt;Django는 이용자 인증 체계를 내장하고 있으며, 우리는 이미 이 기능을 사용해봤습니다. &lt;a href=&quot;http://blog.hannal.com/2014/10/start_with_django_webframework_04/&quot;&gt;4. Photo 모델로 Admin 영역에서 데이터 다루기&lt;/a&gt; 편에서 최고 권한 이용자로 Admin 영역에 로그인하여 사진 게시물을 입력 했었거든요.&lt;/p&gt;

&lt;p&gt;Django에 내장된 인증 체계는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth&lt;/code&gt;라는 경로(name space)인 Python 패키지에 모여 있으며, Django 개념으로는 Django App입니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt; 설정 항목을 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;django.contrib.auth&apos;,&lt;/code&gt;가 있는데, 우리가 만드는 Pystagram에 사용할 Django App에 Django 인증 체계가 앱 형태로 기본 내장되어 있는 것입니다.&lt;/p&gt;

&lt;p&gt;Django webframework으로 제품을 만든다면 Django 인증 체계를 사용하는 게 좋습니다. 오랜 기간 개발되어 보안 수준은 성숙하고 안전하며, 확장 가능하게 유연합니다. Django에서 제공하는 다른 여러 기능이 내장된 인증 기능 구조를 따르기 때문에 Django가 제공하는 기능을 유기성 있고 풍부하게 쓰기에도 Django 인증 체계를 쓰는 게 좋습니다.&lt;/p&gt;

&lt;h4 id=&quot;2-django-내장-권한-기능&quot;&gt;(2) Django 내장 권한 기능&lt;/h4&gt;

&lt;p&gt;권한 검사 기능도 Django에 내장되어 있습니다. 뷰(View) 단위 행동(behaviour), 데이터 단위 행동에 권한을 부여하여 운용 가능하며, 권한을 그룹 단위로 묶어서(grouping) 이용자에게 지정하는 기능도 제공합니다. 자세한 내용은 권한 기능을 적용할 때 다루겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;2-로그인-기능-구현&quot;&gt;2. 로그인 기능 구현&lt;/h3&gt;

&lt;h4 id=&quot;1-url-패턴-추가&quot;&gt;(1) URL 패턴 추가&lt;/h4&gt;

&lt;p&gt;Django에서 제공하는 인증 기능을 이용하여 로그인, 로그아웃 기능을 구현 하겠습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일이 있는 시작패키지에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 열고, 다음 내용을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.contrib.auth import views as auth_views  # 이 줄 추가.

urlpatterns = [
    # 중략
    url(
        r&apos;^accounts/login/&apos;,
        auth_views.login,
        name=&apos;login&apos;,
        kwargs={
            &apos;template_name&apos;: &apos;login.html&apos;
        }
    ),
    url(
        r&apos;^accounts/logout/&apos;,
        auth_views.logout,
        name=&apos;logout&apos;,
        kwargs={
            &apos;next_page&apos;: settings.LOGIN_URL,
        }
    ),
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&apos;^accounts/login/&apos;&lt;/code&gt;은 로그인 하는 URL이고, 로그인 화면을 출력하거나 로그인 인증 처리를 하는 뷰 함수는 Django에 내장된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;login&lt;/code&gt; 뷰 함수를 사용합니다. 이 함수 객체는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth.views&lt;/code&gt; 모듈에 존재합니다. 이 URL 패턴의 이름을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;name&lt;/code&gt; 키워드 인자를 이용하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;login&lt;/code&gt;이라고 지었는데, 이 인자를 사용하지 않아도 무방합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kwargs&lt;/code&gt;는 URL 패턴에 연결한 뷰 함수에 추가로 전달할 인자를 사전형(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dict&lt;/code&gt;) 객체로 전달합니다. 키가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;template_name&apos;&lt;/code&gt;이고 값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;login.html&apos;&lt;/code&gt;인 사전형 객체인데, Django에서 제공하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;login&lt;/code&gt; 뷰 함수에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;template_name&lt;/code&gt; 이름으로 키워드 인자를 지정하면 로그인 화면을 출력하는 데 사용할 템플릿으로 사용합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;login.html&apos;&lt;/code&gt;이라는 문자열을 지정했으니 우리가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TEMPLATE_DIRS&lt;/code&gt;에 지정한 템플릿 디렉터리 중 최상위 순위에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;login.html&lt;/code&gt; 파일을 찾아서 로그인 화면을 출력하는 데 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;r&apos;^accounts/logout/&apos;&lt;/code&gt;은 로그아웃 하는 URL이며, 로그아웃 기능 역시 로그인 기능과 마찬가지로 Django에 내장된 뷰 함수를 사용합니다. 키워드 인자 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next_page&lt;/code&gt;는 로그아웃 하고 난 뒤에 이동할 URL을 의미합니다. 이 항목이 없으면 로그아웃 화면이 출력됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;template_name&lt;/code&gt;: ‘logout.html’ 등으로 지정하지 않으면 Django에 내장된 로그아웃 화면이 나타납니다.&lt;/p&gt;

&lt;h4 id=&quot;2-로그인-템플릿-파일&quot;&gt;(2) 로그인 템플릿 파일&lt;/h4&gt;

&lt;p&gt;이번엔 로그인 화면에 사용할 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;login.html&lt;/code&gt; 템플릿 파일을 만듭니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;templates&lt;/code&gt; 디렉터리에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;login.html&lt;/code&gt; 파일을 만들고 다음 내용을 담습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% extends &quot;layout.html&quot; %}

{% block content %}

{% if form.errors %}
&amp;lt;p&amp;gt;ID나 비밀번호가 일치하지 않습니다.&amp;lt;/p&amp;gt;
{% endif %}

&amp;lt;form method=&quot;post&quot; action=&quot;{% url &apos;login&apos; %}&quot;&amp;gt;
{% csrf_token %}
&amp;lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;&quot; /&amp;gt;



&amp;lt;button type=&quot;submit&quot;&amp;gt;로그인&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;

{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django에서 견본으로 제공하는 &lt;a href=&quot;https://docs.djangoproject.com/en/1.10/topics/auth/default/#django.contrib.auth.views.login&quot;&gt;login.html 템플릿 파일&lt;/a&gt;에서 따와서 약간 고쳤습니다. 따로 뷰 함수에서 템플릿으로 로그인 폼을 템플릿 컨텍스트로 전달하지 않았지만, Django에서 관례로 많이 쓰는 이름인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;form&lt;/code&gt;을 사용했습니다. form.errors&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;엔 입력한 폼 양식에 문제가 있는 경우에 문제 내용이 담겨 있습니다. ID(&lt;/code&gt;username`)나 비밀번호를 입력하지 않거나 형식에 맞지 않는 등 여러 오류 종류가 있겠지만, 간결하게 ID와 비밀번호가 일치하지 않는다고만 안내합니다. 로그인에 대해서는 굳이 친절하게 뭐가 문제인지 자세히 알려줄 필요는 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{% if next %}&lt;/code&gt;에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt;는 로그인을 한 후 이동할 URL을 뜻합니다. 예를 들어, 로그인을 하지 않은 채 사진에 달린 댓글을 삭제하려 하면 로그인하는 URL로 이동하고 로그인을 하고 나면 로그인하기 전에 접근하려는 URL으로 이동하는데, 이동할 URL이 GET이나 POST 방식으로 전달된 Query String 키인 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;next&lt;/code&gt;에 담깁니다. 대개는 URL이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://pystagram.com/accounts/login/?next=/redirect_to_here/&lt;/code&gt;와 같이 표현됩니다.&lt;/p&gt;

&lt;p&gt;그외엔 &lt;a href=&quot;http://blog.hannal.com/2015/05/start_with_django_webframework_07/&quot;&gt;7. 사진 게시물 제출하여 게시하기&lt;/a&gt; 편 내용과 비슷합니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;form&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth.forms&lt;/code&gt; 모듈에 있는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AuthenticationForm&lt;/code&gt; 폼 클래스로 생성한 인스턴스 객체입니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:8000/accounts/login/&lt;/code&gt;에 접속하면 로그인 화면이 나옵니다. 잘못된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;password&lt;/code&gt;을 제출하면 이에 대한 안내도 나오고요.&lt;/p&gt;

&lt;p&gt;현재 구현한 로그인 기능으로 로그인을 하면 “Page not found” 오류를 만나게 됩니다. 이에 대해서는 곧 처리하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;3-로그인-과정&quot;&gt;3. 로그인 과정&lt;/h3&gt;

&lt;p&gt;Django가 제공하는 로그인 뷰 함수가 어떤 과정을 거쳐 이용자 인증을 처리하는지 좀 더 살펴 보겠습니다. 이 부분을 몰라도 로그인 기능을 이용하는 데 문제 없습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-form-검증&quot;&gt;(1) Form 검증&lt;/h4&gt;

&lt;p&gt;웹 페이지에서 폼 양식으로 넘어오는 값은 Form을 이용해 값을 검증합니다. Django는 로그인 절차에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AuthenticationForm&lt;/code&gt; 폼을 사용하며, 이 폼은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth.forms&lt;/code&gt; 모듈에 있습니다. 이쯤되면 눈치 채셨을텐데, Django는 인증 관련 모델, 폼, 뷰, 미들웨어 등을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth&lt;/code&gt; 패키지 안에 담아 놨습니다. 인증과 관련된 소스 코드를 보려면 이 패키지를 살펴 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AuthenticationForm&lt;/code&gt; 폼은 현재 이용자 정보와 HTTP 요청 정보를 담은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request&lt;/code&gt; 객체도 함께 인자로 전달 받는데, 세션 처리에 필요하기 때문에 그렇습니다. 폼 양식 값이 유효하면(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_valid()&lt;/code&gt;) 이용자가 로그인 후에 이동할 URL 문자열이 안전한 지 검사합니다. 그런 뒤 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth_login()&lt;/code&gt; 함수를 이용해 로그인 인증 처리를 마무리하고 나서 이용자를 다음 URL로 이동(redirect) 시킵니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth_login()&lt;/code&gt; 함수는 이름과는 달리 실제로는 인증 과정 마무리 단계를 담당합니다. 로그인 양식을 토대로 이용자 정보를 가져와서 HTTP Request(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;request&lt;/code&gt;) 정보와 함께 사용해 서버 세션 정보를 만듭니다. 세션 정보를 만들지 않으면 로그인 정보는 유지되지 않아서 다른 페이지에 방문할 때마다 매번 로그인을 해야 합니다.&lt;/p&gt;

&lt;p&gt;로그인 양식, 그러니까 로그인 하려고 제출한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;password&lt;/code&gt;에 정확히 일치하는 이용자를 찾는 과정은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AuthenticationForm&lt;/code&gt; 폼에서 이뤄집니다. 이 폼의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;clean()&lt;/code&gt; 메서드에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt;과 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;password&lt;/code&gt; 내용을 토대로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;authenticate()&lt;/code&gt; 함수를 이용해 인증을 시도합니다. 일치하는 이용자가 없으면 Form 오류를 일으키고, 우리는 “ID나 비밀번호가 일치하지 않습니다.”라는 안내를 화면에서 만납니다. 일치하는 이용자가 있으면 이 이용자 계정이 활성화 된 상태인지(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_active&lt;/code&gt;) 검사하는 걸로 폼 안에서 처리하는 인증 과정을 마칩니다.&lt;/p&gt;

&lt;h4 id=&quot;2-인증-체계-기반으로-처리&quot;&gt;(2) 인증 체계 기반으로 처리&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;authenticate()&lt;/code&gt; 함수는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AUTHENTICATION_BACKENDS&lt;/code&gt; 항목에 등록된 인증 체계 기반 클래스를 하나씩 가져와서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;authenticate()&lt;/code&gt; 메서드를 호출하여 인증을 시도합니다. 우리가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일에 따로 이 항목을 설정하지 않아도 문제가 없는 건, Django에 기본으로 내장된 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;global_settings.py&lt;/code&gt;에 이 항목이 설정되어 있기 때문입니다. 이 항목에 있는 내용은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;django.contrib.auth.backends.ModelBackend&apos;&lt;/code&gt; 이름영역인 클래스가 튜플 객체로 담겨 있습니다.&lt;/p&gt;

&lt;p&gt;데이터베이스에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt;와 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;password&lt;/code&gt;로 이용자를 찾는 과정이 비로소 이 단계에서 이뤄집니다. 이용자 모델을 가져오고, 이 모델을 이용해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt;으로 먼저 이용자 데이터를 가져오고, 이 이용자 데이터에 저장된 비밀번호와 이용자가 로그인하며 제출한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;password&lt;/code&gt;를 비교합니다. 비밀번호까지 일치하면 해당 이용자 데이터, 그러니까 이용자 모델로 생성한 인스턴스 객체를 반환하고, 그렇지 않으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;None&lt;/code&gt;을 반환합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AUTHENTICATION_BACKENDS&lt;/code&gt; 항목에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth.backends.ModelBackend&lt;/code&gt;이 튜플에 담겨져 있다는 말은 다음 두 가지를 의미합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Django 인증 체계 기반(backend)을 꼭 사용하지 않아도 된다.&lt;/li&gt;
  &lt;li&gt;인증 체계 기반을 여러 개 이상을 사용하는 게 가능하다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;인증 체계 기반의 클래스 규칙대로 인터페이스를 만들기만 한다면 우리가 직접 만든 인증 체계를 사용하거나 Facebook, Twitter처럼 인증 API를 제공하는 서비스나 플랫폼을 기반으로 인증 체계를 운용해도 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;3-이용자-모델-가져오기&quot;&gt;(3) 이용자 모델 가져오기&lt;/h4&gt;

&lt;p&gt;인증 체계 기반을 Django에서 제공하는 기본 인증 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ModelBackend&lt;/code&gt;를 다른 것으로 갈아끼우거나 추가한다면, 이용자 정보를 데이터베이스에서 다루는 이용자 모델도 대체하여 쓸 수 있습니다. Django에 내장된 이용자 모델은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth.models&lt;/code&gt;에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델 클래스입니다. 이 이용자 모델엔 모델 필드이 간결하게 담겨 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;username&lt;/code&gt; : 이용자 ID 역할. 다른 값과 중복되지 않는 고유한 값만 허용합니다(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;unique=True&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;password&lt;/code&gt; : 비밀번호. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PasswordField&lt;/code&gt; 모델 필드.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;first_name&lt;/code&gt; : 성씨. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CharField&lt;/code&gt; 모델 필드이며 생략 가능.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;last_name&lt;/code&gt; : 이름. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CharField&lt;/code&gt; 모델 필드이며 생략 가능.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;email&lt;/code&gt; : 전자우편 주소. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EmailField&lt;/code&gt; 모델 필드.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_staff&lt;/code&gt; : 관리자 여부. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BooleanField&lt;/code&gt; 모델 필드.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_active&lt;/code&gt; : 활성화 된 계정인지 여부. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BooleanField&lt;/code&gt; 모델 필드.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이외에도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is_superuser&lt;/code&gt;나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;groups&lt;/code&gt; 같은 모델 필드 몇 가지가 더 있지만, 이 모델 필드의 값을 직접 다룰 일은 드물고, 이 강좌 내용을 이해하시면 이런 모델 필드를 직접 찾아 다루는 건 어렵지 않으므로 이 강좌에선 다루지 않겠습니다.&lt;/p&gt;

&lt;p&gt;만약, 필명이나 사용하는 언어, 거주 지역처럼 정보를 추가로 이용자로부터 입력 받아 관리하려면 이용자 모델 클래스를 &lt;strong&gt;확장&lt;/strong&gt;해야 합니다. Django에서 제공하는 이용자 모델을 변경해도 되지만, Django 소스 파일을 직접 고쳐서 쓰지 않는 게 좋습니다. Django 판을 올릴 때마다 직접 수정한 부분을 매번 챙겨야 하고, 연계되어 동작하는 다른 기능에 부작용을 일으킬 여지도 있습니다. 그래서 변경하지 않고 &lt;strong&gt;확장&lt;/strong&gt;해야 합니다.&lt;/p&gt;

&lt;p&gt;확장하는 자세한 방법은 다른 편에서 따로 다루기로 하고&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot; rel=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, 여기에선 확장 방법 종류만 간단히 언급하겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;따로 이용자 모델을 만들고, Django의 이용자 모델에 연결(Model relationship).&lt;/li&gt;
  &lt;li&gt;이용자 모델과 모델 매니저, 이용자 폼 등을 모두 구현하여 이용자 모델 부분을 대체.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2번 방법에서 “모델 부분을 대체”한다는 표현을 눈 여겨 보세요. 일일이 Django 소스에서 이용자 모델 관련 부분, 가령, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth.models.User&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pystagram_auth.models.User&lt;/code&gt;와 같이 교체하는 건 아닙니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AUTH_USER_MODEL&lt;/code&gt; 항목에 지정하기만 하면 됩니다.&lt;/p&gt;

&lt;p&gt;이 항목 역시 우리가 따로 설정한 적이 없는데, Django의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;global_settings&lt;/code&gt;에 설정되어 있으며, 기본 값으로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&apos;auth.User&apos;&lt;/code&gt; 문자열이 할당되어 있습니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth&lt;/code&gt;는 Django 앱 이름(Python 패키지)이고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;User&lt;/code&gt;는 모델 클래스 이름입니다. Python 이름영역(name space)으로 풀어 쓰면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth.models.User&lt;/code&gt;인 셈입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AUTH_USER_MODEL&lt;/code&gt; 설정 항목을 참조하여 이용자 모델을 실제로 가져오는 역할은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_user_model()&lt;/code&gt; 함수가 맡으며, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth&lt;/code&gt;에 있습니다. 이 함수를 이용하면 이용자 모델이 어떤 것으로 바뀌든 코드를 일관되게 유지하게 됩니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AUTH_USER_MODEL = &apos;auth.User&apos;&lt;/code&gt;라고 설정하고 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_user_model()&lt;/code&gt; 함수를 실행하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth.models.User&lt;/code&gt;를 반환하고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AUTH_USER_MODEL = &apos;pystagram_auth.MyUser&apos;&lt;/code&gt;로 설정하고 실행하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pystagram_auth.models.MyUser&lt;/code&gt;를 이용자 모델로 반환합니다. 그러므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;get_user_model()&lt;/code&gt; 함수로 이용자 모델을 가져오는 게 좋습니다.&lt;/p&gt;

&lt;p&gt;인증 체계 기반(backend)과는 달리 기본 이용자 모델은 하나만 가능합니다.&lt;/p&gt;

&lt;h4 id=&quot;4-정리하면&quot;&gt;(4) 정리하면&lt;/h4&gt;

&lt;p&gt;로그인 과정을 정리하면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth.views.login&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth.forms.AuthenticationForm&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth.authenticate()&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.AUTHENTICATION_BACKENDS&lt;/code&gt;에서 인증 기반 하나씩 가져옴&lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth.backends.ModelBackend&lt;/code&gt;의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;authenticate()&lt;/code&gt; 메서드로 인증 처리&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth.auth_login&lt;/code&gt; (정확히는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;django.contrib.auth.login&lt;/code&gt;를 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;auth_login&lt;/code&gt;으로 import 한 것.)으로 인증 관련 세션 처리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;로그인 이후 이동할 URL로 이동 처리(redirect)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-로그인-관련-설정-항목&quot;&gt;4. 로그인 관련 설정 항목&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;에 설정하는 로그인 관련 항목이 몇 가지 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-login_url&quot;&gt;(1) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOGIN_URL&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOGIN_URL&lt;/code&gt;은 로그인 URL을 뜻합니다. Django에서 제공하는 장식자(decorator) 중 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;login_required&lt;/code&gt;는 뷰 함수에 접근할 때 로그인 여부를 검사하고, 로그인하지 않으면 로그인 URL로 이용자를 이동시키는데, 이 로그인 URL을 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.LOGIN_URL&lt;/code&gt;에서 가져 옵니다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;global_settings&lt;/code&gt;에 설정된 기본값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/accounts/login/&lt;/code&gt;입니다. 로그인 URL을 다른 것으로 쓴다면 이 항목에 URL을 지정하면 제3자(3rd party) 도구 등에서 참조합니다.&lt;/p&gt;

&lt;h4 id=&quot;2-logout_url&quot;&gt;(2) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOGOUT_URL&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOGIN_URL&lt;/code&gt;과 비슷한 역할을 합니다. 기본값은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/accounts/logout/&lt;/code&gt;입니다. 그런데 사용할 일은 거의 없어서 사실상 죽은 설정 항목이나 마찬가지입니다. 이런 게 있다는 정도로 알아 두시면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;3-login_redirect_url&quot;&gt;(3) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOGIN_REDIRECT_URL&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;로그인을 하고 나서 이동할 URL을 설정합니다. 로그인 하고나서 이동할 URL이 지정된 경우 그 URL로 이동하지만, 이동할 URL이 지정되지 않았거나 지정한 URL이 보안상 문제가 있는 경우 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.LOGIN_REDIRECT_URL&lt;/code&gt;를 사용합니다.&lt;/p&gt;

&lt;p&gt;현재 구현한 기능으로는 로그인을 마치면 “Page not found” 오류를 만납니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hannal.com/assets/uploads/2015/06/08-404_after_login.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;웹 브라우저 주소입력란을 잘 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://localhost:8000/accounts/profile/&lt;/code&gt;과 같이 전혀 본 적 없는 URL로 되어 있습니다. 이는 Django 기본 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LOGIN_REDIRECT_URL&lt;/code&gt; 설정값이 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/accounts/profile/&lt;/code&gt;이라서 그렇습니다. 아직 우리는 프로필 페이지를 만들지 않았으니 임시로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/photos/upload/&lt;/code&gt;로 이동하도록 설정하겠습니다. 시작패키지에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일을 열고 다음 코드를 추가합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOGIN_REDIRECT_URL = &apos;/photos/upload/&apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 로그인을 마치면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/photos/upload/&lt;/code&gt;로 이동하여 사진을 올리라는 압박을 줍니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;강좌 8편을 마칩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hannal/start_with_django_webframework/tree/l08&quot;&gt;8편까지 진행한 전체 소스 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;다른 편에서 다루겠다는 내용이 늘어가니 불안해지네요. 까먹고 다루지 않을까봐요. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  
</feed>