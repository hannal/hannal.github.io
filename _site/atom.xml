<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text" xml:lang="en">Kay on the rails</title>
  <link type="application/atom+xml" href="atom_feed_url" rel="self"/>
  <link type="text/html" href="home_url_canonical" rel="alternate"/>
  <updated>2018-01-07T04:15:04+09:00</updated>
  <id>unique_feed_identifier</id>
  <author>
    <name>author_name</name>
  </author>
  <rights>copyright_details</rights>

  
  <entry>
    <title>일하는 방식 고민.</title>
    <link href="/2018/01/thinking-of-how-to-work/"/>
    <updated>2018-01-06T10:00:00+09:00</updated>
    <id>/2018/01/thinking_of_how_to_work</id>
    <content type="html">&lt;p&gt;난 하루에 집중해서 6~8시간, 일주일에 3~4일만 일하는 게 좋을 것 같다.&lt;/p&gt;

&lt;p&gt;딴짓하지 않고 자신을 몽땅 짜낼만큼 높은 집중력을 내면서 항상성을 유지할 수 있는 하루 최대 근무 시간은 6시간이 최대치인 것 같다. 8시간도 큰 부담은 없는데, 사람이 언제나 전력 질주하듯 집중력을 발휘할 수 있는 건 아니니 기준은 하루 6시간 집중하는 데 맞추고 좀 여유를 내고 싶은 날은 8시간 일하면 될 것 같다.&lt;/p&gt;

&lt;p&gt;자신을 짜내듯 일하면 업무 탈진한다. 탈진했다고 퇴사해서 충전하는 건 업무 맥락, 팀웍 구축 비용이 너무 아깝다. 그러므로 평소에(?) 일하듯이 평소에 공부하고 경험하며 충전해야 한다. 나는 느리고 시간을 많이 투입해야 해서 하루에 3시간은 학습에 쓰고, 일주일에 하루 정도는 온전히 경험성 활동에 써야 하는 것 같다. 이것도 멍하니 읽고 감상하는 게 아니라 의식하고 의도한 활동으로 해야 한다. 안 그러면 남는 게 없는 것 같다.&lt;/p&gt;

&lt;p&gt;주 중에 일과 학습에 집중해서 달리려면 그 주를 회고하고 다음 주를 계획하는 데 하루 정도는 써야 한다. 물론 노는 것도 포함해서. 그리고 온전히 쉬는 날은 최소 하루 보장하고.&lt;/p&gt;

&lt;p&gt;이렇게 해서 먹고 살 수 있을까? 일주일에 100시간씩 일해야 성공할 기회가 생긴다고 한다. 성공하거나 시간과 자본에서 어느 정도 자유를 얻은 지인을 보면 그런 것 같다. 물론 죽도록 일해서 결국 죽거나 동력을 잃거나 실패하는 사람은 있다. 그런데 느슨하게(?) 일해서 성공한 경우는 적어도 내 주변엔 없고, 사회에 알려진 사례도 못본 것 같다.&lt;/p&gt;

&lt;p&gt;실은 나 혼자라면 그런 삶에 곧 도달할 것 같다. 문제는 언제까지 지속할 수 있느냐이다. 1~2년이 아니라 5년, 10년, 20년 이후에도 이렇게 일해서 먹고 살 수 있을까? 자본 소득이 뒷받쳐주지 않는 현 상황에서는 낙관하지 못한다.&lt;/p&gt;

&lt;p&gt;나 혼자가 아니라 팀이라면 장기 지속할 가능성이 클 것 같다. 한 사람이 하는 일을 두 사람이 하면 된다. 팀 복잡도가 올라가서 발생하는 누수를 감안하면 두 사람이 소화하는 것보다 한 사람이 하는 게 더 나을지도 모른다. 하지만 예측 가능한 일정과 높은 질을 꾸준하게 내려면 하루 6~8시간, 주 3~4일 근무를 해야 가능할 것 같다. 물론 팀원의 프로 의식과 그런 문화를 지키고 발전시키려는 태도와 마음을 서로 강하게 믿어야 가능하다. 결국 누구와 함께 하느냐가 가장 중요한 문제이다.&lt;/p&gt;

&lt;p&gt;그렇다고 같은 일을 많은 사람이 한 팀으로 모이는 건 아니다. 오히려 일을 쪼개고 쪼갠 일에 대해 온전히 위임하고 권한을 발휘하도록 하여 개개인 간 의존성을 낮춰야 한다. 팀은 다른 조직에 비해 오히려 큰데 일은 다른 조직보다 더 원자화 되어 동작하는 그런 조직을 어떻게 만들어야 할 지 아직은 잘 모르겠다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Django 템플릿에서 VariableDoesNotExist 예외 오류 대응하기</title>
    <link href="/2017/06/django-template-variabledoesnotexist-exception/"/>
    <updated>2017-06-26T00:00:00+09:00</updated>
    <id>/2017/06/django_template_variabledoesnotexist</id>
    <content type="html">&lt;p&gt;한 줄 요약 : Django 템플릿 엔진은 템플릿 필터에 대해서 항상 조용한 실패 처리(silent failure)를 하진 않는다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Django Template은 없는 템플릿 변수나 템플릿 변수의 속성, 키, 색인이 없어도 오류 상황을 일으키지 않고 조용히 오류 상황을 잠재운다. 일명 Silent failure 동작이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{{ lorem.ipsum.hello.world }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lorem&lt;/code&gt;이라는 템플릿 변수가 없든 &lt;code class=&quot;highlighter-rouge&quot;&gt;lorem&lt;/code&gt; 템플릿 변수는 있는데 이 객체에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ipsum&lt;/code&gt;이라는 키나 속성이 없다고 가정하자. 최종 템플릿 맥락이 출력(치환)이면 Django는 변수나 키, 속성이 없다는 오류 상황을 일으키지 않으며, 저 템플릿 변수 위치엔 아무것도 출력되지 않는다. 템플릿 변수를 출력(render)하거나 템플릿 태그에서 사용할 때는 이처럼 Silent failure로 동작한다.&lt;/p&gt;

&lt;p&gt;하지만 템플릿 필터를 거치는 경우엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;VariableDoesNotExist&lt;/code&gt; 예외(exception)가 발생한다. 예외 이름에서 드러나듯이 템플릿 변수가 없다는 뜻이다.&lt;/p&gt;

&lt;p&gt;예를 들어, 존재하지 않는 템플릿 변수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;not_exist_var&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;divisibleby&lt;/code&gt; 템플릿 필터에 사용하면 예외 오류가 발생한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{{ '1234'|divisibleby:not_exist_var }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이에 대해 Django 공식 문서에서는 다음과 같이 설명한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thus, filter functions should avoid raising exceptions if there is a reasonable fallback value to return. In case of input that represents a clear bug in a template, raising an exception may still be better than silent failure which hides the bug. ( 출처 : &lt;a href=&quot;https://docs.djangoproject.com/en/1.11/howto/custom-template-tags/#writing-custom-template-filters&quot;&gt;custom-template-tags - writing-custom-template-filter&lt;/a&gt; )&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;간단히 말해서 템플릿 필터 함수에서는 버그를 숨기는 Silent failure 보다는 예외를 일으키는 게 낫다고 한다. 실제로 Django 내장 템플릿 필터를 보면 대체물을 대신 반환해도 될 만한 경우엔 Exception 처리를 잡아내서 오류 상황을 피하지만, 그 외의 경우엔 Exception이 발생하게 냅둔다. 문제는 그 정책이 예상을 벗어나는 경우에 발생한다. 난 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 템플릿 필터에서 조용한 실패 처리를 하지 않는 상황을 만났다. &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 템플릿 필터는 대개 다음과 같이 사용한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{{ empty_var|default:'비었수다' }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;나도 비슷하게 사용했다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{{ apple.attr3|default:lemon.attrdict.color }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django 템플릿 엔진 동작에 익숙하다면 다음과 같이 동작하길 기대(예상)한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;apple.attr3&lt;/code&gt;가 없으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;lemon.attrdict['color']&lt;/code&gt;를 대신 출력&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lemon.attrdict&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;color&lt;/code&gt; 키가 없으면 결국 아무것도 출력하지 않고 Silent failure.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;딱히 Exception이 발생할만한 로직이 아니고, &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 필터 함수를 봐도 인자 두 개 받아서 &lt;code class=&quot;highlighter-rouge&quot;&gt;return value or arg&lt;/code&gt;로 동작하는 것 뿐이다. 다시 말해 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 템플릿 필터인 Python 함수는 두 개 인자를 받는데, 첫 번째 인자로 받는 &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 앞에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;apple.attr3&lt;/code&gt;가 있으면 해당 객체를 반환하고, 없으면 두 번째 인자로 받는 &lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt; 뒤에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;lemon.attrdict.color&lt;/code&gt;를 반환한다.&lt;/p&gt;

&lt;p&gt;하지만 실제로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;VariableDoesNotExist&lt;/code&gt; 예외 오류가 발생한다. 이 예외는 &lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt; 템플릿 태그로 해결하면 된다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://gist.github.com/hannal/9de33b54a749457d7f29c5f30c5e9136&quot;&gt;with 템플릿 태그로 VariableDoesNotExist 예방&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt; 템플릿 태그는 Silent failure 처리를 해주니 &lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt; 템플릿 태그로 만든 임시 템플릿 변수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;colour&lt;/code&gt;엔 출력할(render) 게 없는 빈 객체가 할당이 된다. &lt;code class=&quot;highlighter-rouge&quot;&gt;with&lt;/code&gt; 템플릿 태그를 안 쓴 경우엔 Silent failure를 해주는 놈이 없다보니 Exception이 그대로 나버린 것이다. 이 문제가 까다로운 이유는 Django 디버깅 화면에서는 문제가 있는 템플릿 줄(line)을 가리키지 않고 Exception이 발생한 Django 소스를 보여주는 데 있다. 평범한 속성명이나 키 이름을 쓰다가는 고생하기 십상이다.&lt;/p&gt;

&lt;p&gt;흔히 겪는 상황은 아닐 것 같다. 나는 모델에 &lt;code class=&quot;highlighter-rouge&quot;&gt;JSONField&lt;/code&gt;를 썼고, 이 모델필드의 &lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt; 객체에 특정 키(위 예제 기준으로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;colour&lt;/code&gt;키)가 없어서 발생한 거였다. 뷰 함수에서 넘겨주는 템플릿 변수 이름대로라면 금방 발견했을 것 같다.&lt;/p&gt;

&lt;p&gt;삼천포 요약 : 변수 네이밍을 괴랄하게 하면 디버깅에 도움이 된다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>시트로엥 C4 칵투스 두 달 소감.</title>
    <link href="/2016/11/citroen-c4-cactus/"/>
    <updated>2016-11-28T11:00:00+09:00</updated>
    <id>/2016/11/citroen-c4-cactus</id>
    <content type="html">&lt;p&gt;올해 한국에 출시한 시트로엥 C4 칵투스를 샀다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;운행 기간 : 두 달&lt;/li&gt;
  &lt;li&gt;운행 거리 : 약 1,600km&lt;/li&gt;
  &lt;li&gt;평균 연비 : 리터 당 18~19km&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;총평&quot;&gt;총평&lt;/h3&gt;

&lt;p&gt;재밌는 차다. 개성이 강해서 호불호가 극명하게 갈릴 것 같다. 난 선호에 가깝다. 점수를 매기자면 5점 만점에 4점. 30대 3~4인 가정에 추천한다.&lt;/p&gt;

&lt;h3 id=&quot;특성&quot;&gt;특성&lt;/h3&gt;

&lt;h4 id=&quot;1-연비&quot;&gt;1. 연비&lt;/h4&gt;

&lt;p&gt;도심 내 평속 40~60km 정도일 때 연비는 리터 당 17~18km정도로 측정된다. 고속도로 타서 평속 80~90km로 달리면 연비는 22~25km까지 찍는다. 2016년 11월 기준으로 서울 시내 버스 요금이 기본 요금 1,200원에 10km 초과 시 5km 마다 100원씩 가산되고 경유가 리터 당 대략 1,200~1,300원이니까 연비만 놓고 보면 버스 요금보다 저렴하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2016/11/c4-cactus-fuel-efficient.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;연비 효율을 높이려는 노력이 곳곳에서 보인다. 먼저 차가 멈추면 엔진을 껐다가 출발할 때 다시 켜는 기능을 들 수 있다. 차량 동작을 완전히 끈 게 아니라 엔진만 끄고, 제동 페달에 발을 떼는 순간 빠르게 다시 시동을 건다. 반응성이 좋아서 불편하진 않다. 하루에 두세 시간 정도 운전하면 에코 유지 시간이 몇 십 분 정도 된다. 몇 십 분 주행을 안 한 셈이니 꽤 연류를 아낀 것이다.&lt;/p&gt;

&lt;h4 id=&quot;2-디자인&quot;&gt;2. 디자인&lt;/h4&gt;

&lt;p&gt;눈에 띄는 디자인이다. 선이 또렷하고 야무지게 생겼다. 특히 얼굴이 재밌게 생겨서 사람들이 흘깃 눈길 한 번씩은 보낸다. (｀^´) 이렇게 생겼달까?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2016/11/c4-cactus-front.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;자동차 외관에 플라스틱류 소재가 이렇게 많이 사용된 건 처음 본다. 그 유명한(?) 옆면 에어범퍼도 그렇고, 차 전면부나 후면부 곳곳에도 다소 말랑한 플라스틱 소재가 붙어 있다. 좋고 나쁘고를 떠나서 특이하긴 하다. 색깔도 다양하고 강렬한데, 외형이 워낙 특이해서 난 무난하게 흰색을 골랐다. 흰색이 예쁘다.&lt;/p&gt;

&lt;p&gt;내부 인테리어도 아늑하고 귀여운 편이다.&lt;/p&gt;

&lt;h4 id=&quot;3-공간-크기&quot;&gt;3. 공간, 크기&lt;/h4&gt;

&lt;p&gt;차체는 작은 편이다. 키나 덩치가 큰 사람에겐 다소 좁게 느껴질 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2016/11/c4-cactus-size.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그런데 안쪽 공간은 생각보다 여유롭다. 넓다기 보다는 여유감이 있어 답답하지 않다는 뜻이다. 앞좌석은 자잘한 조작 장치를 버튼식으로 바꾸고 대시보드 디스플레이에 몰아 넣어서 변속 레버 부근 공간이 여유롭다. 보조석은 에어백을 상단으로 옮기고, 앞쪽 가방식 수납 공간에 소지품을 넣을 수 있다.&lt;/p&gt;

&lt;p&gt;뒷좌석은 다소 좁게 느껴질 여지가 있는데, 자잘한 장치를 쳐내서 공간이 깔끔하고(휑하고) 전방과 상향 시야가 탁 트여서 심리상 편안함을 준다. 하지만 키가 큰 사람이 앉기엔 좁은 건 어쩔 수 없다. 뒷좌석엔 isofix 방식인 유아 카시트를 두 대 장착할 수 있으며, 고리 구멍이 표시되어 있어 연결하기 쉽다. 카시트 두 개 놓으면 뒷좌석은 사실상 공간이 남지 않는다.&lt;/p&gt;

&lt;p&gt;트렁크는 생활 물품을 담고 다니기 괜찮은 정도이며 넓은 편은 아니다. 나는 유모차, 자동차 용품 등을 넣고 다니는데, 장 본 물품을 상자 하나에 담아서 트렁크에 담을 정도는 된다. 유모차를 넣고 다니기엔 괜찮지만, 유모차를 싣고 장을 많이 본 날엔 좁다.&lt;/p&gt;

&lt;p&gt;뒷좌석 창문은 바깥쪽으로 살짝 열린다. 싫어하는 사람이 꽤 있을 것 같은데, 난 오히려 마음에 든다. 뒷좌석엔 유아 카시트 장착하고 꼬맹이를 앉히기 때문에 아예 꼬맹이가 활짝 열지 못하는 게 마음 편하다. 아이가 타지 않을 때에는 대부분 나 혼자 차를 타거나 동승자 한 명이 보조석에 앉기 때문에 뒷좌석 창문 열 일이 없다. 뒷좌석 창문이 아래로 열리지 않아서 뒷좌석 문짝 안쪽의 수납 공간이 넓다. 어느 정도로 넓냐면 하루 외출하는 데 쓸 아이 기저귀, 소형 우유팩, 간식통을 담을 수 있다. 아이가 용변을 봐서 돌돌 만 기저귀 서너 개는 넉넉히 들어간다.&lt;/p&gt;

&lt;h4 id=&quot;4-에어범퍼&quot;&gt;4. 에어범퍼&lt;/h4&gt;

&lt;p&gt;예쁜 외관에 눈에 띄게 전혀 다른 재질로 된 에어범퍼가 차 옆면에 꽤 넓게 자리잡고 있다. 내 차는 흰색이고 에어범퍼는 검정색인데, 흰색 몸체는 유광이고 에어범퍼는 무광이라 더 이질감이 크다. 딱 문콕 당할 위치에 에어범퍼가 있어서 문콕 스트레스가 거의 사라진다. 실제로 문콕을 몇 번 당한 것 같은데, 에어범퍼와 바퀴 부근 플라스틱류 소재에 찍힌 자국이 생겼더라. 차체 철판 면은 깨끗하고.&lt;/p&gt;

&lt;p&gt;차 옆면이 어딘가에 닿을 때 가장 먼저 에어범퍼가 닿아서 차체 흠집에 대응할 여지가 있다. 좁은 공간을 우회전하며 들어가다 차 오른쪽 부위가 입구 기둥에 닿는 사고(?)가 발생한 적이 있다. 차체가 뭔가에 닿는 느낌이 들자마자 더 진입하지 않고 후진해서 차를 뺐는데, 에어범퍼가 닿아서 차체엔 아무런 흠집이 생기지 않았다. 에어범퍼가 없었다면 흠집이 생겼거나 최악의 경우 찌그러졌을 것이다.&lt;/p&gt;

&lt;h4 id=&quot;5-편의-기능&quot;&gt;5. 편의 기능&lt;/h4&gt;

&lt;p&gt;크루즈 기능을 처음 써봤는데 설명으로 들었을 때보다 편했다. 일정 속도로 꾸준히 달리는 장거리 이동 중에 무척 유용했지만, 피곤한 운전 상황은 도심 운전인데 도심 안에서는 쓸모가 없어서 아쉬웠다. 크루즈 기능을 쓰면서 자동운전 기능을 더 기대하게 됐다. 다음 차는 자동운전 기능이 있는 걸로 사야겠다.&lt;/p&gt;

&lt;p&gt;주유구는 차 열쇠로 열어야 한다. 실내에서 원격으로 열지 못한다. 이건 호불호가 갈리지 않을 것 같다. 매우 불편하다. 열쇠를 빼서 주유원에게 주면 시동이 꺼졌으므로 창문을 닫지 못한다. 그래서 직접 주유하는 셀프 주유소를 이용하는 편인데, 그래도 싫다.&lt;/p&gt;

&lt;p&gt;하드웨어 조작 장치가 몇 개 없다. 대부분 대시보드에 터치 방식으로 옮겨 넣었다. 그래서 공간이 여유로운데, 날씨가 추워지면 터치를 제대로 인식 못하는 경우가 있다. 운전 중엔 가능한 다른 조작을 해서는 안 되긴 하지만 그래도 운전 중에 냉난방을 조절하는 등 뭔가를 조작하는 경우가 왕왕 있는데, 화면 터치로 해야해서 불편한 경우가 생기곤 한다.&lt;/p&gt;

&lt;p&gt;변속 관련 하드웨어 조작 장치도 마찬가지여서 변속 막대가 아예 없다. 대신 운전(D), 후진(R), 정차(N) 변속 제어를 큼직한 버튼 세 개가 맡는다. 발렛 파킹하는 사람들이 당황하곤 한다.&lt;/p&gt;

&lt;p&gt;벤치식 좌석과 패브릭 시트(?)가 꽤 편안하다. 몸이 푹 잠기는 편안함은 아니고 배기는 부위 없이 안정된 편안함이다.&lt;/p&gt;

&lt;p&gt;창문을 세척할 때 분무액은 와이퍼에서 직접 분사하는 방식인데, 세척액이 시야를 가리는 시간이 매우 짧다. 처음엔 세척액이 제대로 분무되지 않은 줄 알 정도이다.&lt;/p&gt;

&lt;p&gt;Apple Carplay 기능이나 Android Auto 기능을 지원하지 않는다. 아쉽다.&lt;/p&gt;

&lt;h4 id=&quot;6-주행&quot;&gt;6. 주행&lt;/h4&gt;

&lt;p&gt;내가 좋아하는 소리를 내진 않는다. 난 조용하고 얌전한 차를 좋아하며, 다소 묵직한 운전감을 선호한다. 이 차는 가볍다. 차체가 가벼운 편이기도 하지만, 엔진 소리나 운전감이 좋게 말하면 경쾌하고 나쁘게 말하면 가볍다. 차가 가볍다보니 고속 주행 시 바닥에서 올라오는 진동과 소리가 크다. 더욱이 정차 시 에코 상태로 전환되어 엔진이 꺼져서 아주 조용한 상황을 경험하게 되기 때문에 더 비교된다.&lt;/p&gt;

&lt;p&gt;완전 자동 변속 장치가 아니고, 수동 변속을 기반으로 자동 변속을 해주는 변속 방식이다. 연비는 좋은데, 변속될 때 차가 꿀렁거리는 수동 변속의 단점을 안고 있다. 잘 운전하면(?) 꿀렁거림을 줄일 수 있지만, 변속 중 꿀렁거리는 상황을 피하기 힘든 경우도 있다. 1단으로 오르막길 오르는데 RPM이 상승해서 2단으로 바뀌면 순간 꿀렁, 그런데 곧 힘이 부쳐서 다시 1단으로 바뀌면 또 꿀렁. 고속도로에서 6단으로 달리던 중 추월하려고 가속 페달을 밟으면 RPM이 부족해서 5단으로 변속되어 꿀렁, 근데 평지라서 금방 RPM이 진정되면 다시 6단으로 바뀌어서 또 꿀렁. 수동 변속 차량을 오래 운전해서 수동 변속을 좋아하는데도 이 변속 패턴은 짜증나곤 한다.&lt;/p&gt;

&lt;p&gt;보기보다 힘이 괜찮다. 수동 변속 특유의 RPM 장난질로 튀어나가는 힘도 제법이고, 시속 130km까지는 뻗어나가는 힘도 괜찮다. 근데 고속 주행에 적합한 차는 아니긴 하다.&lt;/p&gt;

&lt;p&gt;방향 전환과 제동하는 느낌도 묵직해서 밀리지 않아 안전감 있다. 급곡선을 돌 때는 차 중안 부근이, 급제동을 걸 때는 차 엉덩이 부근이 땅으로 꾹 눌리는 느낌이 든달까? 주행감은 상당히 가벼워서 과속 방지턱도 퉁퉁 튀듯 넘는 기분이 드는데, 방향 전환과 제동은 묵직해서 비교되어 재밌다. 상대적으로 묵직한 게 아니라 정말 묵직하다. 새 차라 그런가? 마음에 든다.&lt;/p&gt;

&lt;p&gt;사람은 자신의 몸이 움직이는 공간을 인지하고 있다. 부딪히지 않고 좁은 틈을 지나갈 수 있는지, 줄넘기를 하는 저 사람과 어느 정도 떨어져야 안전한지 무의식 중에 파악한다. 운전석에 앉으면 자신의 몸을 기준으로 인식된 개인 공간이 차체만큼 확장된다. 마치 차체가 내 몸이 된 것처럼. 이 인지와 실제 차체와 동기화되는 비율이 높을수록 마음이 편하고 안정되는데, 동기화 수준을 떨어뜨리는 요소가 몇 가지 있다. 운전석 기준으로 사각, 후사경에서 인식되는 차 뒷쪽 공간과 실제 차 엉덩이 위치의 위치 차이, 운전석에서 보이는 후드(보닛) 거리와 실제 후드 길이 차이 등이다. 이 차는 내 체형에 잘 맞아서 시야가 좋다. 차체가 SUV에 비해선 낮고, 세단보다는 아주 조금 더 높아서 운전석 높이가 적당하다. 그리고 사각(죽은 시야각)이 거의 없다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>책, Flask 기반의 파이썬 웹 프로그래밍 소감</title>
    <link href="/2016/07/book-python-web-programming-with-flask/"/>
    <updated>2016-07-08T01:00:00+09:00</updated>
    <id>/2016/07/book-python-web-programming-with-flask</id>
    <content type="html">&lt;p&gt;Flask 입문서가 국내 집필서로 나왔다. &lt;a href=&quot;http://www.aladin.co.kr/shop/wproduct.aspx?ItemId=83637353&quot;&gt;Flask 기반의 파이썬 웹 프로그래밍&lt;/a&gt;인데 국내 집필서로는 처음으로 보인다.&lt;/p&gt;

&lt;p&gt;Flask는 경량 웹 프레임웍이다. 경량이라지만 꼭 필요한 건 갖춰져 있어서 바퀴 재발명하는 재미(?)를 만끽하기에도 좋고, 유연해서 확장하기도 좋다. 나도 애용하는데, 한 가지 아쉬운 점이 있고 한 가지 궁금한 점이 있다.&lt;/p&gt;

&lt;p&gt;아쉬운 점은 공식 문서가 불친절하다는 것이다. 방향 제시 수준으로만 설명하고 나머지는 알아서 하라는 식이다. 그래서 종종 flask 소스 코드를 까보곤 하며, 내가 VIM이나 Sublime text를 쓰다가 PyCharm을 쓰게 된 것도 구현체 이동 기능으로 Flask 소스 코드를 편하게 까보기 위해서이다. 문서 보다 Flask 소스 코드 보는 경우가 더 많다. 그래서 Python으로 웹 프로그래밍에 입문하려는 사람에겐 Django를 추천한다. 도구 자체를 익히기엔 Flask가 간결해서 좋지만, 입문자가 독학하는 데 도움이 될 만한 친절한 문서가 많지 않다.&lt;/p&gt;

&lt;p&gt;궁금한 점은 다른 사람은 어떻게 구조를 잡고 쓰고 있는가 이다. 자기 입맛대로 쓰면 그만인 웹 프레임웍이긴 하지만, 그래도 궁금하긴 하다. &lt;a href=&quot;https://github.com/teampopong/pokr.kr&quot;&gt;팀 포퐁의 pokr 소스 코드&lt;/a&gt;를 본 뒤로는 더 궁금해졌다. Django는 구조가 그래도 고만고만한 경향이 있는데, Flask는 정말 다양하겠다는 생각이 들었다.&lt;/p&gt;

&lt;p&gt;이 책은 두 가지 중 하나는 꽤 충족시켜 준다. 공식 문서보다 친절한데 그렇다고 막 장황하지도 않다. 공식 문서를 보고 “설명이 이게 끝?”이라 생각이 든다면, 이 책은 거기서 한 수준 정도 더 설명한다. 설명을 하는 기반 코드가 대체로 공식 문서에 나온 예제이고 거의 동일한데, 그래서 좋은 점은 공식 문서를 볼 때 좀 더 친근하게 느낄 것이고 정석(?) 활용을 학습한다는 점이다. 아쉬운 점은 내가 궁금해하는 걸 해소하진 않는다는 점이다.&lt;/p&gt;

&lt;p&gt;Flask이든 Django이든 잘 활용하려면 각 도구가 지향하는 철학이나 방향을 공감하고 이해해야 한다고 본다. 이 책은 그런 공감을 일으키기엔 얕지만, 얕아서 편하게 읽기에 좋다. 자취생을 위한 간편 요리법을 다루는 책 같다. 입문자를 위한 책인지는 잘 모르겠고, 웹 프로그래밍을 해본 사람이 Flask에 얼른 입문해서 써먹을 때 더 유용해 보인다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;이 책은 출판사 &lt;a href=&quot;http://www.jpub.kr&quot;&gt;제이펍&lt;/a&gt;에서 내게 증정해준 것이다. 내게 리뷰 같은 걸 요구하지 않고 보내준 것이지만, 국내에 Flask를 다루는 국내 집필서가 없어서 반가운 마음에 나 스스로 쓴 비대가성 글이다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>프로그램 짜는 세탁소집 첫째 아들.</title>
    <link href="/2016/06/who-starts-up-o2o-service/"/>
    <updated>2016-06-06T07:00:00+09:00</updated>
    <id>/2016/06/who-starts-up-o2o-service</id>
    <content type="html">&lt;p&gt;오프라인 영역에서 이뤄지던 세차, 세탁, 주차, 배달 등 다양한 서비스가 O2O(online to offline) 서비스로 등장하고 있다. 창업자나 창업팀을 보면 자신이 하던 오프라인 직업에 IT 기술을 접목하거나 창업자가 IT 분야 개발자인데 특정 오프라인 분야의 덕후인 경우가 많다. 온라인과 오프라인을 함께 이해하고 활용할 줄 알고 접목하기 때문에 기존 온라인에서만 혹은 오프라인에서만 일을 하던 사람과 다른 접근을 하거나 좀 더 빠른 실행이 가능한 것이라 본다.&lt;/p&gt;

&lt;p&gt;스스로 판과 규칙을 짜는 주도성을 갖는 경향이 강한 온라인 분야와는 달리 오프라인 영역은 오랜 세월 쌓인 사용자 경험칙이 강하다. 오프라인 특유의 사용자 경험칙은 대를 이어온 손맛과 비슷하다. 감성 영역이란 얘기다. 그 감성은 세대나 정서 차이로 취향에 안 맞기도 하지만, 요는 기계가 엄청나게 많은 차원으로 학습해도 파악하기 어려운 미세한 감성 영역을 이해하고 접근한다는 데 있다.&lt;/p&gt;

&lt;p&gt;그래서 나는 다음 세대 O2O 서비스는 세탁소집 아들, 자동차 정비소 딸, 미용실 둘째 아들이 일으키는 모습을 기대한다. 단, 조건이 있다. 이들은 소프트웨어를 이해하고 당연히 활용한다는 사고 체계를 갖춰야 한다. 무선인 전화기, 터치 인터페이스, 사회 관계는 온라인에서도 지속된다는 당연한 인식이 기본으로 깔려 있으며, 기계가 할 일을 쉽게 시키는 사고 방식과 체계를 갖춘 세대. 세탁소에서 바삐 움직이는 &lt;strong&gt;콤퓨타&lt;/strong&gt; 세탁기를 보며 콤퓨타와 세탁 너머를 상상할 수 있는 세대.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>프로그래밍 입문자를 위한 몇 가지 조언</title>
    <link href="/2016/01/how-to-study-programming/"/>
    <updated>2016-01-13T10:45:00+09:00</updated>
    <id>/2016/01/how-to-study-programming</id>
    <content type="html">&lt;p&gt;2014년 11월 4일부터 &lt;a href=&quot;http://www.fastcampus.co.kr/&quot;&gt;패스트캠퍼스&lt;/a&gt;에서 웹 서비스 개발을 주제로 강의하여 얼마 전에 네 번째 기수를 마쳤다. Python과 Django를 이용해 웹 서비스 개발 공정을 겪는 것이 커리큘럼 주제인데, 1기에 대한 이야기는 &lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;Python과 Django 강의&lt;/a&gt;라는 글로 작성했다. 이번 글에선 어떻게 Python과 Django를 공부하면 좋을 지 1년 간 강의하며 고민했고 몇 가지 원리에 대해서는 정리되어 공유해 본다. 내가 강의한 주제가 Python과 Django, 그리고 웹 프로그래밍이어서 그렇지, 프로그래밍에 대한 공부 방법이라고 해도 무방하다고 생각한다.&lt;/p&gt;

&lt;h3 id=&quot;강의-개요&quot;&gt;강의 개요&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;이름 : &lt;a href=&quot;http://www.fastcampus.co.kr/dev_camp_wsd/&quot;&gt;웹 서비스 개발 캠프&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;주제
    &lt;ul&gt;
      &lt;li&gt;Python과 Django를 강사의 경험을 담아 심도있게 다룬다.&lt;/li&gt;
      &lt;li&gt;웹 서비스를 개발하는 공정을 Back-end 중심으로 경험하며 웹 프로그램을 개발하여 배치(deployment)한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수강 대상자
    &lt;ul&gt;
      &lt;li&gt;다른 언어나 프레임워크를 써봤고, Django에 입문하려는 사람&lt;/li&gt;
      &lt;li&gt;Python이나 웹 프로그래밍 중급 과정에 진입하려는 사람&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;강의 시간
    &lt;ul&gt;
      &lt;li&gt;1기 : 90시간&lt;/li&gt;
      &lt;li&gt;2기 : 64시간&lt;/li&gt;
      &lt;li&gt;3기 : 48시간&lt;/li&gt;
      &lt;li&gt;4기 : 40시간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;손으로-반복-반복-그리고-또-반복&quot;&gt;손으로 반복, 반복, 그리고 또 반복&lt;/h3&gt;

&lt;p&gt;뭔가 만들려 하면 막막해서 시작을 떼지 못하겠다는 입문자가 무척 많다.&lt;/p&gt;

&lt;p&gt;책을 보거나 강의를 듣는 중엔 다 안다. 물어보면 대답도 한다. 근데 막상 코드를 짜라고 하면 힘겨워한다. 질문하며 코드 흐름을 자연스레 유도하면 대답은 하는데, 그 대답을 코드로 옮기질 못하기도 한다. 커리큘럼 초반엔 잘 따라오는데, 중반에 접어들어 학습하는 주제와 범위가 늘면 눈에 띄게 힘들고 어려워 하는 경우도 있다.&lt;/p&gt;

&lt;p&gt;그에 반해 빈 파일에 코드를 채워넣는 걸 주저하지 않는 사람도 있다. 원래 다른 분야에서 프로그래밍을 했거나 다른 언어로 웹 프로그래밍을 한 사람이야 그렇다 쳐도, 사실상 입문자여서 이 강의를 듣기엔 다소 무리하는 수강자인데도 곧잘 코드를 작성한다. 입문자여서 프로그래밍이나 Python, Django에 대한 지식과 경험이 부족하여 이론을 설명하면 이해는 못하는데 코드는 어쨌든 작성해 간다. 심지어 자신이 무슨 코드를 짰는지 이해하지 못하면서도 말이다.&lt;/p&gt;

&lt;p&gt;이런 차이는 반복량에 있다. 눈으로는 코드와 이론을 알지만, 손은 모른다. 프로그래밍 언어도 언어의 한 종류이다. 아무리 영어 단어나 문법을 외워도 말을 하지 않고 글을 쓰지 않으면 표현하기 어렵다. 마찬가지로 눈으로 이론을 공부하고 코드를 읽어도 손으로 코드를 짜지 않으면 코딩은 되지 않는다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://scienceon.hani.co.kr/34106&quot;&gt;시시하고 아는 코드라도 직접 손으로 쳐야 한다. 한 번 쳐보고 넘어가지 말고, 다양하게 응용하며 여러 번 쳐봐야 한다&lt;/a&gt;. 손에도 코드를 새겨야 한다. 코드를 손에 새기는 가장 쉽고 좋은 방법은 딱 세 개이다. 반복, 반복, 그리고 또 반복하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;복습&quot;&gt;복습&lt;/h3&gt;

&lt;p&gt;학습한 건 가능한 빨리 복습해야 학습 효과가 크다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;우선 배운 걸 그대로 따라하는 복습을,&lt;/li&gt;
  &lt;li&gt;시간이 있다면 응용하는 복습을&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하는 게 좋다. 나는 첫 번째 복습 방법을 교재에 반영하여 수강자가 수업 내용을 떠올리도록 유도한다. 큰 주제 별로 교재를 구성하되, 작은 주제는 강의 흐름에 맞추어 배치하여 스토리텔링을 하려 한다. 중요한 내용은 몇 번 반복 등장하고, 가끔 다른 주제가 먼저 등장하기도 하는데 교재를 한 장 한 장 읽어 나가도록 구성하여 교재를 그대로 따라 복습하면 강의를 떠올리도록 한 것이다.&lt;/p&gt;

&lt;p&gt;두 번째 복습 방법은 과제를 내서 유도한다. 아무리 의지가 가득해도 입문자에게 독학이 어려운 이유 중 하나는 학습한 내용을 응용하여 복습하기 어렵기 때문이다. 과제 풀이를 열심히 한 수강자는 커리큘럼 후반으로 가며 다루는 주제가 다양해 질수록 과제를 푼 효과를 보는데, 새 주제가 등장하더라도 이전 주제와 연계되거나 응용하기 때문이다. 책이나 교육 웹사이트로 학습하는데 실습 문제나 과제가 나오면 꼭 풀기를 권한다.&lt;/p&gt;

&lt;p&gt;강의 시간은 기수를 거듭할수록 줄어 들었는데, 수강자가 복습하지 않으면 강의 시간이 아무리 길어도 별 효과가 없었기 때문이다. 실제로 4기는 강의 시간이 1기의 반도 안 됐지만 진도와 강의 주제의 깊이는 별 차이가 없었다.&lt;/p&gt;

&lt;h3 id=&quot;질문&quot;&gt;질문&lt;/h3&gt;

&lt;p&gt;공부하고 있는 걸 머리에 선명하게 새기는 또 다른 방법은 학습자가 질문하는 것인데, 복습한 사람이 질문을 하는 편이었다. 내 경우는 과제에 함정(?)을 심어 놓는데, 과제를 제출한 사람 중 함정에 대해 질문한 사람 없이 문제를 잘 해결했다면 수강자들이 진도를 잘 따라오고 있다고 판단하여 수업에서 좀 더 깊은 내용을 다루거나 더 많은 양을 다룬다. 함정에 빠진 피해자는 질문을 하게 되는데, 함정에 빠진데다 질문을 하여 답변을 받기 때문에 기억에 남을 가능성이 높다고 본다.&lt;/p&gt;

&lt;p&gt;독학할 때엔 이러한 피드백 과정을 겪기 어렵다. 혼자서 웹에서 검색하여 문제를 해결해도 문제의 앞뒤 맥락을 이해하기 보다는 답에 초점을 맞추어 넘어가기 십상이기 때문이다. 나는 문제에 부딪혀서 스스로 해결하지 못하여 웹에서 해결 방법을 찾으면 반드시 따로 갈무리 하여 쌓아놓고, 일정 시간 뒤에 갈무리 한 자료들의 범주를 나누고 복기한다. 갈무리 당시엔 개별 문제이지만, &lt;a href=&quot;http://scienceon.hani.co.kr/33793&quot;&gt;시간이 흘러 쌓인 문제들을 분류해놓고 보면 각 문제가 서로 연결되어 문제 상황과 맥락을 이해&lt;/a&gt;하게 된다.&lt;/p&gt;

&lt;p&gt;질문과 답변을 주고 받는 소통은 피드백 과정이기도 하다. &lt;a href=&quot;http://scienceon.hani.co.kr/33829&quot;&gt;피드백을 받지 못하면 실력은 늘지 않는다&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;질문하고 답을 찾자. 질문 하려면 질문할 준비가 돼야 한다. 그 준비란 바로 실습과 복습이다.&lt;/p&gt;

&lt;h3 id=&quot;함께-공부하기&quot;&gt;함께 공부하기&lt;/h3&gt;

&lt;p&gt;팀은 1기 때부터 계속 조성하려 애썼다. 1기 때는 강사 입장에선 운좋게도 수강자들이 스스로 팀을 짜서 팀 프로젝트를 수행했었다. 2기 때는 권유를 해봤고, 3기 때는 오리엔테이션 때 아예 팀 조성 시간을 갖고 팀 프로젝트를 정해주었으며 팀장에겐 작은 사례(?)를 하기도 했다. 4기 때는 3기 때와 거의 같으나 수시로 팀 프로젝트를 상기시키며 좀 더 독려했다. 하지만 팀 운영은 잘 안 됐다. 복습과 과제 수행도 버거운데 팀 활동은 더 시간 내기 어려웠다는 수강자가 많았다.&lt;/p&gt;

&lt;p&gt;하지만 여전히 팀 조성과 활동을 하도록 관심을 투자할 가치가 있다. 팀은 아니지만 지인과 나란히 앉아 공부하거나 서로 도우며 공부한 수강자는 혼자서 수업에 참여한 수강자에 비해 실패나 난관에 흔들리는 정도가 덜했다. 질문도 왕성하게 하고 붙임성 있게 다른 수강자와 교류하며 수업에 왕성하게 참여하는 수강자는 그 자신이 수업에서 거둬가는 게 많기도 하지만, 다른 수강자에게도 영향을 많이 끼친다. 그런 참여 활동이 &lt;a href=&quot;http://scienceon.hani.co.kr/33907&quot;&gt;당사자 뿐만 아니라 동료 수강자에게 피드백을 주고 받는 과정&lt;/a&gt;이기 때문이다.&lt;/p&gt;

&lt;p&gt;입문자일 수록 함께 공부할 동료를 구하라고 권하고 싶다.&lt;/p&gt;

&lt;h3 id=&quot;마치며&quot;&gt;마치며&lt;/h3&gt;

&lt;p&gt;재작년에 &lt;a href=&quot;http://blog.hannal.com/2014/5/principles_for_efficient_training/&quot;&gt;근거기반훈련 워크샵에 참석해 효과적 훈련의 원리&lt;/a&gt;를 배웠다. 막상 내게 제대로 활용하지 않았는데, 1년 여 강의하며 몇 가지 원리는 뚜렷하게 효과를 체험했다. &lt;a href=&quot;http://www.fastcampus.co.kr/dev_camp_wpb/&quot;&gt;웹 프로그래밍 입문&lt;/a&gt;과 &lt;a href=&quot;http://www.fastcampus.co.kr/dev_camp_wsd/&quot;&gt;웹 서비스 개발&lt;/a&gt;을 주제로 강의하긴 하지만, 꼭 내 강의가 아니더라도 혼자 공부하거나 지인과 공부하며 활용하면 충분히 효과를 볼 것이라 생각한다.&lt;/p&gt;

</content>
  </entry>
  
  <entry>
    <title>2016년을 맞이하며 20년 전 판을 생각하다</title>
    <link href="/2016/01/hello_2016/"/>
    <updated>2016-01-02T16:00:49+09:00</updated>
    <id>/2016/01/hello_2016</id>
    <content type="html">&lt;h3 id=&quot;게임-개발&quot;&gt;게임 개발&lt;/h3&gt;

&lt;p&gt;20년 전에 첫 게임을 만들었다. 내 &lt;a href=&quot;http://blog.hannal.com/profile/&quot;&gt;필명인 한날은 이 게임 이름에서 비롯&lt;/a&gt;된 것이다. 어설프고 재미없고 허섭했지만, 내 게임을 만들어 친구들과 내 게임 얘기를 나누었다. 내 고교 시절 생활기록부를 보니 장래 희망이 컴퓨터 프로그래머라 적혀 있었다. 당시엔 게임 개발이라는 직업이 사회에 인식되기 전이라서 편의상 게임 개발자 대신 컴퓨터 프로그래머라 적은 것인데, 20년이 지난 지금은 정말 게임 개발자가 아니라 컴퓨터 프로그래머가 되어 있다.&lt;/p&gt;

&lt;p&gt;가끔 언제 다시 게임 업계에 돌아오냐는 안부성 질문을 받곤 한다. 게임 업계에 돌아갈 지 안 갈 지 아직은 모르겠다. 하지만 난 게임을 만들어 왔고, 앞으로도 게임을 만들 것이다.&lt;/p&gt;

&lt;h3 id=&quot;홈페이지&quot;&gt;홈페이지&lt;/h3&gt;

&lt;p&gt;20년 전에 내 홈페이지를 처음 열었다. 1997년부터는 게임 개발, 프로그래밍 등을 주제로 운영하다 &lt;a href=&quot;https://web.archive.org/web/19991012051013/http://dimanche.co.kr/index-kr.html&quot;&gt;1998년에 도메인을 사서 나 나름대로 브랜드&lt;/a&gt;를 만들고 유지하려 했다. 꾸준하진 않지만 완전히 놓지 않고 계속 운영해 온 지난 20년을 스스로 대견하게 여긴다.&lt;/p&gt;

&lt;p&gt;나를 표현하는 익숙한 방법이 내 홈페이지 또는 블로그이다. 앞으로도 내 공간에 글을 쓸 것이다.&lt;/p&gt;

&lt;h3 id=&quot;판&quot;&gt;판&lt;/h3&gt;

&lt;p&gt;작더라도 내 판을 만들어야 한다는 생각을 해왔다. 아무리 잘하고 위협스러워도 남의 판에서는 승산이 없다. 판의 주인이 판을 엎고 새 규칙을 짜면 그만이다. 주인이 판 엎지 않게 아양 떨고 비위 맞추고, 규칙을 바꾸면 바꿀 규칙을 예측하며 그 판에 길들여지면 더이상 희망이 없다. 차라리 판의 주인이 한 짓에 삐쳐서 그 판을 떠나는 게 낫다. 내 판을 만들어 사람들이 내 판에 들어오고, 그 판을 키워야 한다. 그래야 내가 바라는 진정한 독립이 이뤄진다.&lt;/p&gt;

&lt;p&gt;하지만 난 그동안 준비되지 않았으며 진심으로 독립을 갈망한 것이 아니었을지도 모른다는 생각을 했다. 내 판을 만들어야 한다고 주창했지만 정작 말로만 고민했을 뿐, 실행할만큼 고민하지 않았다. 여전히 남의 판에 기대어 마이너 버전 수준에서 내 몸뚱아리를 업그레이드 하려 아둥바둥거렸다.&lt;/p&gt;

&lt;p&gt;앞으로 3~4년 뒤부터는 갈수록 내 판을 만드는 데 들이는 노력이 비싸질 것이라 예상한다. 내 판을 만드는 비용이 비싸질수록 포기할 가능성이 커지고, 포기하는 그때부터 남의 판에서 움직이는 장기말이자 노예가 될 것이다.&lt;/p&gt;

&lt;p&gt;20년 전에 막연히 내 판을 만들어야 한다는 생각을 한 것 같다. 능력도 없으면서 게임 만들자며 사람들 꼬셔 게임개발팀을 만들었고, 하루 방문자가 몇 명이더라도 내 홈페이지에 내 글을 남기려 했다. 내 스토리를 갖고 싶었고 만들려 애썼다. 길들여지지 말자. 내 판의 20년 전 원시형을 잊지 말고 포기하지 말자.&lt;/p&gt;

&lt;p&gt;그렇게 다짐하며 각오를 세운다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>내 개발 환경.</title>
    <link href="/2015/12/my-dev-envs/"/>
    <updated>2015-12-18T14:45:00+09:00</updated>
    <id>/2015/12/my_dev_envs</id>
    <content type="html">&lt;p&gt;프로그래밍 입문자, 또는 새로 프로그래밍이나 도구에 입문하는 사람과 얘기를 나누다 보면 다른 사람, 기왕이면 그 언어나 도구에 익숙한 사람이 사용하는 개발 환경을 무척 궁금해 한다는 걸 느꼈다. 그냥 공식 홈페이지에 있는 걸 내려 받아서 설치하면 되는 거 아닌가? 생각하며 관련 자료를 찾아보니 사람들은 공식 홈페이지에 소개되지 않은 방법으로 개발 환경을 꾸린다는 걸 발견하면 더 혼란이 빠져서 아예 입문 자체를 부담스러워 하는 사람도 많다.&lt;/p&gt;

&lt;p&gt;그래서 내가 쓰는 개발 환경을 정리해 본다.&lt;/p&gt;

&lt;h3 id=&quot;공통-환경&quot;&gt;공통 환경&lt;/h3&gt;

&lt;h4 id=&quot;pc&quot;&gt;PC&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Macbook Pro 13인치 (2015년 early)&lt;/li&gt;
  &lt;li&gt;Macbook Pro 15인치 (2014년 early)&lt;/li&gt;
  &lt;li&gt;iMac 20인치 (2011년 mid)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;운영체제&quot;&gt;운영체제&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;주 환경 : OS X. 내가 주로 활동하는 분야는 윈도우 보다는 리눅스나 OS X에서 개발하기 더 편하다.&lt;/li&gt;
  &lt;li&gt;보조 환경 : Ubuntu. 주로 실 서버에 올리기 전에 시험 동작하려고 사용하거나 라즈베리 파이용 뭔가를 만들 때 쓰는 환경이지만, 집에 있는 리눅스 박스가 저사양이라서 평소엔 잘 안 쓴다.&lt;/li&gt;
  &lt;li&gt;쉘(shell) : bash를 주로 써왔지만, 2015년 11월부터 zsh을 쓰고 있다. &lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh&quot;&gt;oh-my-zsh&lt;/a&gt;을 쓰고 설정은 기본값으로 쓰고 있으며, plugin만 git, virtualenv, virtualenvwrapper를 설정했다.&lt;/li&gt;
  &lt;li&gt;터미널은 OS X에 기본 내장된 것을 사용한다.&lt;/li&gt;
  &lt;li&gt;맥 패키지는 &lt;a href=&quot;http://brew.sh&quot;&gt;Homebrew&lt;/a&gt;로 관리한다.&lt;/li&gt;
  &lt;li&gt;파일, 디렉터리 구조는 &lt;a href=&quot;http://mama.indstate.edu/users/ice/tree/&quot;&gt;tree&lt;/a&gt;을 쓴다. OS X는 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew install tree&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;원격에 있는 파일은 &lt;a href=&quot;https://www.gnu.org/software/wget/&quot;&gt;wget&lt;/a&gt;로 받는다. OS X는 &lt;code class=&quot;highlighter-rouge&quot;&gt;brew install wget&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;글꼴&quot;&gt;글꼴&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;http://sourcefoundry.org/hack/&quot;&gt;Hack&lt;/a&gt;을 사용한다.&lt;/p&gt;

&lt;h4 id=&quot;vcs-client&quot;&gt;VCS client&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; : 기본 클라이언트를 터미널에서 쓴다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.sourcetreeapp.com/&quot;&gt;sourcetree&lt;/a&gt; : 커밋이 복잡하게 꼬였을 때 쓰지만, 느려서 가끔 쓴다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/karan/joe&quot;&gt;joe&lt;/a&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 파일을 다룰 때 쓴다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;python&quot;&gt;Python&lt;/h3&gt;

&lt;h4 id=&quot;에디터&quot;&gt;에디터&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jetbrains.com/pycharm/&quot;&gt;PyCharm&lt;/a&gt; : 2015년 11월부터 쓰고 있다. 아직 익숙하지 않다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.sublimetext.com/&quot;&gt;Sublime text 3&lt;/a&gt; : 평소에 주로 써왔는데, 최근엔 조금씩 빈도를 줄이고 있다.
    &lt;ul&gt;
      &lt;li&gt;SublimeLinter + Python Flake8 lint : 코드 검사기는 &lt;a href=&quot;https://flake8.readthedocs.org&quot;&gt;Flake8&lt;/a&gt;을 SublimeLinter에 연동해 쓴다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;VIM : 급히 간단히 편집할 때 쓴다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;python-관련&quot;&gt;Python 관련&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Python 3, 2.7 : 최근엔 3 버전으로 시작하는 프로젝트가 늘고 있지만, 아직은 2.7로 동작하는 게 더 많다.&lt;/li&gt;
  &lt;li&gt;PyPy : 실 사용 환경에서 사용하고 있긴 한데, 여전히 제한되게 쓰고 있다.&lt;/li&gt;
  &lt;li&gt;virtualenv/virtualenvwrapper : 주로 사용하는 Python 환경 격리 도구.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;golang&quot;&gt;Golang&lt;/h3&gt;

&lt;h4 id=&quot;에디터-1&quot;&gt;에디터&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jetbrains.com/idea/&quot;&gt;IntelliJ IDEA&lt;/a&gt; : 2015년 11월부터 쓰고 있다. 느려서 답답한데, 편하긴 하다. golang 정식 plugin이 출시되었다.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.sublimetext.com/&quot;&gt;Sublime text 3&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;plugin : Goimports, GoSublime, SublimeLinter-contrib-golint&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;문서와-자료&quot;&gt;문서와 자료&lt;/h3&gt;

&lt;h4 id=&quot;편집&quot;&gt;편집&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;markdown : 로컬에서 문서를 작성하는 경우엔 대부분 markdown으로 작성한다. 편집은 &lt;a href=&quot;https://atom.io/&quot;&gt;Atom&lt;/a&gt;으로 하는데, 한글이 많으면 어느 에디터든 무척 느려지기 때문에 코딩 할 땐 사용하지 않는 Atom을 markdown 문서 편집용으로 쓴다.&lt;/li&gt;
  &lt;li&gt;google drive : 다른 사람과 협업하거나 공유해야 하는 경우에 사용한다. 주로 google docs, spreadsheet.&lt;/li&gt;
  &lt;li&gt;dropbox paper : 베타판부터 쓰고 있긴 한데, dropbox의 최근 선택과 집중 행보를 보자니 오래 유지 안 하고 종료할 것 같아서 이젠 별로 사용하지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;자료-관리&quot;&gt;자료 관리&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;웹 스크래핑 : 모바일 환경에선 &lt;a href=&quot;https://getpocket.com/&quot;&gt;pocket&lt;/a&gt;, PC 환경에선 pocket과 &lt;a href=&quot;http://www.devontechnologies.com/products/devonthink/overview.html&quot;&gt;devonthink&lt;/a&gt;로 스크랩한다. evernote + clearly를 썼는데, 갈수록 구려져서 안 쓴다.&lt;/li&gt;
  &lt;li&gt;PDF : devonthink에 담아서 관리하며, dropbox에도 올려서 모바일 환경에서 접근한다.&lt;/li&gt;
  &lt;li&gt;bookmark : 구글 크롬에 북마크한다. 구글 계정 동기화를 해놔서 내가 사용하는 장비 모두와 북마크 동기화가 늘 되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;이외&quot;&gt;이외&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Google chrome : 느리고 뚱뚱하지만, 구글 계정 연동이 편해서 여전히 쓴다.&lt;/li&gt;
  &lt;li&gt;이외 도구는 가장 기본 설정대로 사용한다.
    &lt;ul&gt;
      &lt;li&gt;R Studio, Apache spark, React, Jupyter, …&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>10. 이용자가 올린 사진 목록 보기</title>
    <link href="/2015/10/start_with_django_webframework_10/"/>
    <updated>2015-10-02T12:45:00+09:00</updated>
    <id>/2015/10/start_with_django_webframework_10</id>
    <content type="html">&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/category/start-with-django-webframework/&quot;&gt;날로 먹는 Django 웹프레임워크 강좌 목차&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;마지막 갱신일시 : 2017년 1월 30일 1시 10분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;사진을 게시하였으니 저장된 사진을 가져와 나열하는 기능이 필요합니다. 로그인한 이용자가 사진을 게시하는 기능을 만들었으니 이용자 단위로 사진을 가져와 보여주는 개인 프로필 공간을 만들어 보겠습니다. 이번 편은 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 이용해 데이터를 찾는 방법을 다룹니다.&lt;/p&gt;

&lt;h3 id=&quot;개인-프로필-기능용-앱-만들기&quot;&gt;개인 프로필 기능용 앱 만들기&lt;/h3&gt;

&lt;p&gt;강좌 &lt;a href=&quot;http://blog.hannal.com/2014/8/start_with_django_webframework_01/&quot;&gt;1편 Pystagram 기획&lt;/a&gt;에서 개인 프로필 공간(이하 프로필 페이지)은 다음 기능을 포함합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;간단한 소개&lt;/li&gt;
  &lt;li&gt;팔로잉, 팔로워&lt;/li&gt;
  &lt;li&gt;이용자가 올린 사진&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;프로필 페이지를 비롯해서 이용자의 대외 노출 기능은 모두 별도 Django 앱을 만들어 다루겠습니다. 꼭 앱으로 나누지 않아도 되지만, 같은 목적이나 맥락끼리 기능을 구분하여 앱으로 묶어 관리하는 게 낫습니다. 터미널 쉘에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py&lt;/code&gt; 파일을 이용해 앱을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python manage.py startapp profiles
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;url-패턴-만들기&quot;&gt;URL 패턴 만들기&lt;/h3&gt;

&lt;p&gt;이번 편에서는 “이용자가 올린 사진”을 나열하는 기능을 구현하는데, 페이지 URL은 &lt;code class=&quot;highlighter-rouge&quot;&gt;/users/&amp;lt;이용자 ID&amp;gt;/&lt;/code&gt; 패턴입니다. 이전 편까지는 URL 패턴을 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일이 있는 시작 패키지의 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에 등록하였는데, 프로필 공간에 들어가는 기능이나 페이지에 필요한 URL은 따로 분리하여 연결하는 방식을 쓰겠습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리에 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 만들어서 이 모듈에 프로필 관련 URL을 등록하고, 시작 패키지의 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에서는 앱 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;include()&lt;/code&gt; 함수로 포함시키는 방식입니다. Django Admin에 사용하는 URL 패턴을 이 방식으로 포함시켜 사용합니다.&lt;/p&gt;

&lt;p&gt;먼저 시작 패키지, 그러니까 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일이 있는 디렉터리에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 열고 다음 내용을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.conf.urls import include

urlpatterns = [
    # 생략
    url(r'^users/', include('profiles.urls')),
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;include&lt;/code&gt; 함수를 이용해 &lt;code class=&quot;highlighter-rouge&quot;&gt;users/&lt;/code&gt;로 시작하는 URL들은 &lt;code class=&quot;highlighter-rouge&quot;&gt;'profiles.urls'&lt;/code&gt;에 있는 포함시킵니다. 이는 실제로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 만들어 사용하는데, 좀 더 정확하게는 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;urlpatterns&lt;/code&gt; 이름을 갖는 객체를 만들어야 합니다.&lt;/p&gt;

&lt;p&gt;이번엔 include 대상인 &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles.urls&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;urlpatterns&lt;/code&gt;를 만듭니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 새로 만들고, 그 안에 다음 내용을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.conf.urls import url

from . import views

urlpatterns = [
    url(
        r'^(?P&amp;lt;username&amp;gt;[\w.@+-]+)/$',
        views.profile,
        name='profile'
    ),
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그동안 봐온 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 내용과 다를 바 없습니다. 단지 &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱에서 사용하는 URL을 &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles.urls&lt;/code&gt;에 만든 것 뿐입니다.&lt;/p&gt;

&lt;h3 id=&quot;뷰-함수와-템플릿-뼈대-만들기&quot;&gt;뷰 함수와 템플릿 뼈대 만들기&lt;/h3&gt;

&lt;p&gt;이번엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱의 &lt;code class=&quot;highlighter-rouge&quot;&gt;views.py&lt;/code&gt; 파일에 &lt;code class=&quot;highlighter-rouge&quot;&gt;profile()&lt;/code&gt; 뷰 함수를 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.shortcuts import render

def profile(request, username):
    ctx = {}
    return render(request, 'profile.html', ctx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에서 이용자 이름(ID) 문자열을 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;으로 받아내어 뷰 함수로 전달하도록 하였으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;profile()&lt;/code&gt; 함수에서도 두 번째 인자로 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;을 지정해야 합니다.&lt;/p&gt;

&lt;p&gt;뷰 함수는 뼈대부터 만들 것이므로 뷰 함수에서 사용할 뷰 함수 템플릿을 &lt;code class=&quot;highlighter-rouge&quot;&gt;'profile.html'&lt;/code&gt;로 지정합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일은 앱용 템플릿 디렉터리(&lt;code class=&quot;highlighter-rouge&quot;&gt;APP_DIRS&lt;/code&gt;)에 만듭니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;templates&lt;/code&gt; 디렉터리를 새로 만들고, 그 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일을 만든 뒤 다음 내용을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% extends 'layout.html' %}

{% block content %}
profile page
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;드디어 뼈대를 만들었습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py runserver&lt;/code&gt;로 개발용 내장 웹서버를 구동하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8000/users/hannal/&lt;/code&gt;과 같은 URL로 접근하면 프로필 페이지가 나타납니다.&lt;/p&gt;

&lt;p&gt;하지만, 이 글 내용 그대로 수행했다면 반갑지 않은 화면이 나타납니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hannal.com/assets/uploads/2015/10/10-not_exist_template_file_error.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일이 존재하지 않는다는 내용입니다. 이 파일이 분명히 있는데 저 오류가 발생한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt; 설정에 우리가 새로 생성한 &lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱을 추가하지 않아서 그렇습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일은 &lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;profiles&lt;/code&gt; 앱 디렉터리&lt;/strong&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;templates&lt;/code&gt; 디렉터리에 있습니다. 앱 디렉터리에 있다는 의미는 Django가 앱 디렉터리라는 걸 인식해야 한다는 의미입니다. 그래서 &lt;code class=&quot;highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt;에 추가하는 것입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt; 항목에 &lt;code class=&quot;highlighter-rouge&quot;&gt;'profiles'&lt;/code&gt; 문자열을 추가하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'photos',
    'profiles',
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;접속한-페이지의-이용자-정보-가져오기&quot;&gt;접속한 페이지의 이용자 정보 가져오기&lt;/h3&gt;

&lt;p&gt;접속한 프로필 페이지의 이용자 이름은 뷰 함수에 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt; 인자로 전달됩니다. 우리는 Django에서 제공하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델을 사용하므로 이 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt; 모델 필드를 검색(lookup)하는 데 사용하여 이용자를 찾습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.shortcuts import get_object_or_404
from django.contrib.auth import get_user_model

def profile(request, username):
    User = get_user_model()
    user = get_object_or_404(User, username=username)
    ctx = {
        'user': user,
    }

    return render(request, 'profile.html', ctx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get_user_model()&lt;/code&gt; 함수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 모듈의 &lt;code class=&quot;highlighter-rouge&quot;&gt;AUTH_USER_MODEL&lt;/code&gt; 설정 항목을 기준으로 Django 프로젝트가 사용하는 이용자 모델을 가져옵니다. 자세한 내용은 &lt;a href=&quot;http://blog.hannal.com/2015/06/start_with_django_webframework_08/&quot;&gt;8편 로그인, 로그아웃 하기&lt;/a&gt; 편을 참고하세요.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get_object_or_404()&lt;/code&gt; 함수는 지정한 모델과 검색 조건으로 데이터를 가져오려 해보고 없으면 HTTP 404 오류를 일으키는 함수입니다. 두 종류 인자를 필요로 하는데, 첫 번째 인자는 데이터를 찾고 가져올 대상 모델 클래스를 받고, 나머지 인자는 검색에 사용합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;get_object_or_404(User, username=username)&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt; 모델 필드의 값이 뷰 함수에 인자로 전달된 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;과 같은 것을 찾는 내용입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;/users/hannal/&lt;/code&gt; URL로 접근하면 뷰 함수의 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt; 인자의 값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;'hannal'&lt;/code&gt; 문자열이므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;get_object_or_404(User, username='hannal')&lt;/code&gt;을 실행합니다. 이 함수는 데이터 하나를 특정 지어 반한하므로 여러 데이터가 조건에 해당되선 안 됩니다. 데이터가 없는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.http&lt;/code&gt; 모듈에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Http404&lt;/code&gt; 예외 오류를 일으킵니다.&lt;/p&gt;

&lt;p&gt;데이터가 있는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;에 할당하고, 이 객체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿에 템플릿 맥락 요소(context)로 전달하며, 템플릿 안에서 템플릿 변수로 사용할 이름은 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;입니다.&lt;/p&gt;

&lt;p&gt;이번엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일을 수정합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% extends 'layout.html' %}

{% block content %}
&amp;lt;h1&amp;gt;님의 프로필 페이지&amp;lt;/h1&amp;gt;

&amp;lt;ul&amp;gt;
{% for photo in user.photo_set.all %}
    &amp;lt;li&amp;gt;&amp;lt;img src=&quot;&quot; /&amp;gt;&amp;lt;/li&amp;gt;
{% empty %}
    &amp;lt;li&amp;gt;게시한 사진이 없습니다.&amp;lt;/li&amp;gt;
{% endfor %}
&amp;lt;/ul&amp;gt;

{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;눈 여겨 볼 부분은 &lt;code class=&quot;highlighter-rouge&quot;&gt;user.photo_set.all&lt;/code&gt;입니다. 이 부분은 Python 코드로 표현하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;user.photo_set.all()&lt;/code&gt;입니다. Django 템플릿 엔진은 Python의 함수나 클래스와 같이 호출 가능한(callable) 객체를 템플릿 안에서 소괄호를 쳐서 직접 호출하는 걸 허용하지 않습니다. 객체 이름이나 메서드 이름만 명시하면 Django가 대상의 자료형을 검사해서 호출 가능한 객체인 경우 대신 호출하여 수행합니다. 소괄호를 사용하지 못하므로 함수나 메서드에 인자를 전달하지도 못합니다. 인자를 전달하려면 Django 템플릿 필터나 태그를 직접 만들어 사용해야 합니다.&lt;/p&gt;

&lt;h3 id=&quot;queryset-객체&quot;&gt;QuerySet 객체&lt;/h3&gt;

&lt;h4 id=&quot;연관-객체-참조-related-objects-reference&quot;&gt;연관 객체 참조 (related objects reference)&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;user.photo_set.all()&lt;/code&gt;는 접속한 프로필 페이지의 이용자(&lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;)가 소유한(own) 모든 사진 게시물을 가져오는 코드입니다. 하나씩 살펴 보겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;는 뷰 함수에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; &lt;strong&gt;모델&lt;/strong&gt; 클래스로 데이터를 가져와 연결시켜(mapping) Python 인스턴스 객체로 생성한 것입니다. 그런데 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델은 우리가 앞서 만든 &lt;code class=&quot;highlighter-rouge&quot;&gt;photo&lt;/code&gt; 앱의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델이 &lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;로 연결되어 있습니다. 이용자 한 명이 사진을 여러 개 가지므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델이 1, &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델은 다수(n) 관계라서 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델 기준으로는 1:N(OneToMany) 관계입니다.&lt;/p&gt;

&lt;p&gt;이 관계가 중요한데요. Django는 모델이 관계(relationship)를 맺고 있으면 연결 당한 쪽에 &lt;strong&gt;연관 객체 참조 속성&lt;/strong&gt;이라는 특별한 속성을 만듭니다. 연결하는 쪽은 모델 필드로 연결하는 대상 모델을 가리키고 있지만, 연결 당하는 쪽은 Python 코드상으로는 알 도리가 없습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델을 놓고 보면, &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;user = models.ForeignKey(settings.AUTH_USER_MODEL)&lt;/code&gt; 모델 필드를 만들어서 연결하는 모델이 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델이라는 것이 드러나지만, &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델엔 아무런 조치를 취하지 않으므로 Python 코드만으로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델이 자신을 연결하는지는 알지 못합니다. 하지만 Django는 모델 관계를 파악하여 연결 당하는 쪽에 연결하는 모델에 대한 접근 경로를 객체 속성(attribute)으로 만들어 줍니다.&lt;/p&gt;

&lt;p&gt;일 대 다(&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;)나 다 대 다(&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;) 관계는 연결 당하는 특정 데이터에 연결하는 쪽의 여러 데이터가 관계를 맺습니다. 이처럼 &lt;strong&gt;1&lt;/strong&gt;쪽에 &lt;strong&gt;N&lt;/strong&gt;으로 연결되는 경우, &lt;strong&gt;1&lt;/strong&gt;쪽에 N쪽 모델 이름을 참조하여 속성을 만듭니다. 이 속성은 따로 지정하지 않으면 N쪽 모델 이름을 소문자 Snake case 표기로 만들고 &lt;code class=&quot;highlighter-rouge&quot;&gt;_set&lt;/code&gt;을 덧붙인 이름을 갖습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델로 놓고 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델의 인스턴스 객체에 &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt; 속성이 만들어 집니다.&lt;/p&gt;

&lt;h4 id=&quot;queryset-객체-1&quot;&gt;QuerySet 객체&lt;/h4&gt;

&lt;p&gt;연관 객체 참조 속성은 Django 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;은 이름에서 드러나듯이 Query 집합(set)입니다. Django model manager는 크게 두 종류 객체를 반환하는데, 하나는 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체이고 다른 하나는 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체가 아닌 객체입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;엔 다음과 같은 특징이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Model manager의 API를 포함 (정확히는 QuerySet API를 manager가 상속 받아 사용)&lt;/li&gt;
  &lt;li&gt;꼬리에 꼬리를 무는 연산(evaluation). 일명 chaining 연산.
    &lt;ul&gt;
      &lt;li&gt;단 QuerySet(또는 model manager)의 메서드가 반환하는 객체가 QuerySet이어야 함.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;지연 평가 연산과 캐쉬 처리&lt;/li&gt;
  &lt;li&gt;순서열(&lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;tuple&lt;/code&gt;) 연산 지원&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이러한 특성은 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;의 역할에 기인합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;은 사용자의 요청을 받아 질의(query)를 생성합니다. 이 요청이 데이터베이스에서 데이터를 가져와야만 하는 것이면 생성한 질의를 데이터베이스로 보냅니다. 그렇지 않으면 생성한 질의는 그대로 보관한 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 복제하여 새로 반환합니다. 이 경우 반환한 객체도 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체이므로 또 다시 model manager API를 이용해 요청을 보낼 수 있습니다. 이런 과정을 반복합니다. 데이터베이스에 질의를 보내 데이터를 가져오면 그 데이터를 보관해두며, 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체의 데이터를 사용하는 경우 보관된 데이터를 사용합니다. 몇 번을 접근하더라도 보관된 데이터를 그대로 재사용합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;지연 평가 연산 : 데이터베이스에 접근해야 할 때까지 질의를 보내지 않고 질의를 생성해 조합하며 쌓는 동작&lt;/li&gt;
  &lt;li&gt;캐쉬 처리 : 보관한 데이터를 재사용해 데이터에 접근할 때마다 데이터베이스에 질의를 요청하지 않음&lt;/li&gt;
  &lt;li&gt;chaining : &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 반환하는 경우, 그 객체를 이용해 요청을 이어나감&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;우리가 앞서 만든 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델 클래스로 예를 들겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;qs = Photo.objects.filter(pk__in=(1, 2, 3, 4, ))  # 첫 번째 요청.
qs = qs.filter(content__contains='te')  # 두 번째 요청.
qs.count()  # 세 번째 요청.
qs.count()  # 네 번째 요청.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;총 네 번 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체의 메서드를 호출했습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;첫 번째 요청은 &lt;code class=&quot;highlighter-rouge&quot;&gt;pk&lt;/code&gt; 모델 필드(기본키, primary key)가 1, 2, 3, 4인 데이터를 가져오라는 질의를 만듭니다. SQL 질의문으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT * FROM &quot;photos_photo&quot; WHERE &quot;photos_photo&quot;.&quot;id&quot; IN (1, 2, 3, 4)&lt;/code&gt;을 생성한 채 일단 기다립니다.&lt;/li&gt;
  &lt;li&gt;두 번째 요청은 &lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt; 모델 필드로 &lt;code class=&quot;highlighter-rouge&quot;&gt;te&lt;/code&gt; 문자열을 포함하는 데이터를 가져오라는 질의를 만듭니다. 기존 질의문을 조합한 만드므로 질의문은 &lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT * FROM &quot;photos_photo&quot; WHERE (&quot;photos_photo&quot;.&quot;id&quot; IN (1, 2, 3, 4) AND &quot;photos_photo&quot;.&quot;content&quot; LIKE %te% ESCAPE '\')&lt;/code&gt;가 됩니다. 여전히 데이터베이스에 질의를 보내지 않고 기다립니다.&lt;/li&gt;
  &lt;li&gt;세 번째 요청은 여태까지 누적한 탐색(lookup) 조건에 해당하는 모든 데이터의 개수를 가져오는 &lt;code class=&quot;highlighter-rouge&quot;&gt;count()&lt;/code&gt; 메서드입니다. 데이터베이스에 질의를 보내야만 확인 가능한 데이터입니다. 여태까지 만든 질의문을 비로소 데이터베이서에 요청합니다.&lt;/li&gt;
  &lt;li&gt;네 번째 요청도 &lt;code class=&quot;highlighter-rouge&quot;&gt;count()&lt;/code&gt; 메서드입니다. 이미 캐쉬된 데이터가 있어서 데이터베이스에 질의하지 않고 보관하고 있는 데이터에서 개수를 가져와 반환합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;count()&lt;/code&gt; 메서드는 개수를 숫자로 반환하며, 숫자는 정수형(&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;) 객체여서 더이상 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체의 특성을 사용하지 못합니다. 이렇게 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 반환하지 않는 model manager API는 다음과 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;메서드&lt;/th&gt;
      &lt;th&gt;반환하는 객체&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;조건에 해당하는 특정 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;first()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 보관된 데이터 중 첫 번째 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;last()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 보관된 데이터 중 마지막 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;earliest()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;인자로 전달해 지정한 모델 필드를 기준으로 가장 첫 번째 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;latest()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;인자로 전달해 지정한 모델 필드를 기준으로 가장 마지막 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;count()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; 객체&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 보관된 질의를 기준으로 개수를 가져오거나 보관된 데이터의 개수를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exists()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; 객체&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 보관된 질의 또는 보관된 데이터를 기준으로 데이터가 존재하는 지 여부를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get_or_create()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;조건에 해당하는 특정 데이터를 가져오고 없으면 인자로 전달한 내용으로 데이터를 저장한 후 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;update_or_create()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;모델 클래스의 인스턴스 객체&lt;/td&gt;
      &lt;td&gt;특정 데이터를 수정하고, 그 데이터가 없으면 인자로 전달한 내용으로 데이터를 저장한 후 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이외에도 몇 가지 더 있는데 강좌 진행 중 사용하면 자세히 다루겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체를 반환하는 메서드도 살펴 보겠습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;메서드&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;전체 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;인자로 전달한 조건에 해당하는 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;exclude()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;인자로 전달한 조건에 해당하지 않는 데이터를 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;order_by()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 모델 필드로 정렬하여 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reverse()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;에 저장된 데이터를 뒤집어서 가져온다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;select_related()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;N:1(ManyToOne, &lt;code class=&quot;highlighter-rouge&quot;&gt;ForeginKey&lt;/code&gt;)으로 연결된 데이터를 함께 가져온다. 데이터베이스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;JOIN&lt;/code&gt; 처리.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;prefetch_related()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;N:N(&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;)으로 연결된 함께 데이터를 가져온다. 데이터베이스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;JOIN&lt;/code&gt; 처리&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;using()&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 데이터베이스에서 데이터를 가져온다. 기본은 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt;로 지정된 데이터베이스.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이번 편에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;order_by()&lt;/code&gt;을 다루며, 다른 메서드는 사용할 때 자세히 다루겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;filter-메서드&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt; 메서드&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt;을 설명하려고 먼 길 다녀왔네요. &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt; 속성은 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체입니다. 그냥 객체는 아니고 조건이 걸려있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델의 인스턴스 객체에서 사용하는데, 이 말은 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델로 가져온 이용자 데이터를 담고 있는 인스턴스 객체, 즉 특정 이용자에 연결된 &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt;입니다. 이를 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델로 풀어쓰면 다음 코드와 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;user = User.objects.get(username='hannal')
photos = Photo.objects.filter(user=user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;이 &lt;code class=&quot;highlighter-rouge&quot;&gt;'hannal'&lt;/code&gt;인 이용자를 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;에 할당하고, 소유주(&lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;)가 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;인 모든 사진 게시물(&lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt;)을 찾아서 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos&lt;/code&gt;에 할당합니다. 간단히 말해 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;이 &lt;code class=&quot;highlighter-rouge&quot;&gt;'hannal'&lt;/code&gt;인 이용자의 모든 사진 게시물을 가져오는 것이지요.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt; 메서드는 검색(lookup) 조건을 &lt;a href=&quot;http://blog.hannal.com/2015/03/keyword-only-arguments_and_annotations_for_python3/&quot;&gt;키워드 인자&lt;/a&gt;를 받습니다. 인자 이름(key)는 모델 필드의 탐색 방식이고 전달하는 객체(value)는 검색할 값입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;filter(content='hannal')&lt;/code&gt;로 키워드 인자를 전달하면 모델 필드 &lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt;의 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;hannal&lt;/code&gt;과 일치하는 데이터를 찾습니다.&lt;/p&gt;

&lt;p&gt;하지만 검색 방식이 이렇게 단순하진 않습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;hannal&lt;/code&gt; 문자열과 일치하는 게 아니라 &lt;code class=&quot;highlighter-rouge&quot;&gt;hannal&lt;/code&gt; 문자열을 포함한다든지 지정한 숫자보다 큰 값을 갖는 데이터를 찾는 식으로 다양한 검색 방식이 필요한데, Django는 모델 필드 이름에 &lt;code class=&quot;highlighter-rouge&quot;&gt;__탐색키워드&lt;/code&gt;를 덧붙인 인자 이름으로 이러한 검색을 지원합니다. 예를 들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;hannal&lt;/code&gt; 문자열을 포함하는 데이터를 찾는 조건이라면 &lt;code class=&quot;highlighter-rouge&quot;&gt;filter(content__contains='hannal')&lt;/code&gt;와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;__contains&lt;/code&gt;를 모델 필드인 &lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt;에 덧붙입니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;탐색 키워드&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;contains&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 문자열을 포함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;in&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;리스트나 튜플에 담긴 값들에 해당&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gt&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 값을 &lt;strong&gt;초과&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gte&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 값 &lt;strong&gt;이상&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lt&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 값 &lt;strong&gt;미만&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lte&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 값 &lt;strong&gt;이하&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;year&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 연도. &lt;code class=&quot;highlighter-rouge&quot;&gt;DateField&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;DateTimeField&lt;/code&gt; 필드에 한함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;month&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 월. &lt;code class=&quot;highlighter-rouge&quot;&gt;DateField&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;DateTimeField&lt;/code&gt; 필드에 한함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;day&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;지정한 일. &lt;code class=&quot;highlighter-rouge&quot;&gt;DateField&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;DateTimeField&lt;/code&gt; 필드에 한함&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;탐색 키워드 역시 자주 쓰는 것만 소개하였으며, 이외 탐색 키워드는 사용할 때 자세히 다루겠습니다.&lt;/p&gt;

&lt;p&gt;여러 탐색 조건을 지정해도 되는데, 함수에 키워드 인자 여러 개를 넣는 방법과 동일합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Photo.objects.filter(user=user, content__contains='te')
Photo.objects.filter(user=user).filter(content__contains='te')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;두 코드는 동일한 역할을 합니다. 이 코드는 사진 게시물의 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;이고(AND), &lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;'te'&lt;/code&gt; 문자열이 포함된 모든 데이터를 가져옵니다. 쉼표로 구분해 여러 키워드 인자를 전달하든 &lt;code class=&quot;highlighter-rouge&quot;&gt;filter()&lt;/code&gt; 메서드를 체인으로 반복해서 부르든 동일하게 &lt;code class=&quot;highlighter-rouge&quot;&gt;AND&lt;/code&gt; 조합으로 데이터를 찾습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;OR&lt;/code&gt; 조합으로 찾으려면 별도 조치를 취해야 하는데, 나중에 다루겠습니다.&lt;/p&gt;

&lt;p&gt;정리하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델 클래스의 인스턴스 객체에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt; 속성은 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델 클래스와 연결되어 만들어졌으며, &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체로 만들어졌는데 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt; 속성이 속한 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 인스턴스 객체의 데이터를 기반으로 합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_set&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt; 객체이므로 체인 연결하듯이 후속 &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;의 메서드를 사용할 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;user.photo_set.all()&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;all()&lt;/code&gt; 메서드를 쓴 것입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo.objects.filter(user=user).all()&lt;/code&gt;과 동일한 역할을 합니다.&lt;/p&gt;

&lt;h3 id=&quot;사진-정렬하여-나열하기&quot;&gt;사진 정렬하여 나열하기&lt;/h3&gt;

&lt;p&gt;프로필 페이지에서 사진은 저장된 등록된 순서대로 나열됩니다. 별도로 지정하지 않으면 기본키(primary key)를 기준으로 하여 순서대로 나열되기 때문입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;QuerySet&lt;/code&gt;으로 가져오는 데이터를 정렬하는 방법은 크게 두 가지입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;order_by()&lt;/code&gt; 메서드로 정렬할 모델 필드 이름 지정&lt;/li&gt;
  &lt;li&gt;모델에 정렬할 기본(default) 기준을 지정&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;order_by()&lt;/code&gt;는 &lt;a href=&quot;http://blog.hannal.com/2015/03/keyword-only-arguments_and_annotations_for_python3/&quot;&gt;위치 인자&lt;/a&gt;로 정렬 기준으로 삼을 모델 필드 이름을 문자열로 받습니다. 여러 개를 지정하면 정렬 우선순위에 따라 정렬합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Photo.objects.order_by('created_at')  # created_at 순서대로.
Photo.objects.order_by('-created_at')  # created_at 역순으로.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;첫 번째 구문은 전체 사진 게시물을 &lt;code class=&quot;highlighter-rouge&quot;&gt;created_at&lt;/code&gt; 모델 필드 기준으로 하여 순서대로 가져옵니다. 역순으로 가져오려면 모델 필드 이름 앞에 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;를 덧붙이면 되며 두 번째 구문이 &lt;code class=&quot;highlighter-rouge&quot;&gt;created_at&lt;/code&gt; 역순으로 정렬하는 것입니다. 만약 &lt;code class=&quot;highlighter-rouge&quot;&gt;created_at&lt;/code&gt;, 즉 생성일시가 완전히 동일한 경우에는 기본키 역순으로 정렬하도록 하려면 인자를 추가하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Photo.objects.order_by('-created_at', `-pk`)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;무작위 순서로 정렬하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo.objects.order_by('?')&lt;/code&gt;처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;'?'&lt;/code&gt;를 인자로 전달하면 되는데, 주의할 점은 상당히 느립니다. 되도록이면 쓰지 않길 권합니다.&lt;/p&gt;

&lt;p&gt;모델에 정렬할 기본 기준을 정하려면 모델에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; 클래스를 만들고, &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; 클래스 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ordering&lt;/code&gt; 속성을 만들어 정렬할 모델 필드 이름을 나열하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Photo(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL)
    image = models.ImageField(upload_to='%Y/%m/%d/orig')
    filtered_image = models.ImageField(upload_to='%Y/%m/%d/filtered')
    content = models.TextField(max_length=500, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ('-created_at', '-pk', )

    # 후략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;나중에 자세히 다루겠지만, 템플릿에서는 함수 호출하듯이 소괄호(&lt;code class=&quot;highlighter-rouge&quot;&gt;(&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;)&lt;/code&gt;)를 사용하여 객체 호출을 직접 하지 못합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;profile.html&lt;/code&gt; 템플릿 파일에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;{% for photo in user.photo_set.all %}&lt;/code&gt;와 같은 구문을 &lt;code class=&quot;highlighter-rouge&quot;&gt;{% for photo in user.photo_set.order_by('-created_at', '-pk') %}&lt;/code&gt;와 같이 쓰지 못합니다. 그래서 정렬하려면 뷰 함수에서 정렬한 데이터를 별도 변수에 할당하여 이 변수를 템플릿에 전달해야 합니다. 예를 들겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# photos/views.py

def profile(request, username):
    User = get_user_model()
    user = get_object_or_404(User, username=username)
    photos = user.photo_set.order_by('-created_at', '-pk')

    ctx = {
        'user': user,
        'photos': photos,
    }

    return render(request, 'profile.html', ctx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{# photos/templates/profile.html #}
&amp;lt;ul&amp;gt;
{% for photo in photos %}
    &amp;lt;li&amp;gt;&amp;lt;img src=&quot;&quot; /&amp;gt;&amp;lt;/li&amp;gt;
{% empty %}
    &amp;lt;li&amp;gt;게시한 사진이 없습니다.&amp;lt;/li&amp;gt;
{% endfor %}
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;또는 모델에서 정렬 기준을 정의하여 따로 &lt;code class=&quot;highlighter-rouge&quot;&gt;order_by()&lt;/code&gt; 메서드를 쓰지 않더라도 기본으로 지정한 기준대로 정렬되도록 처리해도 됩니다.&lt;/p&gt;

&lt;p&gt;이 강좌에서는 명시한 정렬 기준이 코드에 드러나는 차원에서 뷰 함수에서 정렬하겠습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;강좌 10편을 마칩니다. 정말 오랜만에 연재했네요. 이제 몇 회만 더 연재하면 강좌 1부가 끝납니다. 강좌 분량이 많아지면서 처음 계획을 바꿨습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1부 : Django 전반을 두루 겪기&lt;/li&gt;
  &lt;li&gt;2부 : 1부에서 다루지 않은 내용을 더 자세히 다루기&lt;/li&gt;
  &lt;li&gt;3부 : 앞단 만들고 배포하기&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;올해 안에 1부를 마치도록 노력하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hannal/start_with_django_webframework/tree/l10&quot;&gt;10편까지 진행한 전체 소스 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
  </entry>
  
  <entry>
    <title>Celery의 Subtask 기능을 이용하여 Chord와 Chain로 작업 분산해서 다루기</title>
    <link href="/2015/07/celery_chord_and_chain/"/>
    <updated>2015-07-08T17:25:00+09:00</updated>
    <id>/2015/07/celery_chord_and_chain</id>
    <content type="html">&lt;h3 id=&quot;웹페이지-긁어오기&quot;&gt;웹페이지 긁어오기&lt;/h3&gt;

&lt;p&gt;Python으로 웹페이지 열 곳을 긁어와서 하나로 합쳐 보겠습니다. Python HTTP library인 &lt;a href=&quot;http://docs.python-requests.org/en/latest/&quot;&gt;requests&lt;/a&gt;를 쓰면 아주 간단합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import requests

def fetch_page_by_url(url):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text

merged_text = []
for i in range(0, 10):
    result = fetch_page_by_url(
        'http://localhost:8000/{}.html'.format(i)
    )

    if result is not None:
        merged_text.append(result)

do_something(merged_text.join(''))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;celery를-이용해-비동기-방식으로-긁어오기&quot;&gt;Celery를 이용해 비동기 방식으로 긁어오기&lt;/h3&gt;

&lt;p&gt;차례대로 긁어오니 열 개 페이지를 모두 가져오기 전까지는 결과를(&lt;code class=&quot;highlighter-rouge&quot;&gt;do_something(merged_text.join(''))&lt;/code&gt;) 확인하지 못합니다. &lt;a href=&quot;https://docs.python.org/3/library/multiprocessing.html&quot;&gt;multiprocessing&lt;/a&gt;을 이용해 여러 프로세스로 동시성을 확보해도 되지만, 분산 작업 큐 시스템인 &lt;a href=&quot;http://celery.readthedocs.org/en/latest/&quot;&gt;Celery&lt;/a&gt;로 쉽고 간편하게 비동기 처리하기도 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from celery import Celery

app = Celery(__name__)

@app.task
def fetch_page_by_url(url):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text

merged_text = []
for i in range(0, 10):
    result = fetch_page_by_url.apply_async(
        'http://localhost:8000/{}.html'.format(i)
    )

    if result is not None:
        merged_text.append(result)

do_something(merged_text.join(''))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드에는 문제가 있습니다. Celery 작업 수행 객체로 장식된(decorated) &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url&lt;/code&gt; 객체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;apply_async()&lt;/code&gt; 메서드를&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 이용하여 &lt;strong&gt;비동기&lt;/strong&gt;로 작업을 수행하는데, 이 메서드가 반환하는 객체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;res.text&lt;/code&gt;가 아니라 Celery 결과 작업을 다루는 객체입니다. 게다가 비동기로 작업을 수행하고 바로 프로그램 수행 제어권을 호출자에게 반환하므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url.apply_async(...)&lt;/code&gt; 호출이 되자마자 바로 다음 구문을 수행하는데, 웹 페이지를 가져오는 작업이 끝났는지 여부는 알지 못 합니다.&lt;/p&gt;

&lt;p&gt;이 문제를 피하려면 &lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt; 메서드를 이용합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if result.get() is not None:
        merged_text.append(result)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get()&lt;/code&gt; 메서드는 비동기로 수행하는 작업 객체(&lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;)가 작업을 마치고 값을 반환하기를 &lt;strong&gt;동기식&lt;/strong&gt;으로 기다려서 반환합니다. 어?! 이렇게 할 거라면 굳이 Celery를 쓸 필요가 없지요. Celery에게 여러 작업을 맡겨서 비동기로 처리하고, 비동기로 처리한 결과를 받아다 뭔가를 하려면 다른 방법을 써야 합니다. 이 글에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;chain&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;chord&lt;/code&gt;을 사용하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;chain-기능&quot;&gt;chain 기능&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chain&lt;/code&gt; 기능은 이름에서 전해지듯이 작업을 체인처럼 줄줄이 수행합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from celery import chain

@app.task
def fetch_page_by_url(url, append_text=None):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        if append_text is None
            return res.text
        else:
            res.text + append_text

tasks = []
for i in range(0, 10):
    tasks.append(
        fetch_page_by_url.subtask(
            'http://localhost:8000/{}.html'.format(i)
        )
    )

result = chain(tasks)()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;subtask()&lt;/code&gt;는 Celery 작업 객체를 하위 작업으로 수행하는 메서드입니다&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;. &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url&lt;/code&gt; 객체를 하위 작업으로 수행하는 작업 열 개를 담아 &lt;code class=&quot;highlighter-rouge&quot;&gt;chain()&lt;/code&gt;에 전달하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;chain()&lt;/code&gt;은 순서대로 작업을 수행합니다. 각 작업이 반환하는 객체는 다음 작업자에게 인자로 전달합니다. 첫 번째 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt; 함수가 반환하는 웹페이지 문자열을 두 번째 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;는 두 번째 인자로 받는 것이죠. 그래서 두 번째 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;부터는 앞 작업자가 반환하는 결과를 넘겨 받는 것이지요.&lt;/p&gt;

&lt;p&gt;다른 예를 들어 보겠습니다. 숫자 두 개를 인자로 전달하면 두 숫자를 더하는 작업자를 쓰겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;첫 번째 셈은 1 + 1 입니다.&lt;/li&gt;
  &lt;li&gt;두 번째 셈은 첫 번째 덧셈 결과를 받아서 10을 더합니다.&lt;/li&gt;
  &lt;li&gt;세 번째 셈은 두 번째 덧셈 결과를 받아서 100을 더합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이걸 &lt;code class=&quot;highlighter-rouge&quot;&gt;chain()&lt;/code&gt;을 이용하면 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;do_chain_tasks = chain(add.s(1, 1), add.s(10), add.s(100))
do_chain_tasks()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chain()&lt;/code&gt;도 바로 작업을 수행하는 게 아니라 Celery 작업 객체를 반환하며&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;, 이 작업 객체를 실행해야 합니다. 바로 위 코드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;chain(...)()&lt;/code&gt;라는 구문을 나눈 것입니다.&lt;/p&gt;

&lt;p&gt;재밌는 점은 Celery는 비트 연산으로도 &lt;code class=&quot;highlighter-rouge&quot;&gt;chain()&lt;/code&gt; 작업 객체를 만들어 준다는 점입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(
    fetch_page_by_url.s('http://localhost:8000/0.html') |
    fetch_page_by_url.s('http://localhost:8000/1.html') |
    fetch_page_by_url.s('http://localhost:8000/2.html') |
    fetch_page_by_url.s('http://localhost:8000/3.html')
).apply_async()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;참 꼼꼼하게 만들어 놨어요. :)&lt;/p&gt;

&lt;h3 id=&quot;chord-기능&quot;&gt;chord 기능&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chain()&lt;/code&gt;을 이용해 비동기로 열 개 작업을 수행하고 그 결과를 합쳤는데, 아쉬운 마음이 듭니다. 전체 작업 자체는 분명 비동기로 시작한 게 맞지만, 웹페이지를 긁어오는 작업도 동시에 분산해서 처리하면 더 효율이 좋을 겁니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;chord()&lt;/code&gt;는 하위 작업을 동시에 수행하고, 각 작업자가 반환하는 값을 callback 실행 객체로 전달해줍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from collections import MutableSequence
from celery import chord

@app.task
def fetch_page_by_url(url):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text

@app.task
def merge_text(texts):
    assert(isinstance(texts, MutableSequence))
    return texts.join('')

tasks = []
for i in range(0, 10):
    tasks.append(
        fetch_page_by_url.s('http://localhost:8000/{}.html'.format(i))
    )

do_chain_tasks = chord(tasks)
do_chain_tasks(merge_text.s())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt; 함수가 원래대로(?) 돌아왔고, &lt;code class=&quot;highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt; 함수가 새로 추가됐습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt;는 전달받은 인자 &lt;code class=&quot;highlighter-rouge&quot;&gt;texts&lt;/code&gt;를 합치는 일을 하는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;가 반환하는 문자열을 담은 리스트형(&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;) 객체입니다. 맨 처음에 비동기로 작성한 코드에서 웹페이지 문자열을 리스트로 담은 &lt;code class=&quot;highlighter-rouge&quot;&gt;merged_text&lt;/code&gt;와 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chord()&lt;/code&gt;는 각 작업자(&lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;)가 반환하는 값을 리스트형으로 모아서 callback 객체에게 인자로 전달합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;chord()&lt;/code&gt;로 만든 Celery 작업 객체로 callback 객체를 전달할 때 인자를 지정하지 않아도 됩니다. 알아서 넣어 줍니다.&lt;/p&gt;

&lt;p&gt;근데 이 코드엔 사소하다면 사소하고 심각하다면 심각한 문제가 있습니다. 작업들을 비동기로 수행하다보니 웹페이지 문자열이 우리가 원하는 순서대로 담겨져 &lt;code class=&quot;highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt;로 전달된다는 보장이 없습니다. 작업이 먼저 끝나는 순서대로 결과가 담기니 0 - 1 - 2 - 3 … 순서가 될 지 9 - 4 - 7 - 1 순서가 될 지는 아무도 모릅니다.&lt;/p&gt;

&lt;p&gt;여러 해결책이 있겠지만, 각 작업자마다 순번을 주고, &lt;code class=&quot;highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt;는 이 순번대로 문자열을 합치면 되겠네요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@app.task
def fetch_page_by_url(url, num):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text, num

@app.task
def merge_text(texts):
    assert(isinstance(texts, MutableSequence))
    texts.sort(key=lambda x: x[1])
    return texts.join('')

tasks = []
for i in range(0, 10):
    tasks.append(
        fetch_page_by_url.s(
            'http://localhost:8000/{}.html'.format(i), i
        )
    )
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;각 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;에 두 번째 인자로 순번(&lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt;)을 전달하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt;는 받은 순번을 웹페이지 문자열과 함께 그대로 반환합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;merge_text()&lt;/code&gt;가 전달받은 &lt;code class=&quot;highlighter-rouge&quot;&gt;texts&lt;/code&gt;엔 각 &lt;code class=&quot;highlighter-rouge&quot;&gt;fetch_page_by_url()&lt;/code&gt; 결과가 &lt;code class=&quot;highlighter-rouge&quot;&gt;[(문자열, 0), (문자열, 3), ...]&lt;/code&gt; 형태로 담깁니다. 그래서 각 항목의 두 번째(&lt;code class=&quot;highlighter-rouge&quot;&gt;[1]&lt;/code&gt;) 값으로 정렬하고 나서 한 문자열로 합친 것입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://celery.readthedocs.org/en/latest/userguide/canvas.html#the-primitives&quot;&gt;Canvas: Designing Workflows : The primitives&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://celery.readthedocs.org/en/latest/userguide/tasks.html#avoid-launching-synchronous-subtasks&quot;&gt;Tasks : Avoid launching synchronous subtasks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;대개는 &lt;code class=&quot;highlighter-rouge&quot;&gt;delay()&lt;/code&gt;라는 메서드로 줄여서 수행합니다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;대개는 &lt;code class=&quot;highlighter-rouge&quot;&gt;s()&lt;/code&gt;로 줄인 메서드 이름을 씁니다. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;chain&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;chord&lt;/code&gt;는 함수처럼 생겼지만 클래스입니다. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  
  <entry>
    <title>9. 로그인한 이용자만 사진 게시물 게시하기</title>
    <link href="/2015/06/start_with_django_webframework_09/"/>
    <updated>2015-06-28T01:20:00+09:00</updated>
    <id>/2015/06/start_with_django_webframework_09</id>
    <content type="html">&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/category/start-with-django-webframework/&quot;&gt;날로 먹는 Django 웹프레임워크 강좌 목차&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;마지막 갱신일시 : 2017년 1월 30일 0시 50분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;지난 편에서는 Django 이용자 인증 체계을 알아봤으니 이번 편에서는 인증 기능을 이용하여 로그인한 이용자만 사진 게시물을 게시하는 기능을 만들어 보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;1-사진-게시물에-이용자-정보-연결&quot;&gt;1. 사진 게시물에 이용자 정보 연결&lt;/h3&gt;

&lt;h4 id=&quot;1-기본키-primary-key&quot;&gt;(1) 기본키 (Primary Key)&lt;/h4&gt;

&lt;p&gt;로그인한 이용자만 사진 게시물을 게시한다면 각 사진 게시물엔 사진을 게시한 이용자 정보를 담아야 합니다. 누가 게시한 사진인지 알아야 하니까요. 이용자 ID(&lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;)을 문자열로 담아도 되지만, 대개는 고유하며 변하지 않을 정보인 기본키(Primary Key)를 담습니다.&lt;/p&gt;

&lt;p&gt;이용자가 따로 기본키 역할을 하는 모델 필드를 지정하지 않으면 Django는 관례대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;라는 모델 필드를 알아서 만들고 이를 기본키로 사용합니다. 사진 모델인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt;로 사진 게시물 데이터를 &lt;code class=&quot;highlighter-rouge&quot;&gt;photo01&lt;/code&gt;이라는 인스턴스 객체로 할당하면 이 객체엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;라는 멤버 변수가 속성으로 존재하고 이 속성에 정수(&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;) 값이 할당되어 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; photo01 = Photo.objects.last()
&amp;gt;&amp;gt;&amp;gt; print(photo01.pk)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;모델의 인스턴스 객체엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;pk&lt;/code&gt; 속성도 존재하는데, 이 속성은 기본키를 가리키고 있습니다. 이용자가 &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; 모델 필드를 기본키로 하지 않고 &lt;code class=&quot;highlighter-rouge&quot;&gt;uuid&lt;/code&gt;라는 모델 필드를 만들어 이 필드를 기본키로 지정하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;pk&lt;/code&gt;는 이 모델 필드를 가리킵니다. 우리는 각 모델의 기본키로 설정된 모델 필드의 이름이 무엇인지 신경쓰지 않고 &lt;code class=&quot;highlighter-rouge&quot;&gt;pk&lt;/code&gt; 속성을 사용하면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;2-모델-관계-필드-relationship-fields&quot;&gt;(2) 모델 관계 필드 (relationship fields)&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델로 데이터베이스에 저장할 데이터에 이용자 모델의 기본키 값을 저장하려면 다음과 같이 하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Photo(models.Model):
    user_id = models.IntegerField()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그런 뒤에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델로 데이터를 저장하는 과정에서 이용자의 기본키 값을 &lt;code class=&quot;highlighter-rouge&quot;&gt;user_id&lt;/code&gt;에 할당하면 됩니다. 각 게시물을 게시한 이용자가 누구인지 아니까 각 사진 게시물 정보를 가져오면서 이용자 정보도 함께 가져오면 좋겠군요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.contrib.auth import get_user_model
User = get_user_model()

class Photo(models.Model):
    # 중략
    def get_user(self):
        return User.objects.get(pk=self.user_id)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드들엔 문제가 있습니다. 모델의 기본키 모델 필드가 &lt;code class=&quot;highlighter-rouge&quot;&gt;IntegerField&lt;/code&gt;가 아닌 경우에 제대로 대응하지 못하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;get_user()&lt;/code&gt; 메서드를 호출할 때마다 매번 이용자 모델에서 이용자 데이터를 탐색해 반환하며, 이용자 모델과 연결하는 모델마다 매번 저런 구현을 중복 적용해야 합니다. 이런 문제들에 대응하는 구현체를 만들어야 하는데, Django는 &lt;a href=&quot;https://docs.djangoproject.com/en/1.8/ref/models/fields/#module-django.db.models.fields.related&quot;&gt;관계 모델 필드&lt;/a&gt;로 제공합니다. 총 세 종류입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt; : 1 대 다(1 to n) 관계&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt; : 1 대 1 관계&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt; : 다 대 다(n to n) 관계&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이용자와 사진 게시물 관계로 세 관계 필드를 살펴 보겠습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;OneToOneField&lt;/code&gt;는 이용자는 오직 사진 게시물을 하나만 게시하고 소유합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;ManyToManyField&lt;/code&gt;는 이용자가 사진 게시물을 여러 개 올릴 수 있는데, 각 사진 게시물을 여러 이용자가 소유하는 게 가능합니다. 1번 사진을 Hannal 이용자 뿐만 아니라 Kay, Yuna 이용자가 소유하는 관계가 맺어지므로 소유한 누구나 사진 게시물을 변경하거나 지울 수 있습니다. 마지막으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;는 한 이용자가 여러 사진 게시물을 게시하고 소유하는 관계입니다. 우리에게 필요한 모델 관계군요. &lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;에 대한 건 본 편 “2. &lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt; 모델 필드”를 참고하시고, 연결부터 해보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;3-photo-모델에-이용자-기본키-정보-연결하기&quot;&gt;(3) &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델에 이용자 기본키 정보 연결하기&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.conf import settings

class Photo(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL)
    # 후략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt; 모델 필드(클래스)는 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.db.models&lt;/code&gt; 모듈에 있어서 다른 모델 필드처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;models&lt;/code&gt; 객체에서 접근하여 사용하면 됩니다. 첫 번째 인자로 관계 지을 모델을 모델 객체나 경로를 문자열로 전달합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;settings&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;AUTH_USER_MODEL&lt;/code&gt; 설정 항목은 현재 프로젝트에서 사용하는 인증용 이용자 모델이 위치한 경로를 문자열로 지정하고 있습니다. &lt;a href=&quot;http://blog.hannal.com/2015/06/start_with_django_webframework_08/&quot;&gt;8. 로그인, 로그아웃 하기&lt;/a&gt;편에서 이에 대한 내용을 참조하세요.&lt;/p&gt;

&lt;h5 id=&quot;마이그레이션-수행&quot;&gt;마이그레이션 수행&lt;/h5&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델이 변경됐으니 데이터베이스에 반영해야 합니다. 마이그레이션을 수행합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python manage.py makemigrations photos
You are trying to add a non-nullable field 'user' to photo without a default;
we can't do that (the database needs something to populate existing rows).
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows)
 2) Quit, and let me add a default in models.py
Select an option:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;긴 영어 문장이 나오며 뭔가를 물어 보는데 당황하지 말고 내용을 잘 살펴 보세요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;당신은 Null(&lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;)을 허용하지 않는(non-nullable) &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;라는 필드를 추가하려 하는데, 값이 주어지지 않는 경우에 기본으로 저장될 기본값(default)이 없다.&lt;/li&gt;
  &lt;li&gt;데이터베이스가 기존에 저장된 데이터(populate existing rows)에 Null 외 값을 필요로 해서 우린(Django) 이 작업을 바로 수행하지 못한다.&lt;/li&gt;
  &lt;li&gt;그러니 뭔가 조치를 취해달라.
    &lt;ol&gt;
      &lt;li&gt;이 자리에서 기본값을 제공해주든&lt;/li&gt;
      &lt;li&gt;마이그레이션 수행 과정에서 빠져 나간 뒤에 &lt;code class=&quot;highlighter-rouge&quot;&gt;models.py&lt;/code&gt;에 기본값 지정 인자(&lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt;)를 추가해달라.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 자리에서 기본값을 제공해줄테니 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;을 입력합니다. Django가 뭔가를 요구하네요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Please enter the default value now, as valid Python
The datetime module is available, so you can do e.g. datetime.date.today()
&amp;gt;&amp;gt;&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;기본값으로 유효한 Python의 객체를 입력하라는 말입니다. 일단 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;을 입력합니다.&lt;/p&gt;

&lt;p&gt;이제야 마이그레이션 수행에 필요한 마이그레이션 작업 파일이 만들어 졌습니다. 두 번째 입력한 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;은 이용자 모델의 기본키 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;을 뜻합니다. 기존에 저장한 사진 게시물의 이용자를 기본키 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;인 이용자로 지정한 것입니다. 만약, 기존에 소유자가 없는 사진 게시물을 위해 별도 이용자를 만들어서 연결하고자 한다면, 그 이용자를 만들어서 그 이용자의 기본키 숫자값을 지정하면 됩니다.&lt;/p&gt;

&lt;p&gt;왜 기본키 값을 넣는지 첫 번째 이유는 앞서 설명을 하였고, 두 번째 이유는 “(2) ForeignKey 모델 필드”에서 설명하겠습니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;makemigrations&lt;/code&gt; 명령어로 만든 마이그레이션 작업 내용을 &lt;code class=&quot;highlighter-rouge&quot;&gt;migrate&lt;/code&gt; 명령어로 데이터베이스에 반영합니다.&lt;/p&gt;

&lt;h3 id=&quot;2-로그인한-이용자만-사진-게시물-게시하기&quot;&gt;2. 로그인한 이용자만 사진 게시물 게시하기&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델에 이용자 모델 연결을 마쳤으니 이번엔 사진 게시물을 저장하는 과정에 로그인한 이용자 정보를 적용하겠습니다. 간단히 말해서 로그인한 이용자만 사진 게시물을 게시하는 것이지요.&lt;/p&gt;

&lt;h4 id=&quot;1-현재-이용자를-사진-게시물에-적용&quot;&gt;(1) 현재 이용자를 사진 게시물에 적용&lt;/h4&gt;

&lt;p&gt;현재 웹 서비스에 연결된(requested) 접속 정보는 &lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt; 객체에 담겨 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;는 뷰(view) 함수가 첫 번째 인자로 전달받는 객체입니다. 개별 사진을 보는 &lt;code class=&quot;highlighter-rouge&quot;&gt;detail&lt;/code&gt; 뷰 함수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;def detail(request, pk):&lt;/code&gt;와 같이, 사진 게시물을 새로 저장하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;create&lt;/code&gt; 뷰 함수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;def create(request):&lt;/code&gt;와 같이 첫 번째 인자로 &lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;를 전달 받습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reuqest&lt;/code&gt; 객체엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 속성이 존재하는데, 이 속성은 접속한 이용자에 정보가 담겨 있습니다. 로그인한 이용자라면 이용자 모델 클래스로 생성한 인스턴스 객체가, 로그인하지 않은 이용자라면 &lt;code class=&quot;highlighter-rouge&quot;&gt;AnonymousUser&lt;/code&gt; 모델 클래스로 생성한 인스턴스 객체가 할당됩니다.&lt;/p&gt;

&lt;p&gt;그럼 로그인한 이용자만 사진을 게시하도록 코드부터 작성해 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def create(request):
    if request.method == &quot;GET&quot;:
        form = PhotoForm()
    elif request.method == &quot;POST&quot;:
        form = PhotoForm(request.POST, request.FILES)

        if form.is_valid():
            obj = edit_form.save(commit=False)
            obj.user = request.user
            obj.save()

            return redirect(obj)

    # 후략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;한 줄은 조금 바뀌었고, 두 줄이 추가됐습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if form.is_valid():
    obj = form.save(commit=False)
    obj.user = request.user
    obj.save()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;두 번째 줄 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj = form.save(commit=False)&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;form&lt;/code&gt; 객체는 사진 게시물 생성과 관련된 폼(Form)인 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt; 폼 클래스입니다. 첫 번째 줄에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;is_valid()&lt;/code&gt;로 웹에서 전달받은 자료를 검증한 그 객체입니다. 이 객체가 모델 폼인 경우, 그러니까 &lt;code class=&quot;highlighter-rouge&quot;&gt;ModelForm&lt;/code&gt; 클래스를 상속받아 만든 폼인 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt; 인스턴스 메서드를 포함하고 있는데, 이 메서드는 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드와 동일한 역할을 합니다. 데이터를 모델에 연결된 데이터베이스 테이블에 저장하는 것이지요. 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드와 마찬가지로 저장한 내용이 반영된 모델의 인스턴스 객체를 반환합니다. 즉 &lt;code class=&quot;highlighter-rouge&quot;&gt;form.save()&lt;/code&gt;로부터 반환받은 객체를 할당한 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt;는 모델 폼의 인스턴스 객체가 아니라 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt; 모델 폼 클래스에 연결되어 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델로 생성한 인스턴스 객체입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드에 인자로 전달한 &lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;은 실제로 데이터베이스에 반영할 것인지 여부를 정합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;를 전달하면 바로 데이터베이스에 저장하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;False&lt;/code&gt;라고 하면 모델 클래스로 생성한 인스턴스 객체만 반영하고 데이터베이스에 실제로 반영하진 않습니다. 따로 반영 여부를 정해주지 않으면 기본값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;이어서 바로 데이터베이스에 반영합니다. 데이터베이스에 저장하지 않을 거면서 뭐하러 &lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드를 호출했으며, &lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드엔 실제로 반영할 것인지 여부를 정하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt; 인자가 필요한 이유는 무엇일까요? 답은 그 바로 다음에 나오는 두 줄에 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;obj.user = request.user&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt; 객체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 속성에 현재 로그인한 &lt;code class=&quot;highlighter-rouge&quot;&gt;request.user&lt;/code&gt; 속성을 할당하는 것입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt; 폼 클래스는 웹에서 폼 양식 자료가 담긴 &lt;code class=&quot;highlighter-rouge&quot;&gt;request.POST&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;request.FILES&lt;/code&gt;만 전달 받았지, 현재 이용자 정보가 담긴 &lt;code class=&quot;highlighter-rouge&quot;&gt;request.user&lt;/code&gt;를 전달받은 적이 없습니다. 그래서 &lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드가 반환한 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt; 인스턴스 객체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;에는 이용자 정보가 없습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델에 &lt;code class=&quot;highlighter-rouge&quot;&gt;auth.User&lt;/code&gt;에 있는 이용자 모델을 &lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt; 관계로 연결했는데, 뷰 함수에서는 관련 정보를 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;에 반영하지 않았습니다.&lt;/p&gt;

&lt;p&gt;만약, &lt;code class=&quot;highlighter-rouge&quot;&gt;edit_form.save()&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;edit_form.save(commit=True)&lt;/code&gt;처럼 바로 데이터베이스에 반영하려고 하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;IntegrityError&lt;/code&gt; 예외 오류가 발생하며, &lt;code class=&quot;highlighter-rouge&quot;&gt;NOT NULL constraint failed: photo_photo.user_id&lt;/code&gt;라 안내 받습니다.&lt;/p&gt;

&lt;p&gt;겁먹지 말고 오류 안내말을 잘 보세요. 정확히 이해하지 않은 채 추측만 하려는 태도는 안 좋지만, 여러분은 이 강좌 나머지 내용을 그냥 건너뛰지 않을테니 예외 오류 내용을 보고 상황을 추측해 보겠습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;NOT NULL&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;failed&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;photos_photo.user_id&lt;/code&gt; 이 세 가지 표현이 눈에 들어오지요? &lt;code class=&quot;highlighter-rouge&quot;&gt;photos_photo&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos&lt;/code&gt; 앱의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델과 연관되어 보이고, &lt;code class=&quot;highlighter-rouge&quot;&gt;user_id&lt;/code&gt;는 우리가 만든 적이 없지만 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드와 관련되어 보입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드에 &lt;code class=&quot;highlighter-rouge&quot;&gt;NOT NULL&lt;/code&gt;과 관련된 문제가 발생하여 진행하던 작업(&lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt;)이 실패했다는 뜻이군요. &lt;code class=&quot;highlighter-rouge&quot;&gt;NOT NULL&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;이면 안 된다는 의미니까 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드에 &lt;code class=&quot;highlighter-rouge&quot;&gt;NULL&lt;/code&gt;이 들어가서 오류가 생긴 겁니다.&lt;/p&gt;

&lt;p&gt;웹페이지의 폼 양식에서 이용자 모델의 기본키 값을 직접 전달하면 안 됩니다. 예를 들어, &lt;code class=&quot;highlighter-rouge&quot;&gt;hannal&lt;/code&gt; 이용자의 기본키 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;1023&lt;/code&gt;이고 이 값을 웹 폼 양식에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;user_id&lt;/code&gt;로 담아서 서버로 전달한다면, 이용자는 기본키 값 숫자를 고쳐서 마치 다른 이용자가 사진 게시물을 올린 것처럼 왜곡할지도 모릅니다. 이런 정보는 서버에서 알아내서 다뤄야 합니다. 그게 &lt;code class=&quot;highlighter-rouge&quot;&gt;request.user&lt;/code&gt;입니다. 아하, &lt;code class=&quot;highlighter-rouge&quot;&gt;request.user&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt; 폼 클래스에 전달하면 되겠구나.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;form = PhotoForm(request.POST, request.FILES, request.user)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;request.POST&lt;/code&gt;처럼.&lt;/p&gt;

&lt;p&gt;아닙니다. 그렇게 알아서 동작(magic behaviour)해주지 않고, 그래서도 안 됩니다. 이용자 정보가 필요한 폼 클래스라면 이용자 정보를 따로 전달받도록 처리해야 합니다. Python 클래스는 실행 가능한(callable) 객체이므로 함수처럼 소괄호를 사용하여 실행하고 실행 결과로 인스턴스 객체를 반환 받는데, 인스턴스 초기화를 수행하는 메서드가 &lt;code class=&quot;highlighter-rouge&quot;&gt;__init__()&lt;/code&gt;입니다. 이용자 정보인 &lt;code class=&quot;highlighter-rouge&quot;&gt;request.user&lt;/code&gt;를 인자로 전달 받는 &lt;code class=&quot;highlighter-rouge&quot;&gt;__init__()&lt;/code&gt; 메서드를 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt; 폼 클래스에 만들면 됩니다. 이건 Class based view를 다룰 때 살펴보기로 하고, 이번 편에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드에 &lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt; 인자를 &lt;code class=&quot;highlighter-rouge&quot;&gt;False&lt;/code&gt;로 전달하여 처리합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;user = models.ForeignKey(settings.AUTH_USER_MODEL)&lt;/code&gt;로 만들었고, 이 모델 필드는 NULL을 허용하지 않습니다. 데이터베이스 테이블에도 &lt;code class=&quot;highlighter-rouge&quot;&gt;NOT NULL&lt;/code&gt;로 정의되어 있습니다. 그래서 데이터베이스에 실제로 반영하지 말고 우선 모델로 생성한 인스턴스 객체를 &lt;code class=&quot;highlighter-rouge&quot;&gt;edit_form&lt;/code&gt; 객체로부터 받으려고 &lt;code class=&quot;highlighter-rouge&quot;&gt;save(commit=False)&lt;/code&gt; 메서드를 수행했습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt;이 반환하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 인스턴스 객체를 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt;에 할당받고, 이 객체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 속성에 이용자 정보인 &lt;code class=&quot;highlighter-rouge&quot;&gt;request.user&lt;/code&gt;를 할당합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;obj.user = request.user&lt;/code&gt; 코드입니다. 이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj.save()&lt;/code&gt;를 수행하여 데이터베이스에 저장합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;obj.save(commit=True)&lt;/code&gt;와 동일합니다.&lt;/p&gt;

&lt;p&gt;이제 로그인한 이용자 정보가 사진 게시물에 반영되어 저장됩니다.&lt;/p&gt;

&lt;h4 id=&quot;2-create-뷰-함수에-로그인한-이용자만-접근하도록-제한&quot;&gt;(2) &lt;code class=&quot;highlighter-rouge&quot;&gt;create&lt;/code&gt; 뷰 함수에 로그인한 이용자만 접근하도록 제한&lt;/h4&gt;

&lt;p&gt;로그인하지 않은 이용자가 사진 게시물을 저장하려 하면 오류가 발생할 겁니다. 로그인하지 않은 이용자는 이용자 모델로 생성한 인스턴스 객체에 기본키 값이 없을테니 &lt;code class=&quot;highlighter-rouge&quot;&gt;IntegrityError&lt;/code&gt; 예외 오류가 발생할 것 같습니다. 이렇게 예상하셨다면 훌륭합니다. 한 번 시도해보세요.&lt;/p&gt;

&lt;p&gt;실제로 발생하는 예외는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ValueError&lt;/code&gt;가 발생하며, 안내말은 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델 클래스로 만든 인스턴스여야 한다는 내용입니다. 앞서 설명드린 바와 같이 로그인하지 않은 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;request.user&lt;/code&gt;엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;AnonymousUser&lt;/code&gt; 모델 클래스로 생성한 인스턴스 객체가 할당되어 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth.models&lt;/code&gt;에 있는데, 코드를 보면 아시겠지만 껍데기 역할을 할 뿐입니다.&lt;/p&gt;

&lt;p&gt;로그인한 이용자인지 여부는 &lt;code class=&quot;highlighter-rouge&quot;&gt;request.user&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;is_authenticated()&lt;/code&gt; 메서드를 실행하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt; 객체를 반환받아 구분합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;이면 로그인한 이용자, &lt;code class=&quot;highlighter-rouge&quot;&gt;False&lt;/code&gt;이면 로그인하지 않은 이용자입니다. 코드도 아주 간단합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.conf import settings

def create(request):
    if not request.user.is_authenticated():
        return redirect(settings.LOGIN_URL)
    # 후략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;로그인하지 않은 이용자가 &lt;code class=&quot;highlighter-rouge&quot;&gt;create&lt;/code&gt; 뷰 함수로 접근하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.LOGIN_URL&lt;/code&gt;에 지정되어 있는 URL로 이동(redirect) 시킵니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;LOGIN_URL&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;global_settings&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;/accounts/login/&lt;/code&gt;으로 기본 지정되어 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@login_required&lt;/code&gt; 장식자(decorator)를 사용하면 앞서 구현한 부분을 더 명확하고 간결하게 표현할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.contrib.auth.decorators import login_required

@login_required
def create(request):
    # 후략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;더 친절하게도 로그인한 후 이동할 도착지도 &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt; 인자로 지정됩니다. 로그인 주소를 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.LOGIN_URL&lt;/code&gt;에 따로 지정해주면 자동으로 변경한 주소로 이동해 줍니다.&lt;/p&gt;

&lt;h3 id=&quot;3-모델-관계에-더-자세히-알아보기&quot;&gt;3. 모델 관계에 더 자세히 알아보기&lt;/h3&gt;

&lt;p&gt;우리는 이용자 모델을 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드에 &lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt; 관계로 연결했습니다. 그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드에 이용자 모델로 생성한 인스턴스 객체(&lt;code class=&quot;highlighter-rouge&quot;&gt;request.user&lt;/code&gt;)를 할당하지 않자 &lt;code class=&quot;highlighter-rouge&quot;&gt;photo_photo.user_id&lt;/code&gt;에 NULL을 저장하려 해서 저장하지 못했다는 예외 오류도 접했습니다. 이 중에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;user_id&lt;/code&gt; 정체를 살펴 보겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-foreignkey-모델-필드&quot;&gt;(1) ForeignKey 모델 필드&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;, 그러니까 Many to one 관계는 “One”쪽에 “Many”쪽 데이터 여러 개가 연결되는 구조입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hannal.com/assets/uploads/2015/06/09-ManyToOne.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한 이용자가 여러 게시물을 남기거나, 한 글갈래(category)에 여러 글이 속하는 관계입니다. Django 모델로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt; 모델 필드로 모델 클래스를 지정한 것인데, 이 관계 정보를 데이터베이스엔 어떻게 저장할까요?&lt;/p&gt;

&lt;p&gt;일단 각 모델은 데이터베이스에 Django 앱 이름과 모델 이름을 조합하여 테이블로 만듭니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;photos_photo&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos&lt;/code&gt; 앱에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델을 뜻합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;hello&lt;/code&gt;라는 앱의 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hannal&lt;/code&gt; 모델은 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello_hannal&lt;/code&gt; 테이블을, &lt;code class=&quot;highlighter-rouge&quot;&gt;KayCha&lt;/code&gt; 모델은 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello_kay_cha&lt;/code&gt; 테이블을 만들어 연결합니다. 앞서 발생한 &lt;code class=&quot;highlighter-rouge&quot;&gt;IntegrityError&lt;/code&gt; 예외 오류에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos_photo&lt;/code&gt; 정체가 무엇인지 이제 아시겠죠?&lt;/p&gt;

&lt;p&gt;Django의 모델 필드는 데이터베이스의 컬럼(column)이 됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;image&lt;/code&gt; 모델 필드는 같은 이름을 갖는 테이블 컬럼이 됩니다. 모델 필드형(type)은 테이블 컬럼형을 결정합니다. 그런데 &lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt;와 같은 모델 관계 필드는 컬럼 이름이 조금 다릅니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드는 컬럼 이름이 &lt;code class=&quot;highlighter-rouge&quot;&gt;user_id&lt;/code&gt;입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;user_id&lt;/code&gt; 정체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드가 맞습니다. 그런데 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;가 아니라 &lt;code class=&quot;highlighter-rouge&quot;&gt;user_id&lt;/code&gt;인 이유는 무엇일까요? 질문 아니니 대답 안 하셔도 됩니다. :)&lt;/p&gt;

&lt;p&gt;이번 9회 초반에 모델 간 연결은 기본키로 한다고 설명했습니다. Django는 Many쪽이 One쪽을 연결하는 경우, Many쪽 모델 필드 이름에 One쪽의 기본키 이름을 덧붙입니다.&lt;/p&gt;

&lt;p&gt;기본키는 관례에 따라 &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;라는 모델 필드가 되며, 모델 필드는 데이터베이스 테이블 컬럼과 이름이 같으므로 테이블 컬럼도 &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드는 이용자 모델을 Many to one으로 가리키는데, 이용자 모델의 기본키인 모델 필드도 &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델 데이터가 Many쪽이고 이용자 모델이 One쪽이므로, &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt; 모델 필드는 이용자 모델 필드의 기본키 모델 필드인 &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; 이름을 덧붙여서 &lt;code class=&quot;highlighter-rouge&quot;&gt;user_id&lt;/code&gt;가 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hannal.com/assets/uploads/2015/06/09-foreign_key_db_table_schema.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 기본키 모델 필드 이름이 &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;가 아니라 &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt;라면 &lt;code class=&quot;highlighter-rouge&quot;&gt;_uid&lt;/code&gt;가 덧붙게 됩니다. Django는 이 데이터베이스 컬럼 값을 참조하여 서로 분리된 모델의 데이터 연결 관계를 알아냅니다.&lt;/p&gt;

&lt;h4 id=&quot;2-모델-관계를-나중에-맺기-lazy-relation&quot;&gt;(2) 모델 관계를 나중에 맺기 (lazy relation)&lt;/h4&gt;

&lt;p&gt;모델 관계를 맺을 대상 모델 클래스 객체를 직접 전달해도 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.contrib.auth import get_user_model
User = get_user_model()

class Photo(models.Model):
    user = models.ForeignKey(User)
    # 후략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;models.ForeignKey(User)&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ForeignKey&lt;/code&gt; 클래스에 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt;라는 객체를 첫 번째 인자로 전달하여 호출(call)하고, 모델 필드의 인스턴스 객체를 반환받아 &lt;code class=&quot;highlighter-rouge&quot;&gt;user&lt;/code&gt;에 할당하는 것입니다. Python은 소스 파일 맨 윗 줄부터 아래로 실행하므로 저 구문을 실행하여 모델 필드를 만드는 시점에 실제로 존재하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 객체를 사용합니다.&lt;/p&gt;

&lt;p&gt;그렇다면 관계 맺을 모델이 있는 경로를 문자열로 담아 인자로 전달하는 경우는 언제일까요? 이용자 모델처럼 상황에 따라 연결할 모델이 바뀌는 경우가 있습니다. 지난 편에서 예를 든 것처럼 이용자 모델이 바꾸면 이 모델을 가져오는(&lt;code class=&quot;highlighter-rouge&quot;&gt;import&lt;/code&gt;) 모든 코드에도 영향이 미칩니다. 그러나 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.AUTH_USER_MODEL&lt;/code&gt;에 이용자 모델이 있는 위치를 지정하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;AUTH_USER_MODEL&lt;/code&gt; 내용을 참조하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;get_user_model()&lt;/code&gt; 함수로 이용자 모델을 가져오면 &lt;a href=&quot;http://blog.dahlia.kr/post/103101756957&quot;&gt;한 의도를 한 구현체로 정리&lt;/a&gt;할 수 있지요.&lt;/p&gt;

&lt;p&gt;관계 맺을 대상 모델이 아직 만들어지기 전에 연결하려는 경우에도 문자열로 지정합니다. A 모델이(from) B 모델을(to) 관계를 맺는다면 다음과 같이 B 모델을 먼저 만들고 그 &lt;strong&gt;이후&lt;/strong&gt;에 A 모델을 만들어야 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class B(models.Model):
    pass

class A(models.Model):
    b = models.ForeignKey(B)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;B 모델은 C 모델을 관계 맺는다면 C 모델을 B 모델에 앞서 만들어야 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class C(models.Model):
    pass

class B(models.Model):
    c = models.ForeignKey(C)

class A(models.Model):
    b = models.ForeignKey(B)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그런데 C 모델은 A 모델에 관계를 지어야 한다고 가정하겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class C(models.Model):
    a = models.ForeignKey(A)

class B(models.Model):
    c = models.ForeignKey(C)

class A(models.Model):
    b = models.ForeignKey(B)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문제가 생깁니다. C 모델이 만들어지는 시점에 A라는 객체가 존재하지 않기 때문이죠. A 모델을 C 모델 코드 위로 올리면 안 됩니다. A 모델이 만들어지는 시점에 B 모델이 없기 때문이지요. 이런 경우에, C 모델에서 A 모델을 문자열 인자로 전달하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class C(models.Model):
    a = models.ForeignKey('A')

class B(models.Model):
    c = models.ForeignKey(C)

class A(models.Model):
    b = models.ForeignKey(B)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문자열로 관계 맺을 대상 모델을 지정하면 관계 맺을 대상 모델이 만들어졌다는 신호가 오기 전까지 관계를 맺지 않은 채 관계 맺는 연산을 지연시켜 놓습니다. 비유가 아니라 정말로 대상 모델 클래스(예 : &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; 모델)가 초기화 되면 모델 신호(&lt;code class=&quot;highlighter-rouge&quot;&gt;ModelSignal&lt;/code&gt;)인 &lt;code class=&quot;highlighter-rouge&quot;&gt;class_prepared&lt;/code&gt;를 일으키고(fire), 대상 모델을 바라보던 모델은(예 : &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt; 모델) 이 신호을 받고선 비로소 실제 관계를 맺습니다.&lt;/p&gt;

&lt;p&gt;이런 연산 특성을 응용하여 관계 맺을 대상 모델로 자기 자신을 지정하는 것도 가능합니다. 순환 관계(recursive relationship)이라고 하는데, 문자열 &lt;code class=&quot;highlighter-rouge&quot;&gt;'self'&lt;/code&gt;을 지정하면 됩니다. 추후에 기회가 닿으면 순환 관계 모델을 만들어 보겠습니다.&lt;/p&gt;

&lt;p&gt;정리하면, 모델 관계 필드는 관계 맺을 대상을 세 가지 형태로 지정합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;관계 지을 모델 클래스 객체를 직접 인자로 전달&lt;/li&gt;
  &lt;li&gt;관계 지을 모델 클래스 객체가 있는 경로를 문자열로 전달
    &lt;ul&gt;
      &lt;li&gt;형식 : &lt;code class=&quot;highlighter-rouge&quot;&gt;Django앱이름.모델이름&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;자기 자신을 가리키는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;'self'&lt;/code&gt; 문자열 전달&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;강좌 9편을 마칩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hannal/start_with_django_webframework/tree/l09&quot;&gt;9편까지 진행한 전체 소스 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
  </entry>
  
  <entry>
    <title>8. 로그인, 로그아웃 하기</title>
    <link href="/2015/06/start_with_django_webframework_08/"/>
    <updated>2015-06-07T02:45:00+09:00</updated>
    <id>/2015/06/start_with_django_webframework_08</id>
    <content type="html">&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/category/start-with-django-webframework/&quot;&gt;날로 먹는 Django 웹프레임워크 강좌 목차&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;마지막 갱신일시 : 2017년 1월 30일 0시 20분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이번 편에서는 Django 이용자 인증 체계을 알아보고, 이 인증 체계에서 로그인을 어떻게 처리하는지 살펴 보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;1-django-이용자-인증-체계&quot;&gt;1. Django 이용자 인증 체계&lt;/h3&gt;

&lt;p&gt;Django 이용자 인증 체계는 크게 두 가지 요소로 구분합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;인증 (Authentication)&lt;/li&gt;
  &lt;li&gt;권한 (Authorization)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인증은 “나 누구인데 확인 좀…”이라면 권한은 “나 이거 해도 돼요?”라 보면 됩니다. 누구인지 신원이 확인되지 않은 존재에게 권한을 세밀하게 부여하진 못합니다. 신원이 확인된, 즉, 인증된 이용자인지 아닌지로 구분하는 정도로 권한을 부여합니다. 그래서, 권한 체계를 비롯하여 이용자 인증 체계 자체는 인증(Authetication)을 바탕으로 합니다.&lt;/p&gt;

&lt;h4 id=&quot;1-django-내장-인증-기능&quot;&gt;(1) Django 내장 인증 기능&lt;/h4&gt;

&lt;p&gt;Django는 이용자 인증 체계를 내장하고 있으며, 우리는 이미 이 기능을 사용해봤습니다. &lt;a href=&quot;http://blog.hannal.com/2014/10/start_with_django_webframework_04/&quot;&gt;4. Photo 모델로 Admin 영역에서 데이터 다루기&lt;/a&gt; 편에서 최고 권한 이용자로 Admin 영역에 로그인하여 사진 게시물을 입력 했었거든요.&lt;/p&gt;

&lt;p&gt;Django에 내장된 인증 체계는 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth&lt;/code&gt;라는 경로(name space)인 Python 패키지에 모여 있으며, Django 개념으로는 Django App입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt; 설정 항목을 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;'django.contrib.auth',&lt;/code&gt;가 있는데, 우리가 만드는 Pystagram에 사용할 Django App에 Django 인증 체계가 앱 형태로 기본 내장되어 있는 것입니다.&lt;/p&gt;

&lt;p&gt;Django webframework으로 제품을 만든다면 Django 인증 체계를 사용하는 게 좋습니다. 오랜 기간 개발되어 보안 수준은 성숙하고 안전하며, 확장 가능하게 유연합니다. Django에서 제공하는 다른 여러 기능이 내장된 인증 기능 구조를 따르기 때문에 Django가 제공하는 기능을 유기성 있고 풍부하게 쓰기에도 Django 인증 체계를 쓰는 게 좋습니다.&lt;/p&gt;

&lt;h4 id=&quot;2-django-내장-권한-기능&quot;&gt;(2) Django 내장 권한 기능&lt;/h4&gt;

&lt;p&gt;권한 검사 기능도 Django에 내장되어 있습니다. 뷰(View) 단위 행동(behaviour), 데이터 단위 행동에 권한을 부여하여 운용 가능하며, 권한을 그룹 단위로 묶어서(grouping) 이용자에게 지정하는 기능도 제공합니다. 자세한 내용은 권한 기능을 적용할 때 다루겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;2-로그인-기능-구현&quot;&gt;2. 로그인 기능 구현&lt;/h3&gt;

&lt;h4 id=&quot;1-url-패턴-추가&quot;&gt;(1) URL 패턴 추가&lt;/h4&gt;

&lt;p&gt;Django에서 제공하는 인증 기능을 이용하여 로그인, 로그아웃 기능을 구현 하겠습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일이 있는 시작패키지에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 열고, 다음 내용을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.contrib.auth import views as auth_views  # 이 줄 추가.

urlpatterns = [
    # 중략
    url(
        r'^accounts/login/',
        auth_views.login,
        name='login',
        kwargs={
            'template_name': 'login.html'
        }
    ),
    url(
        r'^accounts/logout/',
        auth_views.logout,
        name='logout',
        kwargs={
            'next_page': settings.LOGIN_URL,
        }
    ),
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;r'^accounts/login/'&lt;/code&gt;은 로그인 하는 URL이고, 로그인 화면을 출력하거나 로그인 인증 처리를 하는 뷰 함수는 Django에 내장된 &lt;code class=&quot;highlighter-rouge&quot;&gt;login&lt;/code&gt; 뷰 함수를 사용합니다. 이 함수 객체는 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth.views&lt;/code&gt; 모듈에 존재합니다. 이 URL 패턴의 이름을 &lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt; 키워드 인자를 이용하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;login&lt;/code&gt;이라고 지었는데, 이 인자를 사용하지 않아도 무방합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;kwargs&lt;/code&gt;는 URL 패턴에 연결한 뷰 함수에 추가로 전달할 인자를 사전형(&lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt;) 객체로 전달합니다. 키가 &lt;code class=&quot;highlighter-rouge&quot;&gt;'template_name'&lt;/code&gt;이고 값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;'login.html'&lt;/code&gt;인 사전형 객체인데, Django에서 제공하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;login&lt;/code&gt; 뷰 함수에 &lt;code class=&quot;highlighter-rouge&quot;&gt;template_name&lt;/code&gt; 이름으로 키워드 인자를 지정하면 로그인 화면을 출력하는 데 사용할 템플릿으로 사용합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;'login.html'&lt;/code&gt;이라는 문자열을 지정했으니 우리가 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;TEMPLATE_DIRS&lt;/code&gt;에 지정한 템플릿 디렉터리 중 최상위 순위에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;login.html&lt;/code&gt; 파일을 찾아서 로그인 화면을 출력하는 데 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;r'^accounts/logout/'&lt;/code&gt;은 로그아웃 하는 URL이며, 로그아웃 기능 역시 로그인 기능과 마찬가지로 Django에 내장된 뷰 함수를 사용합니다. 키워드 인자 &lt;code class=&quot;highlighter-rouge&quot;&gt;next_page&lt;/code&gt;는 로그아웃 하고 난 뒤에 이동할 URL을 의미합니다. 이 항목이 없으면 로그아웃 화면이 출력됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;template_name&lt;/code&gt;: ‘logout.html’ 등으로 지정하지 않으면 Django에 내장된 로그아웃 화면이 나타납니다.&lt;/p&gt;

&lt;h4 id=&quot;2-로그인-템플릿-파일&quot;&gt;(2) 로그인 템플릿 파일&lt;/h4&gt;

&lt;p&gt;이번엔 로그인 화면에 사용할 &lt;code class=&quot;highlighter-rouge&quot;&gt;login.html&lt;/code&gt; 템플릿 파일을 만듭니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;templates&lt;/code&gt; 디렉터리에 &lt;code class=&quot;highlighter-rouge&quot;&gt;login.html&lt;/code&gt; 파일을 만들고 다음 내용을 담습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% extends &quot;layout.html&quot; %}

{% block content %}

{% if form.errors %}
&amp;lt;p&amp;gt;ID나 비밀번호가 일치하지 않습니다.&amp;lt;/p&amp;gt;
{% endif %}

&amp;lt;form method=&quot;post&quot; action=&quot;{% url 'login' %}&quot;&amp;gt;
{% csrf_token %}
&amp;lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;&quot; /&amp;gt;



&amp;lt;button type=&quot;submit&quot;&amp;gt;로그인&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;

{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django에서 견본으로 제공하는 &lt;a href=&quot;https://docs.djangoproject.com/en/1.10/topics/auth/default/#django.contrib.auth.views.login&quot;&gt;login.html 템플릿 파일&lt;/a&gt;에서 따와서 약간 고쳤습니다. 따로 뷰 함수에서 템플릿으로 로그인 폼을 템플릿 컨텍스트로 전달하지 않았지만, Django에서 관례로 많이 쓰는 이름인 &lt;code class=&quot;highlighter-rouge&quot;&gt;form&lt;/code&gt;을 사용했습니다. form.errors&lt;code class=&quot;highlighter-rouge&quot;&gt;엔 입력한 폼 양식에 문제가 있는 경우에 문제 내용이 담겨 있습니다. ID(&lt;/code&gt;username`)나 비밀번호를 입력하지 않거나 형식에 맞지 않는 등 여러 오류 종류가 있겠지만, 간결하게 ID와 비밀번호가 일치하지 않는다고만 안내합니다. 로그인에 대해서는 굳이 친절하게 뭐가 문제인지 자세히 알려줄 필요는 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{% if next %}&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt;는 로그인을 한 후 이동할 URL을 뜻합니다. 예를 들어, 로그인을 하지 않은 채 사진에 달린 댓글을 삭제하려 하면 로그인하는 URL로 이동하고 로그인을 하고 나면 로그인하기 전에 접근하려는 URL으로 이동하는데, 이동할 URL이 GET이나 POST 방식으로 전달된 Query String 키인 &lt;code class=&quot;highlighter-rouge&quot;&gt;next&lt;/code&gt;에 담깁니다. 대개는 URL이 &lt;code class=&quot;highlighter-rouge&quot;&gt;https://pystagram.com/accounts/login/?next=/redirect_to_here/&lt;/code&gt;와 같이 표현됩니다.&lt;/p&gt;

&lt;p&gt;그외엔 &lt;a href=&quot;http://blog.hannal.com/2015/05/start_with_django_webframework_07/&quot;&gt;7. 사진 게시물 제출하여 게시하기&lt;/a&gt; 편 내용과 비슷합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;form&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth.forms&lt;/code&gt; 모듈에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthenticationForm&lt;/code&gt; 폼 클래스로 생성한 인스턴스 객체입니다.&lt;/p&gt;

&lt;p&gt;이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8000/accounts/login/&lt;/code&gt;에 접속하면 로그인 화면이 나옵니다. 잘못된 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;password&lt;/code&gt;을 제출하면 이에 대한 안내도 나오고요.&lt;/p&gt;

&lt;p&gt;현재 구현한 로그인 기능으로 로그인을 하면 “Page not found” 오류를 만나게 됩니다. 이에 대해서는 곧 처리하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;3-로그인-과정&quot;&gt;3. 로그인 과정&lt;/h3&gt;

&lt;p&gt;Django가 제공하는 로그인 뷰 함수가 어떤 과정을 거쳐 이용자 인증을 처리하는지 좀 더 살펴 보겠습니다. 이 부분을 몰라도 로그인 기능을 이용하는 데 문제 없습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-form-검증&quot;&gt;(1) Form 검증&lt;/h4&gt;

&lt;p&gt;웹 페이지에서 폼 양식으로 넘어오는 값은 Form을 이용해 값을 검증합니다. Django는 로그인 절차에 &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthenticationForm&lt;/code&gt; 폼을 사용하며, 이 폼은 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth.forms&lt;/code&gt; 모듈에 있습니다. 이쯤되면 눈치 채셨을텐데, Django는 인증 관련 모델, 폼, 뷰, 미들웨어 등을 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth&lt;/code&gt; 패키지 안에 담아 놨습니다. 인증과 관련된 소스 코드를 보려면 이 패키지를 살펴 보시면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AuthenticationForm&lt;/code&gt; 폼은 현재 이용자 정보와 HTTP 요청 정보를 담은 &lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt; 객체도 함께 인자로 전달 받는데, 세션 처리에 필요하기 때문에 그렇습니다. 폼 양식 값이 유효하면(&lt;code class=&quot;highlighter-rouge&quot;&gt;is_valid()&lt;/code&gt;) 이용자가 로그인 후에 이동할 URL 문자열이 안전한 지 검사합니다. 그런 뒤 &lt;code class=&quot;highlighter-rouge&quot;&gt;auth_login()&lt;/code&gt; 함수를 이용해 로그인 인증 처리를 마무리하고 나서 이용자를 다음 URL로 이동(redirect) 시킵니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;auth_login()&lt;/code&gt; 함수는 이름과는 달리 실제로는 인증 과정 마무리 단계를 담당합니다. 로그인 양식을 토대로 이용자 정보를 가져와서 HTTP Request(&lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;) 정보와 함께 사용해 서버 세션 정보를 만듭니다. 세션 정보를 만들지 않으면 로그인 정보는 유지되지 않아서 다른 페이지에 방문할 때마다 매번 로그인을 해야 합니다.&lt;/p&gt;

&lt;p&gt;로그인 양식, 그러니까 로그인 하려고 제출한 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;password&lt;/code&gt;에 정확히 일치하는 이용자를 찾는 과정은 &lt;code class=&quot;highlighter-rouge&quot;&gt;AuthenticationForm&lt;/code&gt; 폼에서 이뤄집니다. 이 폼의 &lt;code class=&quot;highlighter-rouge&quot;&gt;clean()&lt;/code&gt; 메서드에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;password&lt;/code&gt; 내용을 토대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;authenticate()&lt;/code&gt; 함수를 이용해 인증을 시도합니다. 일치하는 이용자가 없으면 Form 오류를 일으키고, 우리는 “ID나 비밀번호가 일치하지 않습니다.”라는 안내를 화면에서 만납니다. 일치하는 이용자가 있으면 이 이용자 계정이 활성화 된 상태인지(&lt;code class=&quot;highlighter-rouge&quot;&gt;is_active&lt;/code&gt;) 검사하는 걸로 폼 안에서 처리하는 인증 과정을 마칩니다.&lt;/p&gt;

&lt;h4 id=&quot;2-인증-체계-기반으로-처리&quot;&gt;(2) 인증 체계 기반으로 처리&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;authenticate()&lt;/code&gt; 함수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;AUTHENTICATION_BACKENDS&lt;/code&gt; 항목에 등록된 인증 체계 기반 클래스를 하나씩 가져와서 &lt;code class=&quot;highlighter-rouge&quot;&gt;authenticate()&lt;/code&gt; 메서드를 호출하여 인증을 시도합니다. 우리가 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일에 따로 이 항목을 설정하지 않아도 문제가 없는 건, Django에 기본으로 내장된 &lt;code class=&quot;highlighter-rouge&quot;&gt;global_settings.py&lt;/code&gt;에 이 항목이 설정되어 있기 때문입니다. 이 항목에 있는 내용은 &lt;code class=&quot;highlighter-rouge&quot;&gt;'django.contrib.auth.backends.ModelBackend'&lt;/code&gt; 이름영역인 클래스가 튜플 객체로 담겨 있습니다.&lt;/p&gt;

&lt;p&gt;데이터베이스에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;password&lt;/code&gt;로 이용자를 찾는 과정이 비로소 이 단계에서 이뤄집니다. 이용자 모델을 가져오고, 이 모델을 이용해 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;으로 먼저 이용자 데이터를 가져오고, 이 이용자 데이터에 저장된 비밀번호와 이용자가 로그인하며 제출한 &lt;code class=&quot;highlighter-rouge&quot;&gt;password&lt;/code&gt;를 비교합니다. 비밀번호까지 일치하면 해당 이용자 데이터, 그러니까 이용자 모델로 생성한 인스턴스 객체를 반환하고, 그렇지 않으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt;을 반환합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;settings&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;AUTHENTICATION_BACKENDS&lt;/code&gt; 항목에 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth.backends.ModelBackend&lt;/code&gt;이 튜플에 담겨져 있다는 말은 다음 두 가지를 의미합니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Django 인증 체계 기반(backend)을 꼭 사용하지 않아도 된다.&lt;/li&gt;
  &lt;li&gt;인증 체계 기반을 여러 개 이상을 사용하는 게 가능하다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;인증 체계 기반의 클래스 규칙대로 인터페이스를 만들기만 한다면 우리가 직접 만든 인증 체계를 사용하거나 Facebook, Twitter처럼 인증 API를 제공하는 서비스나 플랫폼을 기반으로 인증 체계를 운용해도 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;3-이용자-모델-가져오기&quot;&gt;(3) 이용자 모델 가져오기&lt;/h4&gt;

&lt;p&gt;인증 체계 기반을 Django에서 제공하는 기본 인증 &lt;code class=&quot;highlighter-rouge&quot;&gt;ModelBackend&lt;/code&gt;를 다른 것으로 갈아끼우거나 추가한다면, 이용자 정보를 데이터베이스에서 다루는 이용자 모델도 대체하여 쓸 수 있습니다. Django에 내장된 이용자 모델은 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth.models&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt; 모델 클래스입니다. 이 이용자 모델엔 모델 필드이 간결하게 담겨 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt; : 이용자 ID 역할. 다른 값과 중복되지 않는 고유한 값만 허용합니다(&lt;code class=&quot;highlighter-rouge&quot;&gt;unique=True&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;password&lt;/code&gt; : 비밀번호. &lt;code class=&quot;highlighter-rouge&quot;&gt;PasswordField&lt;/code&gt; 모델 필드.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;first_name&lt;/code&gt; : 성씨. &lt;code class=&quot;highlighter-rouge&quot;&gt;CharField&lt;/code&gt; 모델 필드이며 생략 가능.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;last_name&lt;/code&gt; : 이름. &lt;code class=&quot;highlighter-rouge&quot;&gt;CharField&lt;/code&gt; 모델 필드이며 생략 가능.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;email&lt;/code&gt; : 전자우편 주소. &lt;code class=&quot;highlighter-rouge&quot;&gt;EmailField&lt;/code&gt; 모델 필드.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;is_staff&lt;/code&gt; : 관리자 여부. &lt;code class=&quot;highlighter-rouge&quot;&gt;BooleanField&lt;/code&gt; 모델 필드.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;is_active&lt;/code&gt; : 활성화 된 계정인지 여부. &lt;code class=&quot;highlighter-rouge&quot;&gt;BooleanField&lt;/code&gt; 모델 필드.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이외에도 &lt;code class=&quot;highlighter-rouge&quot;&gt;is_superuser&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;groups&lt;/code&gt; 같은 모델 필드 몇 가지가 더 있지만, 이 모델 필드의 값을 직접 다룰 일은 드물고, 이 강좌 내용을 이해하시면 이런 모델 필드를 직접 찾아 다루는 건 어렵지 않으므로 이 강좌에선 다루지 않겠습니다.&lt;/p&gt;

&lt;p&gt;만약, 필명이나 사용하는 언어, 거주 지역처럼 정보를 추가로 이용자로부터 입력 받아 관리하려면 이용자 모델 클래스를 &lt;strong&gt;확장&lt;/strong&gt;해야 합니다. Django에서 제공하는 이용자 모델을 변경해도 되지만, Django 소스 파일을 직접 고쳐서 쓰지 않는 게 좋습니다. Django 판을 올릴 때마다 직접 수정한 부분을 매번 챙겨야 하고, 연계되어 동작하는 다른 기능에 부작용을 일으킬 여지도 있습니다. 그래서 변경하지 않고 &lt;strong&gt;확장&lt;/strong&gt;해야 합니다.&lt;/p&gt;

&lt;p&gt;확장하는 자세한 방법은 다른 편에서 따로 다루기로 하고&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, 여기에선 확장 방법 종류만 간단히 언급하겠습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;따로 이용자 모델을 만들고, Django의 이용자 모델에 연결(Model relationship).&lt;/li&gt;
  &lt;li&gt;이용자 모델과 모델 매니저, 이용자 폼 등을 모두 구현하여 이용자 모델 부분을 대체.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2번 방법에서 “모델 부분을 대체”한다는 표현을 눈 여겨 보세요. 일일이 Django 소스에서 이용자 모델 관련 부분, 가령, &lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth.models.User&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;pystagram_auth.models.User&lt;/code&gt;와 같이 교체하는 건 아닙니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;settings&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;AUTH_USER_MODEL&lt;/code&gt; 항목에 지정하기만 하면 됩니다.&lt;/p&gt;

&lt;p&gt;이 항목 역시 우리가 따로 설정한 적이 없는데, Django의 &lt;code class=&quot;highlighter-rouge&quot;&gt;global_settings&lt;/code&gt;에 설정되어 있으며, 기본 값으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;'auth.User'&lt;/code&gt; 문자열이 할당되어 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;auth&lt;/code&gt;는 Django 앱 이름(Python 패키지)이고, &lt;code class=&quot;highlighter-rouge&quot;&gt;User&lt;/code&gt;는 모델 클래스 이름입니다. Python 이름영역(name space)으로 풀어 쓰면 &lt;code class=&quot;highlighter-rouge&quot;&gt;auth.models.User&lt;/code&gt;인 셈입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;settings&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;AUTH_USER_MODEL&lt;/code&gt; 설정 항목을 참조하여 이용자 모델을 실제로 가져오는 역할은 &lt;code class=&quot;highlighter-rouge&quot;&gt;get_user_model()&lt;/code&gt; 함수가 맡으며, &lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth&lt;/code&gt;에 있습니다. 이 함수를 이용하면 이용자 모델이 어떤 것으로 바뀌든 코드를 일관되게 유지하게 됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;AUTH_USER_MODEL = 'auth.User'&lt;/code&gt;라고 설정하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;get_user_model()&lt;/code&gt; 함수를 실행하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;auth.models.User&lt;/code&gt;를 반환하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;AUTH_USER_MODEL = 'pystagram_auth.MyUser'&lt;/code&gt;로 설정하고 실행하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;pystagram_auth.models.MyUser&lt;/code&gt;를 이용자 모델로 반환합니다. 그러므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;get_user_model()&lt;/code&gt; 함수로 이용자 모델을 가져오는 게 좋습니다.&lt;/p&gt;

&lt;p&gt;인증 체계 기반(backend)과는 달리 기본 이용자 모델은 하나만 가능합니다.&lt;/p&gt;

&lt;h4 id=&quot;4-정리하면&quot;&gt;(4) 정리하면&lt;/h4&gt;

&lt;p&gt;로그인 과정을 정리하면 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth.views.login&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth.forms.AuthenticationForm&lt;/code&gt;
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth.authenticate()&lt;/code&gt;
            &lt;ul&gt;
              &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;settings.AUTHENTICATION_BACKENDS&lt;/code&gt;에서 인증 기반 하나씩 가져옴&lt;/li&gt;
              &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth.backends.ModelBackend&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;authenticate()&lt;/code&gt; 메서드로 인증 처리&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth.auth_login&lt;/code&gt; (정확히는 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.auth.login&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;auth_login&lt;/code&gt;으로 import 한 것.)으로 인증 관련 세션 처리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;로그인 이후 이동할 URL로 이동 처리(redirect)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;4-로그인-관련-설정-항목&quot;&gt;4. 로그인 관련 설정 항목&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;에 설정하는 로그인 관련 항목이 몇 가지 있습니다.&lt;/p&gt;

&lt;h4 id=&quot;1-login_url&quot;&gt;(1) &lt;code class=&quot;highlighter-rouge&quot;&gt;LOGIN_URL&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LOGIN_URL&lt;/code&gt;은 로그인 URL을 뜻합니다. Django에서 제공하는 장식자(decorator) 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;login_required&lt;/code&gt;는 뷰 함수에 접근할 때 로그인 여부를 검사하고, 로그인하지 않으면 로그인 URL로 이용자를 이동시키는데, 이 로그인 URL을 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.LOGIN_URL&lt;/code&gt;에서 가져 옵니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;global_settings&lt;/code&gt;에 설정된 기본값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;/accounts/login/&lt;/code&gt;입니다. 로그인 URL을 다른 것으로 쓴다면 이 항목에 URL을 지정하면 제3자(3rd party) 도구 등에서 참조합니다.&lt;/p&gt;

&lt;h4 id=&quot;2-logout_url&quot;&gt;(2) &lt;code class=&quot;highlighter-rouge&quot;&gt;LOGOUT_URL&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LOGIN_URL&lt;/code&gt;과 비슷한 역할을 합니다. 기본값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;/accounts/logout/&lt;/code&gt;입니다. 그런데 사용할 일은 거의 없어서 사실상 죽은 설정 항목이나 마찬가지입니다. 이런 게 있다는 정도로 알아 두시면 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;3-login_redirect_url&quot;&gt;(3) &lt;code class=&quot;highlighter-rouge&quot;&gt;LOGIN_REDIRECT_URL&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;로그인을 하고 나서 이동할 URL을 설정합니다. 로그인 하고나서 이동할 URL이 지정된 경우 그 URL로 이동하지만, 이동할 URL이 지정되지 않았거나 지정한 URL이 보안상 문제가 있는 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.LOGIN_REDIRECT_URL&lt;/code&gt;를 사용합니다.&lt;/p&gt;

&lt;p&gt;현재 구현한 기능으로는 로그인을 마치면 “Page not found” 오류를 만납니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hannal.com/assets/uploads/2015/06/08-404_after_login.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;웹 브라우저 주소입력란을 잘 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8000/accounts/profile/&lt;/code&gt;과 같이 전혀 본 적 없는 URL로 되어 있습니다. 이는 Django 기본 &lt;code class=&quot;highlighter-rouge&quot;&gt;LOGIN_REDIRECT_URL&lt;/code&gt; 설정값이 &lt;code class=&quot;highlighter-rouge&quot;&gt;/accounts/profile/&lt;/code&gt;이라서 그렇습니다. 아직 우리는 프로필 페이지를 만들지 않았으니 임시로 &lt;code class=&quot;highlighter-rouge&quot;&gt;/photos/upload/&lt;/code&gt;로 이동하도록 설정하겠습니다. 시작패키지에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일을 열고 다음 코드를 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;LOGIN_REDIRECT_URL = '/photos/upload/'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이제 로그인을 마치면 &lt;code class=&quot;highlighter-rouge&quot;&gt;/photos/upload/&lt;/code&gt;로 이동하여 사진을 올리라는 압박을 줍니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;강좌 8편을 마칩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hannal/start_with_django_webframework/tree/l08&quot;&gt;8편까지 진행한 전체 소스 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;다른 편에서 다루겠다는 내용이 늘어가니 불안해지네요. 까먹고 다루지 않을까봐요. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  
  <entry>
    <title>7. 사진 게시물 제출하여 게시하기</title>
    <link href="/2015/05/start_with_django_webframework_07/"/>
    <updated>2015-05-18T02:47:49+09:00</updated>
    <id>/2015/05/start_with_django_webframework_07</id>
    <content type="html">&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/category/start-with-django-webframework/&quot;&gt;날로 먹는 Django 웹프레임워크 강좌 목차&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;마지막 갱신일시 : 2017년 1월 29일 23시 40분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그동안 우리는 사진 게시물을 Django Admin에서 게시했습니다. 이번엔 사진 게시물을 게시하는 기능을 구현하겠습니다. Django Form을 이용할 것인데, 이번 편에서는 왜 Django Form을 쓰면 좋고, 어떻게 동작하는 지 흐름을 이해하는 내용을 다루겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;1-django-form&quot;&gt;1. Django Form&lt;/h3&gt;

&lt;p&gt;Django Form은 Django의 주요 매력 요소 중 하나라 생각합니다. &lt;a href=&quot;http://blog.hannal.com/2014/9/start_with_django_webframework_03/&quot;&gt;Django는 MTV 패턴을 따른다&lt;/a&gt;고 하는데, Django Model과 Form을 활용하면 반복되는 처리를 Django가 대신 하고 이용자는 데이터(model)와 표현물(template)에 집중하게 됩니다.&lt;/p&gt;

&lt;p&gt;Form은 이름에서 드러나듯이 입력 양식(form)을 다루는 기능입니다. “입력 양식”이란 Django가 웹 프레임워크이니 웹 입력 양식을 뜻합니다. Django Form은 HTML로 만든 웹 화면의 form 태그에서 서버로 전달된 항목이 유효한 지 검증(validation)할 뿐만 아니라 웹 입력 항목에 필요한 HTML 태그를 생성해 출력합니다. 유효하지 않은 항목이 있으면 어떻게 유효하지 않은 지 안내말을 출력하기도 합니다.&lt;/p&gt;

&lt;p&gt;유효성은 꼼꼼하게 검사(validation)해야 합니다. 보안 측면에서 클라이언트(서비스 이용자)가 서버로 보내오는 데이터는 그다지 신뢰해서는 안 됩니다. 우리 서비스를 위태롭게 할 코드가 숨겨져 있을지도 모릅니다. 운영 측면에서도 이용자가 system이나 admin과 같이 운영자를 사칭하는 계정 이름을 짓거나 화면을 망가뜨리거나 다른 이용자의 권한을 가로채는 서비스 앞단(front-end)용 코드를 심을지도 모릅니다.&lt;/p&gt;

&lt;p&gt;보안성을 높이려면 마냥 뚫고 들어오지 못 하게 폐쇄하기만 할 게 아니라 개방할 필요도 있습니다. 개발자 또는 개발팀이 아무리 뛰어난 능력을 가졌어도 갈수록 증가하는 소프트웨어 복잡성에서 발생하는 수많은 경우와 상황에 대응하는 건 불가능합니다. 또한 서비스에 구현된 모든 기능을 완전히 직접 구현하여 제공하는 것이 아닌 이상 우리가 만드는 소프트웨어는 다른 소프트웨어나 도구와 연결되는데, &lt;a href=&quot;http://blog.dahlia.kr/post/82482810330&quot;&gt;우리가 만든 소프트웨어의 바깥 환경이 변하면서 우리가 만든 소프트웨어도 녹슬어&lt;/a&gt; 끊임없이 새로운 문제에 부딪히게 됩니다. 이 문제는 폐쇄하여 감출 게 아니라 오히려 개방하여 더 드러내서 많은 사람이 문제를 발견하는 게 낫습니다. Django는 오픈소스 프로젝트이며, 많은 개발자가 참여하고 기여하고 사용합니다. Django처럼 애용되고 활성화 된 오픈소스 프로젝트는 사람이 유발하는 보안 구멍을 주시하는 눈이 많아서 우리가 직접 구현하는 것보다 더 신뢰할 만하다고 생각합니다. 우리의 능력이 뛰어나든 그렇지 않든 말이지요.&lt;/p&gt;

&lt;p&gt;운영 측면에서 대응해야 할 대응은 반복되는 처리가 많습니다. 예를 들어, 숫자만 입력받을 항목에 숫자 외 다른 글자가 입력되었는지 검사하고 들어 있으면 예외 처리하거나 첨부한 이미지 파일이 제대로 된 파일인지 검사하는 처리는 항목 개수만큼이나 반복되는 과정입니다. 이를 일일이 코드로 검사한다면 실수할 가능성이 큽니다. 일관성과 관리 차원에서 그러한 역할을 하는 검사기(validator)를 만들어 처리하는 게 좋습니다.&lt;/p&gt;

&lt;p&gt;이렇게 클라이언트로부터 전송받은 데이터가 유효한지 검사하고 걸러내는 역할을 Django Form가 합니다. Django Form을 사용하면 상당히 다양한 입력 형식에 대해 수 년에 걸쳐 쌓인 경험으로 유효성을 검사합니다. 가령, Django Form의 &lt;code class=&quot;highlighter-rouge&quot;&gt;EmailField&lt;/code&gt; 폼 필드를 사용하면, 다국어나 &lt;code class=&quot;highlighter-rouge&quot;&gt;.wiki&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;.google&lt;/code&gt;과 같은 새로운 최상위 도메인(Top-level domain), 심지어 IPv4나 IPv6와 같이 IP주소로 구성된 전자우편 주소에 대응 가능합니다.&lt;/p&gt;

&lt;p&gt;물론 어디까지나 유효성을 검사하는 것이므로 제가 앞서 언급한 보안성에 대해 무결하지는 않습니다. 예를 들어, Django Form의 &lt;code class=&quot;highlighter-rouge&quot;&gt;ImageField&lt;/code&gt; 폼 필드는 클라이언트가 제출한 파일이 &lt;a href=&quot;https://github.com/django/django/blob/1.8.1/django/forms/fields.py#L691&quot;&gt;이미지 파일로 유효한지 확인하는 방법을 Image Library인 PIL이나 Pillow의 &lt;code class=&quot;highlighter-rouge&quot;&gt;verify()&lt;/code&gt;에 의존&lt;/a&gt;합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;verify()&lt;/code&gt; 메서드는 파일의 헤더 영역을 읽어 들여서 유효한 파일인지 검사할 뿐입니다. 그 마저도 일부 파일에 대해서만 제공하여, &lt;a href=&quot;https://github.com/python-pillow/Pillow/blob/master/PIL/GifImagePlugin.py&quot;&gt;GIF 파일&lt;/a&gt;을 처리하는 모듈엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;verify()&lt;/code&gt;가 아예 없습니다. GIF, PNG, Jpeg과 같은 이미지 파일은 일반 문자열을 담는 Metadata 영역(chunk)을 지원하는데, 이 요소를 악용하여 보안을 위협하는 코드를 삽입하여 서버나 클라이언트(방문자)에게 해를 끼칠 가능성이 있습니다&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;하지만, 이는 Django Form이 보안에 초점을 맞춘 기능은 아니니 보안 대응용으로 Django Form에 의존하지 않아야 한다는 의미이며, 입력 항목이 유효한 지에 대한 필수 검사 요소는 갖추고 있으므로 Django Form을 가장 기본으로 사용하고 보안에 필요한 조치를 추가하는 것이 나을 것입니다.&lt;/p&gt;

&lt;h4 id=&quot;form과-modelform&quot;&gt;Form과 ModelForm&lt;/h4&gt;

&lt;p&gt;Django Form은 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.forms&lt;/code&gt; 모듈에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Form&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;ModelForm&lt;/code&gt; 클래스로 제공됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Form&lt;/code&gt;은 앞서 설명한 내용을 그대로 담고 있는 클래스입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;ModelForm&lt;/code&gt;은 Django Model과 연계한 Form 클래스입니다. Django Model을 사용한다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;ModelForm&lt;/code&gt;을 이용하여 입력 양식과 입력 항목 검증, 그리고 검증된 입력 데이터를 데이터베이스에 저장하는 과정을 편하게 처리합니다.&lt;/p&gt;

&lt;p&gt;자세한 건 코드로 구현하면서 다루겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;2-사진-게시물을-form을-이용하여-게시하기&quot;&gt;2. 사진 게시물을 Form을 이용하여 게시하기&lt;/h3&gt;

&lt;h4 id=&quot;form-만들기&quot;&gt;Form 만들기&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;photos&lt;/code&gt; 디렉터리에 &lt;code class=&quot;highlighter-rouge&quot;&gt;forms.py&lt;/code&gt; 파일을 만듭니다. 앞으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos&lt;/code&gt; 앱에서 사용하는 Form은 이 모듈에 만듭니다. 이제 사진 게시물을 편집하는(생성하거나 수정) 폼을 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt;이라는 이름으로 만듭니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__future__&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unicode_literals&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;django&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forms&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;models&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Photo&lt;/span&gt;


&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhotoForm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ModelForm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Photo&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fields&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'image'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'content'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아주 간결한 코드입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;forms&lt;/code&gt; 모듈에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ModelForm&lt;/code&gt; 클래스를 상속받는 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt; 클래스를 만들면 이 클래스는 Form 클래스입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;ModelForm&lt;/code&gt;이므로 클래스 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; 클래스를 또 만들고, 그 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Photo&lt;/span&gt;&lt;/code&gt;라는 코드로 이 Model form에 연계하는 Model을 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt;로 지정한 것입니다. 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델 클래스는 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos&lt;/code&gt; 앱 디렉터리의 &lt;code class=&quot;highlighter-rouge&quot;&gt;models.py&lt;/code&gt; 모듈에 있으니 &lt;code class=&quot;highlighter-rouge&quot;&gt;from .models import Photo&lt;/code&gt;로 읽어 들인 것입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; 클래스의 &lt;code class=&quot;highlighter-rouge&quot;&gt;fields&lt;/code&gt; 속성은 폼에 사용할 모델의 모델 필드를 지정하는 데 사용합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;fields = ('image', 'content', )&lt;/code&gt; 이 코드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 &lt;code class=&quot;highlighter-rouge&quot;&gt;image&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt; 모델 필드를 폼 필드로 만드는 설정인 셈입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ModelForm&lt;/code&gt;은 Form에 연결한 Model의 모델 필드를 기반으로 폼 필드를 만듭니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Photo(models.Model):
    image = models.ImageField(upload_to='%Y/%m/%d/orig')
    filtered_image = models.ImageField(upload_to='%Y/%m/%d/filtered')
    content = models.TextField(max_length=500, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델이 이와 같은 모델 필드로 구성되어 있으니 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt;을 일반 &lt;code class=&quot;highlighter-rouge&quot;&gt;Form&lt;/code&gt; 클래스를 상속받아 만든다면 다음과 같이 만드는 셈입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class PhotoForm(forms.Form):
    image = forms.ImageField()
    filtered_image = forms.ImageField()
    content = forms.CharField(
        max_length=500,
        required=False,
        widget=forms.Textarea
    )
    created_at = forms.DateTimeField(required=False)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Model과 비슷하게 생겼습니다. 웹페이지에 사용할 HTML도 거의 비슷합니다.&lt;/p&gt;

&lt;p&gt;Model은 데이터베이스와 연관되어 있어서 모델 필드형(type)이 데이터베이스의 컬럼(column)형(type)에 맞추어져 있고, Form은 웹 입력 양식인 form 관련 태그의 종류에 맞추어져 소소한 차이가 있지만, 결국 웹에서 넘겨받은 데이터를 데이터베이스에 넣는 것이라 서로 비슷한 인터페이스를 갖습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;ModelForm&lt;/code&gt;을 쓰면 모델 필드와 폼 필드 간 차이 마저도 별로 의식하지 않습니다. 그래서 Model을 잘 만들고 &lt;code class=&quot;highlighter-rouge&quot;&gt;ModelForm&lt;/code&gt;을 이용하여 Model form을 만들면 우리는 데이터 유효성을 검사하고 이를 데이터베이스에 넣거나 찾아 쓰는 데이터 관리와 처리를 날로 먹게 됩니다.&lt;/p&gt;

&lt;h4 id=&quot;사진-게시물-작성-화면-만들기&quot;&gt;사진 게시물 작성 화면 만들기&lt;/h4&gt;

&lt;p&gt;사진 게시물을 게시하려면 사진 파일을 선택하고, 사진을 설명하는 본문 등 사진 게시물에 필요한 사항을 입력해야 합니다. 본 강좌 중 &lt;a href=&quot;http://blog.hannal.com/2014/8/start_with_django_webframework_01/&quot;&gt;Pystagram 기획&lt;/a&gt;편에서 사진 게시물을 작성하고 게시하는 URL을 &lt;code class=&quot;highlighter-rouge&quot;&gt;/photos/upload/&lt;/code&gt;로 하기로 했으니 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에 이 주소 패턴을 등록합니다. 시작 패키지(&lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일이 있는 디렉터리)에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일을 열고 다음 URL 패턴을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 생략 
from photos.views import hello
from photos.views import detail
from photos.views import create  # 이 줄 추가


urlpatterns = [
    url(r'^hello/$', hello),
    url(r'^photos/(?P&amp;lt;pk&amp;gt;[0-9]+)/$', detail, name='detail'),
    url(r'^photos/upload/$', create, name='create'),  # 이 줄 추가
    url(r'^admin/', admin.site.urls),
]
# 생략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/photos/upload/&lt;/code&gt; URL에 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos&lt;/code&gt; 앱 디렉터리에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;views.py&lt;/code&gt; 모듈의 &lt;code class=&quot;highlighter-rouge&quot;&gt;create&lt;/code&gt; 뷰 함수를 연결(mapping)한 것입니다.&lt;/p&gt;

&lt;p&gt;이번엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;views.py&lt;/code&gt; 파일에 &lt;code class=&quot;highlighter-rouge&quot;&gt;create&lt;/code&gt; 뷰 함수를 만듭니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 생략
from .forms import PhotoForm


def create(request):
    form = PhotoForm()
    ctx = {
        'form': form,
    }
    return render(request, 'edit.html', ctx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;edit.html&lt;/code&gt; 템플릿 파일에 템플릿 맥락 요소(Context)로 앞서 만든 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt; 클래스 객체를 전달하는데, 폼 클래스 자체가 아니라 폼 클래스를 인스턴스 객체로 생성하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;form&lt;/code&gt;에 할당하고, 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;form&lt;/code&gt;을 전달합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;render()&lt;/code&gt; 함수는 &lt;a href=&quot;http://blog.hannal.com/2014/11/start_with_django_webframework_05/&quot;&gt;5. url에 view 함수 연결해서 사진 출력하기&lt;/a&gt; 편에서 역할을 설명했고, 이번 편에서 처음 사용합니다. 이 함수는 대개 세 가지 인자를 필요로 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;템플릿 파일 이름&lt;/li&gt;
  &lt;li&gt;사전형(&lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt;) 객체로 전달되는 템플릿 맥락 요소(context)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt; 객체는 뷰 함수에 첫 번째 인자로 전달되는 객체입니다. &lt;a href=&quot;https://docs.djangoproject.com/en/1.10/ref/request-response/#httprequest-objects&quot;&gt;HTTP Request&lt;/a&gt;를 뜻합니다. 뷰 함수는 언제나 첫 번째 인자로 &lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt; 객체를 전달 받는데, 이 객체를 &lt;code class=&quot;highlighter-rouge&quot;&gt;render()&lt;/code&gt; 함수의 첫 번째 인자로 전달합니다. 템플릿에서 템플릿 맥락 요소로 &lt;code class=&quot;highlighter-rouge&quot;&gt;request&lt;/code&gt; 객체를 지정하는(mapping) 데 사용됩니다. 두 번째 인자는 템플릿 파일 경로를 문자열로 지정하며, 이 인자 역시 필수 인자입니다. 마지막으로, 세 번째 인자는 템플릿 파일 안에서 사용할 템플릿 맥락 요소를 사전형(&lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt;) 객체로 전달합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;{'form': form}&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Key&lt;/code&gt;인 &lt;code class=&quot;highlighter-rouge&quot;&gt;'form'&lt;/code&gt;은 템플릿 파일 안에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;form&lt;/code&gt;이라는 이름으로 사용하는 템플릿 변수가 되고, &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt;인 &lt;code class=&quot;highlighter-rouge&quot;&gt;form&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoForm()&lt;/code&gt;의 인스턴스 객체)가 이 템플릿 변수에 연결된(mapped) 객체인 셈이지요.&lt;/p&gt;

&lt;p&gt;이번엔 템플릿 파일인 &lt;code class=&quot;highlighter-rouge&quot;&gt;edit.html&lt;/code&gt;을 만듭니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;photo&lt;/code&gt; 디렉터리에 &lt;code class=&quot;highlighter-rouge&quot;&gt;templates&lt;/code&gt; 디렉터리를 만들고, 그 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;edit.html&lt;/code&gt; 파일을 만들어 다음 내용을 담습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% extends 'layout.html' %}

{% block content %}
&amp;lt;form
    method=&quot;POST&quot;
    action=&quot;&quot;
    enctype=&quot;multipart/form-data&quot;
&amp;gt;
    {% csrf_token %}
    {{ form.as_p }}

    &amp;lt;p&amp;gt;
        &amp;lt;button type=&quot;submit&quot;&amp;gt;저장&amp;lt;/button&amp;gt;
    &amp;lt;/p&amp;gt;
&amp;lt;/form&amp;gt;

{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django Template은 추후 연재에서 자세히 다루겠습니다. 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;edit.html&lt;/code&gt;는 뷰 함수에서 지정한 템플릿 파일이니 이후엔 &lt;strong&gt;뷰 템플릿 파일&lt;/strong&gt;이라 부르겠습니다. 템플릿 내용 중 눈여겨 볼 점은 &lt;code class=&quot;highlighter-rouge&quot;&gt;{{ form.as_p }}&lt;/code&gt; 코드입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;form&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;create&lt;/code&gt; 뷰 함수가 &lt;code class=&quot;highlighter-rouge&quot;&gt;form&lt;/code&gt; 폼 객체를 &lt;code class=&quot;highlighter-rouge&quot;&gt;form&lt;/code&gt;이라는 템플릿 변수로 지정해 전달한 것입니다. 이 객체의 인스턴스 메서드인 &lt;code class=&quot;highlighter-rouge&quot;&gt;as_p()&lt;/code&gt;를 호출하면 각 폼 필드를 HTML 태그인 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&lt;/code&gt;(paragraph, 문단 태그)로 감싸서 출력합니다. 실제로 출력되는 HTML 코드는 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;label for=&quot;id_image&quot;&amp;gt;Image file:&amp;lt;/label&amp;gt; &amp;lt;input id=&quot;id_image&quot; name=&quot;image&quot; type=&quot;file&quot; /&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;label for=&quot;id_content&quot;&amp;gt;Content:&amp;lt;/label&amp;gt; &amp;lt;textarea cols=&quot;40&quot; id=&quot;id_content&quot; maxlength=&quot;500&quot; name=&quot;content&quot; rows=&quot;10&quot;&amp;gt;
&amp;lt;/textarea&amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델에 있는 모델 필드 중 두 개가 HTML form 입력항목 태그로 표현 되었습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;created_at&lt;/code&gt;은 없는데, 날짜나 시간 관련 모델 필드(&lt;code class=&quot;highlighter-rouge&quot;&gt;DateTimeField&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;DateField&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;TimeField&lt;/code&gt;)에 &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_now_add&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;auto_now&lt;/code&gt; 필드 옵션 중 하나라도 &lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;로 지정되면 Model form으로 폼 필드를 만들 때 기본 입력 항목으로 지정되지 않고, 그래서 HTML 태그로도 만들어 내지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;{% csrf_token %}&lt;/code&gt;는 &lt;a href=&quot;https://goo.gl/Bw90sV&quot;&gt;CSRF(Cross Site Request Forgery)&lt;/a&gt; 토큰을 만드는 템플릿 태그입니다. Django로 만든 웹 페이지에 접속하면 각 세션을 기반으로 CSRF 토큰을 만들며, 이 토큰이 조작되거나 존재하지 않으면 Form 데이터를 Django로 동작하는 웹 애플리케이션 서버에 보내지 못합니다&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;. CSRF 토큰 검사를 하지 않도록 하면 되지만, 보안 상 좋지 않으니 HTML 폼 영역에 CSRF 토큰을 생성하도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;{% csrf_token %}&lt;/code&gt;을 습관처럼 넣길 권합니다. 빠뜨리면 CSRF 검증을 실패하였다는 오류가 발생합니다.&lt;/p&gt;

&lt;p&gt;뷰 템플릿 파일인 &lt;code class=&quot;highlighter-rouge&quot;&gt;edit.html&lt;/code&gt;는 레이아웃 구조를 잡는 역할을 하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;layout.html&lt;/code&gt; 템플릿 파일로 확장하므로(&lt;code class=&quot;highlighter-rouge&quot;&gt;{% extends 'layout.html' %}&lt;/code&gt;) 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;layout.html&lt;/code&gt; 파일도 만들어야 합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% load staticfiles %}

&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ko&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;{% block page_title %}Pystagram{% endblock %}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{% static 'js/jquery-2.1.3.min.js' %}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
{% block content %}{% endblock %}
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;지난 6회 연재 글에서 다룬 정적(static) 파일 내용이 얼핏 보이네요. 이것도 Django Template을 다루는 연재 글에서 자세히 다루겠습니다.&lt;/p&gt;

&lt;p&gt;이제 Django의 개발용 내장 웹 서버를 구동하고(&lt;code class=&quot;highlighter-rouge&quot;&gt;python manage.py runserver&lt;/code&gt;) &lt;code class=&quot;highlighter-rouge&quot;&gt;/photo/upload/&lt;/code&gt; URL로 접속하면 사진 게시물을 작성하는 편집 화면이 나옵니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;filtered_image&lt;/code&gt;은 이미지 필터를 적용하여 가공된 이미지 파일을 담는 모델 필드입니다. 다시 말하면 사진 게시물을 편집하는 단계에서 이용자가 접근해서는 안 되는 필드입니다. 그래서 화면에 나타나지 않게 감추었습니다. 앞서 모델폼을 만들 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;fields&lt;/code&gt; 속성에서 누락한 탓입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fields&lt;/code&gt;는 폼에서 사용할 모델 필드를 지정하는 데 사용하며, 모델 필드 이름을 문자열로 리스트(&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;)나 튜플(&lt;code class=&quot;highlighter-rouge&quot;&gt;tuple&lt;/code&gt;) 객체에 나열해 담으면 됩니다. 그런데 폼 필드로 사용하지 않을 모델 필드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;filtered_image&lt;/code&gt; 하나이고, 사용할 모델 필드는 221개쯤 있다고 가정하겠습니다. 고작 하나를 사용하지 않으려고 221개 모델 필드 이름을 나열하면 무척 고통스럽습니다. 이런 경우는 사용하지 않을 모델 필드만 지정해야 편한데, &lt;code class=&quot;highlighter-rouge&quot;&gt;exclude&lt;/code&gt;에 지정하면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PhotoForm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ModelForm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Meta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Photo&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exclude&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'filtered_image'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 코드에서 유의할 점은 &lt;code class=&quot;highlighter-rouge&quot;&gt;exclude&lt;/code&gt; 역시 리스트나 튜플 객체를 할당해야 하므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;'filtered_image'&lt;/code&gt; 뒤에 쉼표 하나 더 찍어줘야 합니다&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;photos&lt;/code&gt; 앱 디렉터리에 &lt;code class=&quot;highlighter-rouge&quot;&gt;templates&lt;/code&gt; 디렉터리를 만들고 그곳에 템플릿 파일을 담으면 Django가 알아서 앱 디렉터리에 있는 템플릿 파일을 가져옵니다. 이 동작은 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;에 따로 설정되어 있어서 그렇습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates'), ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;TEMPLATES&lt;/code&gt; 항목을 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;'APP_DIRS': True,&lt;/code&gt; 코드가 있는데, 이 부분이 바로 Django 앱 별로 템플릿 파일을 다루도록 할 것인지 여부를 지정한 것이며 앱 안에 위치하는 템플릿 디렉터리 이름은 &lt;code class=&quot;highlighter-rouge&quot;&gt;templates&lt;/code&gt;로 고정되어 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;False&lt;/code&gt;로 바꾸면 앱 디렉터리에 있는 템플릿 파일을 다루지 않습니다.&lt;/p&gt;

&lt;h4 id=&quot;사진-게시물-게시하기&quot;&gt;사진 게시물 게시하기&lt;/h4&gt;

&lt;p&gt;우리는 사진 게시물 내용을 작성하는 URL과 사진 게시물을 제출하여 게시하는 URL을 같이 쓰겠습니다. 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;/photo/upload/&lt;/code&gt;에 HTTP Get 방식으로 접근하면 사진 게시물을 작성하는 화면이 나오고, POST 방식으로 접근하면 게시물을 제출합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.shortcuts import redirect


def create(request):
    if request.method == &quot;GET&quot;:
        form = PhotoForm()
    elif request.method == &quot;POST&quot;:
        form = PhotoForm(request.POST, request.FILES)

        if form.is_valid():
            obj = form.save()
            return redirect(obj)

    ctx = {
        'form': form,
    }

    return render(request, 'edit.html', ctx)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;request.method&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;GET&lt;/code&gt;인 경우는 기존 코드를 그대로 사용하면 됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;POST&lt;/code&gt; 방식, 즉, 게시물 내용과 파일을 제출 받는 부분을 추가했습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PhotoForm(request.POST, request.FILES)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt; 폼에 첫 번째 인자로 &lt;code class=&quot;highlighter-rouge&quot;&gt;request.POST&lt;/code&gt;를, 두 번째 인자로 &lt;code class=&quot;highlighter-rouge&quot;&gt;request.FILES&lt;/code&gt;를 전달합니다. 첫 번째 인자는 폼에서 다룰 데이터를 뜻하며, 사전형(&lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt;) 객체나 사전형 객체처럼 동작하는(비슷한 인터페이스를 제공하는) 객체&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;여야 합니다. 파일을 제외한 HTML Form에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;POST&lt;/code&gt; 방식으로 전송해온 모든 formdata 데이터가 &lt;code class=&quot;highlighter-rouge&quot;&gt;request.POST&lt;/code&gt;에 있습니다. 파일은 &lt;code class=&quot;highlighter-rouge&quot;&gt;request.FILES&lt;/code&gt;에 있습니다. 그래서, 이 둘을 분리하여 첫 번째 인자, 두 번째 인자로 전달한 것입니다.&lt;/p&gt;

&lt;p&gt;여기까지는 폼에서 처리할 데이터를 인자로 전달하여 설정한 것일 뿐이므로, &lt;code class=&quot;highlighter-rouge&quot;&gt;form = PhotoForm()&lt;/code&gt;와 다를 바 없습니다. 그렇다고 해서 다음과 같이 코드를 작성해서는 안 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    form = PhotoForm()
    if request.method == &quot;POST&quot;:
        form.data = request.POST
        form.files = request.FILES

        if form.is_valid():
            obj = form.save()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django Form은 첫 번째 인자로 넘어온 데이터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; 멤버에, 파일은 &lt;code class=&quot;highlighter-rouge&quot;&gt;files&lt;/code&gt; 멤버에 할당하는 걸 이용한 것인데, Form 클래스로 인스턴스 객체를 생성해 할당하는 과정에서(&lt;code class=&quot;highlighter-rouge&quot;&gt;__init__()&lt;/code&gt;) 인자로 전달된 데이터나 파일이 있으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;is_bound&lt;/code&gt;라는 멤버에 &lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;가 할당되고, 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;is_bound&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;여야만 &lt;code class=&quot;highlighter-rouge&quot;&gt;is_valid()&lt;/code&gt;를 비롯한 폼 검사를 수행하기 때문입니다. 물론,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    if request.method == &quot;POST&quot;:
        form.is_bound = True
        form.data = request.POST
        form.files = request.FILES
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 &lt;code class=&quot;highlighter-rouge&quot;&gt;is_bound&lt;/code&gt;를 직접 &lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;로 할당하면 되지만, &lt;code class=&quot;highlighter-rouge&quot;&gt;form = PhotoForm(request.POST, request.FILES)&lt;/code&gt;라고 코드를 짜면 그만인 것을 굳이 저렇게 짤 필요는 없습니다.&lt;/p&gt;

&lt;p&gt;폼에 검사할 데이터를 전달하여 초기화하여 인스턴스 객체(&lt;code class=&quot;highlighter-rouge&quot;&gt;form&lt;/code&gt;)에는 전달된 데이터를 검사하는 몇 가지 인스턴스 메서드를 제공합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;full_clean()&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;clean()&lt;/code&gt; 메서드가 폼 데이터를 검사하는 데 사용하는 메서드인데, 실제로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;is_valid()&lt;/code&gt; 메서드를 사용하면 됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;is_valid()&lt;/code&gt; 메서드는 폼에 전달된 데이터를 폼 필드를 기준으로 검사하여 모든 데이터가 유효하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;를, 하나라도 유효하지 않은 항목이 있으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;False&lt;/code&gt;를 반환합니다. 동작은 다음과 같습니다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;is_valid()&lt;/code&gt; : 폼 검사와 관련된 오류(error)가 있는 지 검사.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;full_clean()&lt;/code&gt; : &lt;code class=&quot;highlighter-rouge&quot;&gt;_clean_fields()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;_clean_form()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;_post_clean()&lt;/code&gt; 메서드를 차례대로 수행하여 폼 데이터 유효성을 검사.&lt;/li&gt;
  &lt;li&gt;최종 : &lt;code class=&quot;highlighter-rouge&quot;&gt;is_valid()&lt;/code&gt;는 오류(errors)가 없으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;를 반환하고, 있으면 데이터가 유효하지 않아 &lt;code class=&quot;highlighter-rouge&quot;&gt;False&lt;/code&gt;를 반환하며, 어떤 항목에 문제가 유효하지 않은 지 여부는 폼 인스턴스 객체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;errors&lt;/code&gt; 멤버(프로퍼티)에 사전형 객체처럼 생긴 &lt;code class=&quot;highlighter-rouge&quot;&gt;ErrorDict&lt;/code&gt;의 인스턴스 객체로 할당.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;데이터가 모두 유효하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt; 폼의 인스턴스 객체인 &lt;code class=&quot;highlighter-rouge&quot;&gt;form&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드를 실행하고, 이 메서드는 연결된 모델을 이용하여 데이터를 저장합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;save()&lt;/code&gt; 메서드는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ModelForm&lt;/code&gt; 클래스에 있는 메서드인데, 모델 폼에 연결한 모델을 이용하여 데이터를 저장하고 저장한 모델의 인스턴스 객체를 반환합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;PhotoForm&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델을 연결하였으므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델로 생성한 인스턴스 객체를 반환하는 셈이지요.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;return redirect(obj)&lt;/code&gt; 에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;redirect()&lt;/code&gt; 함수는 HTTP Response를 반환하는 Django의 &lt;code class=&quot;highlighter-rouge&quot;&gt;HttpResponseRedirect&lt;/code&gt; 클래스를 이용하여 클라이언트를 지정한 URL로 이동(redirect)시킵니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;render()&lt;/code&gt; 함수처럼 몇 가지 절차를 간편하게 줄여준 함수이며, &lt;code class=&quot;highlighter-rouge&quot;&gt;django.shortcuts&lt;/code&gt; 모듈에 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;redirect(obj)&lt;/code&gt;에서 눈 여겨 볼 부분은 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt;입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;obj&lt;/code&gt; 변수엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델의 인스턴스 객체가 연결되어 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;redirect&lt;/code&gt; 함수는 전달된 객체가 모델의 인스턴스 객체인 경우 그 객체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;get_absolute_url()&lt;/code&gt; 메서드를 호출합니다. 음, 우리는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델에 &lt;code class=&quot;highlighter-rouge&quot;&gt;get_absolute_url()&lt;/code&gt; 인스턴스 메서드를 만든 적이 없습니다. 먼저 만들고 설명하겠습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;photo&lt;/code&gt; 앱 디렉터리 안에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;models.py&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델 클래스에 다음 코드를 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from django.core.urlresolvers import reverse_lazy


class Photo(models.Model):
    # 중략

    def get_absolute_url(self):
        url = reverse_lazy('detail', kwargs={'pk': self.pk})
        return url
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Django Model의 &lt;code class=&quot;highlighter-rouge&quot;&gt;get_absolute_url()&lt;/code&gt; 메서드는 모델의 개별 데이터에 접근하는 URL을 문자열로 반환합니다. 우리는 개별 사진을 보는 URL을 &lt;code class=&quot;highlighter-rouge&quot;&gt;/photos/사진ID/&lt;/code&gt; 패턴으로 제공하므로, 2번 사진은 &lt;code class=&quot;highlighter-rouge&quot;&gt;/photos/2/&lt;/code&gt;, 1023번 사진은 &lt;code class=&quot;highlighter-rouge&quot;&gt;/photos/1023/&lt;/code&gt; URL로 접근합니다. 각 사진의 데이터는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Photo&lt;/code&gt; 모델에 존재하며, 사진 데이터란 모델 클래스의 인스턴스 객체이므로 모델 클래스에 인스턴스 메서드로 &lt;code class=&quot;highlighter-rouge&quot;&gt;get_absolute_url()&lt;/code&gt;를 만드는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get_absolute_url&lt;/code&gt;라는 이름을 반드시 따를 필요는 없으며 없어도 무방합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;permalink()&lt;/code&gt;라는 이름으로 메서드를 만들어도 무방합니다. 다만, &lt;code class=&quot;highlighter-rouge&quot;&gt;get_absolute_url&lt;/code&gt;는 Django가 개별 모델 데이터의 URL을 제공하는 메서드라고 전제해 놓은 관례(conventional) 이름이어서 Django가 알아서 처리하는 감춰진 동작&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;에 사용됩니다. 이런 관례(convention)를 따르면 일일이 지정하고 설정하지 않아도 되어 코드가 간결해집니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reverse_lazy()&lt;/code&gt;는 나중에 좀 더 자세히 다루기로 하고, 이번 편에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;'create'&lt;/code&gt; 이름으로 등록한 URL 패턴에 키워드 인자인 &lt;code class=&quot;highlighter-rouge&quot;&gt;pk&lt;/code&gt;의 값으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;self.pk&lt;/code&gt;를 할당하여 URL 문자열을 가져오는 데 사용했다고 이해하고 넘어가겠습니다.&lt;/p&gt;

&lt;p&gt;사진 게시물을 게시하는 기능을 구현했습니다. 실제로 올려보세요. 잘 게시됩니다.&lt;/p&gt;

&lt;h4 id=&quot;유효하지-않은-폼-항목-오류-출력하기&quot;&gt;유효하지 않은 폼 항목 오류 출력하기&lt;/h4&gt;

&lt;p&gt;혹시 사진으로 이미지 파일을 첨부하지 않거나 이미지 파일이 아닌 파일을 첨부하여 게시물을 첨부해 보셨나요? 강좌 소스 코드대로 잘 따라 오셨다면, 오류 내용이 안내됩니다. 우리는 템플릿 파일 어디에도 폼 오류 안내말을 출력하지 않았는데, 이게 어떻게 된 일일까요? 우리가 템플릿 파일에 폼 관련 내용을 담은 건 고작 한 줄 뿐입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    {{ form.as_p }}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;as_p&lt;/code&gt;로 폼 내용을 HTML로 출력하려 하면, 폼 항목에 오류가 있는 지, 즉, 폼 인스턴스 객체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;errors&lt;/code&gt; 속성에 내용이 있는 지 확인하고, 있다면 오류 내용을 출력합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;{{ form.as_p }}&lt;/code&gt;를 풀어쓰면 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    {% for field in form %}
    &amp;lt;p&amp;gt;
        {% if field.errors %}
        {{ field.errors }}
        {% endif %}

        {{ field }}
    &amp;lt;/p&amp;gt;
    {% endfor %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;form&lt;/code&gt; 템플릿 변수(&lt;code class=&quot;highlighter-rouge&quot;&gt;views.py&lt;/code&gt;에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;form&lt;/code&gt; 객체)는 &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;문으로 순환 가능합니다. 순환하면 폼에 등록된 폼 필드 순서대로 하나씩 폼 필드 객체를 꺼냅니다. 이 필드 객체를 출력하려 하면 이 필드가 생성하는 HTML 내용을 반환하는데, 이 필드 객체에 오류가 있는 경우, 오류 내용이 필드 객체의 &lt;code class=&quot;highlighter-rouge&quot;&gt;errors&lt;/code&gt;에 할당됩니다. 한 폼 필드에 오류 내용은 한 개 이상인 경우도 생기므로 순서열 객체(&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;)에 오류가 하나씩 할당됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;{{ field.errors }}&lt;/code&gt; 마저도 더 풀어쓰면 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        {% if field.errors %}
        &amp;lt;ul&amp;gt;
            {% for error in field.errors %}
            &amp;lt;li&amp;gt;{{error}}&amp;lt;/li&amp;gt;
            {% endfor %}
        &amp;lt;/ul&amp;gt;
        {% endif %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;폼 필드를 직접 명시하여 오류를 확인하는 방법도 있습니다. 예를 들어, 이미지 파일 필드인 &lt;code class=&quot;highlighter-rouge&quot;&gt;image&lt;/code&gt;에 오류가 있는 지 확인하는 방법은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% if form.errors.image %}
    {{form.errors.image}}
{% endif %}

또는

{% if form.image.errors %}
    {{form.image.errors}}
{% endif %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;대개는 Django Form이 자동으로 만들어주는 폼 항목 구성을 그대로 사용하진 않습니다. 각 폼 항목에 CSS나 HTML 속성을 다르게 부여하는데, Django 애플리케이션 개발자가 고치지 않고 Front-end 개발자가 수정하는 경우도 있습니다. 그래서 폼 필드를 구성하는 요소(레이블, 오류, 폼 필드 자체)를 분리해서 위와 같이 다루는 경우가 흔하고, 오히려 &lt;code class=&quot;highlighter-rouge&quot;&gt;{{ form.as_p }}&lt;/code&gt;와 같이 Django에서 만들어내는 HTML 그대로를 사용하는 경우가 드뭅니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;강좌 7편을 마칩니다. 이번 편에서 다룬 Django Form이 동작하는 큰 흐름을 이해하면 앞으로 다룰 Form 세부 요소를 이해하기 쉽습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hannal/start_with_django_webframework/tree/l07&quot;&gt;7편까지 진행한 전체 소스 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/&quot;&gt;Encoding Web Shells in PNG IDAT chunks&lt;/a&gt; 글이나 &lt;a href=&quot;https://blog.sucuri.net/2013/07/malware-hidden-inside-jpg-exif-headers.html&quot;&gt;Malware Hidden Inside JPG EXIF Headers&lt;/a&gt; 글 참조. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://dobest.io/how-csrf-token-works/&quot;&gt;Django와 Rails에서 CSRF Token의 동작 방식&lt;/a&gt;이라는 글을 참조하세요. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;쉼표를 빼서 &lt;code class=&quot;highlighter-rouge&quot;&gt;('filtered_image')&lt;/code&gt;로 표기하면 그냥 문자열 객체가 됩니다. 리스트 객체를 만드는 데 대괄호를(&lt;code class=&quot;highlighter-rouge&quot;&gt;[&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;]&lt;/code&gt;) 사용하고 튜플 객체를 만드는 데 소괄호(&lt;code class=&quot;highlighter-rouge&quot;&gt;(&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;)&lt;/code&gt;)를 활용해서 헷갈리기 일쑤인데, 튜플을 만드는 데에 필요한 건 괄호가 아니라 쉼표(&lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;)입니다. 왜냐하면 쉼표로 항목을 구분하여 나열하며, 괄호는 명시적으로 생략 가능하기 때문입니다. 단, 예외로 아무 항목이 없는 빈 튜플을 만드는 경우엔 그냥 소괄호로 짝지으면 됩니다. 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#tuples&quot;&gt;공식 문서의 Tuples&lt;/a&gt;를 참조하세요. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;사전형 객체처럼 생긴 이런 객체를 인스턴스로 만드는 데 사용하는 클래스(&lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt;)도 &lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt;를 상속받아서 만들어서 &lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt;형이 제공하는 인터페이스를 포함합니다. &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot;&gt;
      &lt;p&gt;“magic”이라는 표현을 씁니다. 뭔가 알아서 수행되는데, 이용자(개발자)가 굳이 알 필요가 없는 내부에 감춰진 동작을 뜻하지요. &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  
  <entry>
    <title>6. Django 정적 파일 기능 이해하기</title>
    <link href="/2015/04/start_with_django_webframework_06/"/>
    <updated>2015-04-27T04:00:49+09:00</updated>
    <id>/2015/04/start_with_django_webframework_06</id>
    <content type="html">&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/category/start-with-django-webframework/&quot;&gt;날로 먹는 Django 웹프레임워크 강좌 목차&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;마지막 갱신일시 : 2017년 1월 29일 22시 30분&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;지난 5회에서 다룬 정적 파일을 Django에서 어떻게 다루는지 자세히 알아 보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;1-django와-정적-파일&quot;&gt;1. Django와 정적 파일&lt;/h3&gt;

&lt;h4 id=&quot;웹-서버와-웹-애플리케이션-그리고-정적-파일&quot;&gt;웹 서버와 웹 애플리케이션, 그리고 정적 파일&lt;/h4&gt;

&lt;p&gt;웹 게시판이나 블로그, 또는 우리가 만들 Pystagram은 웹 프로그램 또는 웹 애플리케이션입니다. 이런 웹 애플리케이션이 필요한 이유는 뭘까요?&lt;/p&gt;

&lt;p&gt;웹 서버는 웹 클라이언트가 특정 위치에(URL) 있는 서버 저장소(storage)에 있는 자원(resource)을 요청(HTTP request) 받아서 제공(serving)하는 응답(HTTP response) 처리가 기본 동작입니다. 이러한 기본 동작은 자원과 접근 가능한 주소가 정적으로 연결된 관계입니다. PC 스토리지의 &lt;code class=&quot;highlighter-rouge&quot;&gt;/Users/hannal/Pictures/private_photo.png&lt;/code&gt; 경로에 사진 파일이 있다고 예를 들면 파일 경로는 웹 주소이고 사진 파일은 자원입니다. 사진 파일을 읽어 들여 보거나 수정하거나 지우는 행위는 HTTP method(GET, POST, PUT, DELETE 등)로 표현합니다. 정리하면 웹 서버는 요청받은 URL과 방식으로 서버에 존재하는 자원을 제공하며, 이 동작을 정적 자원(static resource)을 제공하는 것입니다.&lt;/p&gt;

&lt;p&gt;그런데 사진 파일 자체를 제공하는 데 그치지 않고, 사진에 설명도 달고 댓글도 단다면 자원(사진, 본문, 댓글 등)을 정적으로 제공하는 건 그다지 효율성이 좋지 않습니다. 본문을 수정하거나 댓글을 단다는 건 내용물이 고정되어 있지 않고 언제든지 변하는 상황인데, 언제든지 가변하는 내용물을 고정된 자원으로 제공하려면 내용물이 바뀔 때마다 고정된 자원도 매번 바꿔서 정적인 상태로 만들어야 합니다&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;가변하는 자원을 운용하려면 동적으로 자원을 처리하는 기능을 구현해야 하는데, 웹 서버에 이러한 기능을 추가하는 건 그리 좋은 생각은 아닙니다. 웹 서버는 대부분 C나 C++ 언어로 작성되어 있고, 동적인 웹 자원을 다루는 처리는 대부분 문자열을 가공하는 과정입니다. C나 C++ 언어로 문자열을 다루는 건 불편할 뿐더러 웹 서버에 동적 자원을 다루는 기능을 직접 탑재하는 것도 까다롭습니다. 문자열 가공을 더 쉽게 다루는 다른 언어(Python, Perl 등)로 동적 자원을 처리하는 별도 웹 서버 애플리케이션을 웹 서버와 분리해서 만들고 관리하는 게 낫습니다. 그리고 웹 애플리케이션과 웹 서버가 통신하는 인터페이스를 중간에 두어 서로를 연결합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hannal.com/assets/uploads/2015/04/06-webserver-webapplication.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;django는-정적-파일을-제공하는-실-서비스용-기능을-제공하지-않는다&quot;&gt;Django는 정적 파일을 제공하는 실 서비스용 기능을 제공하지 않는다&lt;/h4&gt;

&lt;p&gt;Django는 실 서비스 환경에서 사용할 정적 파일을 제공하는 기능을 제공하지 않습니다. 서버에 저장된 정적 파일을 읽어들여서 그대로 웹 클라이언트에 보내기만 하면 그만인 단순한 기능인데도 Django는 그런 기능을 제공하지 않습니다. 왜냐하면 그럴 필요가 없기 때문인데, 앞서 설명한 바와 같이 정적 파일을 제공하는 건 웹 서버 전문 영역이기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog.hannal.com/assets/uploads/2015/04/06-webserver-static_resources.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;게다가 웹 애플리케이션은 웹 서버와 연결하는 중간 인터페이스를 거치므로 효율이 더 떨어집니다.&lt;/p&gt;

&lt;p&gt;하지만 개발 상황인 경우는 효율보다는 기능(역할)이 중요한 경우가 많습니다. 정적 파일이 제대로 제공되는지 확인하려고 항상 웹 서버를 구동할 필요는 없습니다. Django는 개발 단계에서 쓸 정적 파일 제공 기능을 제공합니다. 성능은 웹 서버가 직접 정적 파일을 제공하는 것 보다 떨어지지만 정적 파일 제공에 필요한 기능은 대부분 지원합니다.&lt;/p&gt;

&lt;h4 id=&quot;static-file과-media-file&quot;&gt;Static file과 Media file&lt;/h4&gt;

&lt;p&gt;Django은 정적 파일을 크게 두 종류로 구분합니다.&lt;/p&gt;

&lt;p&gt;Static file은 Javascript, CSS, Image 파일처럼 웹 서비스에서 사용하려고 미리 준비해 놓은 정적 파일입니다. 파일 자체가 고정되어 있고, 서비스 중에도 수시로 추가되거나 변경되지 않고 고정되어 있습니다.&lt;/p&gt;

&lt;p&gt;Media file은 이용자가 웹에서 올리는(upload) 파일입니다. 파일 자체는 고정되어 이지만, 언제 어떤 파일이 정적 파일로 제공되고 준비되는지 예측할 수 없습니다.&lt;/p&gt;

&lt;p&gt;Static file과 Media file은 정적 파일이라는 점에서는 같지만, 정적 파일을 제공하는 상황을 예측할 수 있는지 여부는 다릅니다. Static file은 서비스에 필요한 정적 파일을 미리 준비해놓기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py&lt;/code&gt; 도구에 &lt;code class=&quot;highlighter-rouge&quot;&gt;findstatic&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;collectstatic&lt;/code&gt;이라는 기능으로 정적 파일을 모으고 찾는 관리 기능을 제공합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py&lt;/code&gt;은 Django 프로젝트를 관리하는 일에 필요한 기능을 명령줄 쉘(shell)에서 수행하는 도구입니다. 그에 반해 Media file은 이용자가 웹에서 올리는 파일이므로 미리 예측해서 준비할 수 없습니다. 그래서 Static file 관련된 관리 기능인 &lt;code class=&quot;highlighter-rouge&quot;&gt;findstatic&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;collectstatic&lt;/code&gt; 기능을 사용하지 못합니다.&lt;/p&gt;

&lt;h3 id=&quot;2-static-file&quot;&gt;2. Static file&lt;/h3&gt;

&lt;p&gt;Static file은 웹 서비스에 사용할 정적 파일을 미리 준비하여 제공하는 데 사용합니다. Django로 운영되는 프로젝트의 설정을 관리하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;에 Static file와 관련된 항목이 다섯 가지 존재하며, 보통은 다음 세 가지를 사용합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_URL&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;staticfiles_dirs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;은 개발 단계에서 사용하는 정적 파일이 위치한 경로들을 지정하는 설정 항목입니다. 특정 Django App&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;에만 사용하는 정적 파일이 있거나 혹은 정적 파일을 관리하기 용이하게 하기 위해 여러 경로(path)에 정적 파일을 배치하였다면, 이 경로들을 Python의 &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;tuple&lt;/code&gt;로 담으면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;STATICFILES_DIRS = (
    os.path.join(BASE_DIR, 'static'),
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;대개는 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;이라는 디렉터리에 정적 파일을 담습니다. 주의할 점은 정적 디렉터리 경로가 하나이더라도 반드시 &lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;tuple&lt;/code&gt;로 담아야 한다는 점입니다. 흔히 하는 실수는 다음과 같이 항목 뒤에 쉼표를 빠뜨리는 것입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;STATICFILES_DIRS = (
    os.path.join(BASE_DIR, 'static')
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 경우 Django는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ImproperlyConfigured: Your STATICFILES_DIRS setting is not a tuple or list; perhaps you forgot a trailing comma?&lt;/code&gt;라는 경고를 출력하며 정적 파일을 제대로 제공(serving)하지 못합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py&lt;/code&gt;에서 제공하는 명령어 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;findstatic&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;에 설정한 경로에서 지정한 정적 파일을 찾습니다. 실습해보지요. &lt;a href=&quot;http://jquery.com/download/&quot;&gt;jQuery download&lt;/a&gt;에서 “Download the compressed, production jQuery x.x.x”로 된 링크를 찾은 뒤 그 링크에 걸려있는 jQuery 파일을 내려 받습니다. 이 강좌를 쓰는 시점에서 저는 2.1.3판을 받았습니다. 이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py&lt;/code&gt; 파일이 있는 경로에 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;이라는 이름으로 디렉터리를 만들고, 다시 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 디렉터리 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;js&lt;/code&gt;라는 디렉터리를 만든 다음에 &lt;code class=&quot;highlighter-rouge&quot;&gt;js&lt;/code&gt; 디렉터리에 내려 받은 jQuery 파일을 넣습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;에는 앞서 나온 예시대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt; 항목을 추가합니다. 이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;findstatic&lt;/code&gt; 명령어로 파일을 찾아 보겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python manage.py findstatic js/jquery-2.1.3.min.js
Found 'jquery-2.1.3.min.js' here:
  /(중략)/pystagram/static/js/jquery-2.1.3.min.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;물론 &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; 기호는 입력하지 않습니다. 쉘의 프롬프트 기호이니까요.&lt;/p&gt;

&lt;p&gt;이번엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;os.path.join(BASE_DIR, 'static2')&lt;/code&gt; 항목을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;STATICFILES_DIRS = (
    os.path.join(BASE_DIR, 'static'),
    os.path.join(BASE_DIR, 'static2'),
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;그런 뒤 &lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py&lt;/code&gt; 파일이 있는 경로에 &lt;code class=&quot;highlighter-rouge&quot;&gt;static2&lt;/code&gt; 디렉터리를 만들고 이 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;js&lt;/code&gt; 디렉터리를 만들어서 그곳에 jQuery 파일을 복사합니다. 마지막으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;photo&lt;/code&gt; 디렉터리(Django &lt;code class=&quot;highlighter-rouge&quot;&gt;photo&lt;/code&gt; 앱)에 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 디렉터리를 만들고 이 디렉터리에 jQuery 파일을 복사하고, 또 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 디렉터리 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;js&lt;/code&gt; 디렉터리를 더 만든 뒤 그 안에 jQuery 파일을 복사합니다. 디렉터리 구조는 다음과 같으며, 강좌 연재가 너무 지연되어서 &lt;code class=&quot;highlighter-rouge&quot;&gt;photo&lt;/code&gt; 디렉터리가 뭔지 기억이 나지 않는다면 “&lt;a href=&quot;http://blog.hannal.com/2014/9/start_with_django_webframework_03/&quot;&gt;3. Photo 앱과 모델 만들기&lt;/a&gt;”편을 참고하시길 바랍니다. :)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;.&lt;/li&gt;
  &lt;li&gt;static/
    &lt;ul&gt;
      &lt;li&gt;js/&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;static2/
    &lt;ul&gt;
      &lt;li&gt;js/&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;photos/
    &lt;ul&gt;
      &lt;li&gt;static/&lt;/li&gt;
      &lt;li&gt;static/js/&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그런 뒤 다음 세 줄을 실행하여 화면에 나온 결과가 무엇을 의미하는지 고민해 보세요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python manage.py findstatic jquery-2.1.3.min.js
$ python manage.py findstatic js/jquery-2.1.3.min.js
$ python manage.py findstatic javascript/jquery-2.1.3.min.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;충분히 고민하셨으리라 믿습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;js/jquery-2.1.3.min.js&lt;/code&gt;를 찾으려 하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 디렉터리에 있는 것과 &lt;code class=&quot;highlighter-rouge&quot;&gt;static2&lt;/code&gt; 디렉터리에 있는 것, 그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos/static&lt;/code&gt; 디렉터리에 있는 것이 나타납니다. 나타난 순서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;static2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;photos/static&lt;/code&gt; 디렉터리 순인데, 이 배치된 순서는 실제로 정적 파일을 찾아다 사용할 때 우선순위로 작용합니다. 이 우선순위는 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;에 명기된 디렉터리가 더 상위인데, &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_FINDERS&lt;/code&gt;라는 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 설정 항목에서 기본 파일 시스템 파인더(finder)가 Django App 디렉터리보다 상위순위로 지정되어 있기 때문입니다.&lt;/p&gt;

&lt;p&gt;이와 같이 정적 파일 경로가 일치할 경우 우선순위에 따라 실제 사용하는 정적 파일이 결정됩니다. 실제 물리 경로는 그대로 유지하지만 우선순위 문제를 겪지 않으려면 접두사(prefix)를 붙여서 구분하면 됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;static2&lt;/code&gt;는 이제 곧 지울 항목이니까 &lt;code class=&quot;highlighter-rouge&quot;&gt;byebye&lt;/code&gt;라는 접두사를 쓰겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;STATICFILES_DIRS = (
    os.path.join(BASE_DIR, 'static'),
    ('byebye', os.path.join(BASE_DIR, 'static2'),),
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 설정을 적용하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;static2&lt;/code&gt; 디렉터리가 마치 &lt;code class=&quot;highlighter-rouge&quot;&gt;byebye&lt;/code&gt;라는 디렉터리 안에 위치한 것처럼 &lt;code class=&quot;highlighter-rouge&quot;&gt;static2&lt;/code&gt;에 있는 정적 파일에 접근해야 합니다. 다음 두 명령을 실행해 보세요.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python manage.py findstatic js/jquery-2.1.3.min.js
$ python manage.py findstatic byebye/js/jquery-2.1.3.min.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;static_url&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_URL&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_URL&lt;/code&gt;은 웹 페이지에서 사용할 정적 파일의 최상위 URL 경로입니다. 이 최상위 경로 자체는 실제 파일이나 디렉터리가 아니며, URL로만 존재하는 단위입니다. 그래서 이용자 마음대로 정해도 무방하며, 저는 &lt;code class=&quot;highlighter-rouge&quot;&gt;assets&lt;/code&gt;라는 URL 경로를 쓰겠습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;STATIC_URL = '/assets/'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;문자열은 반드시 &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;로 끝나야 합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;findstatic&lt;/code&gt; 명령어로 탐색되는 정적 파일 경로에 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_URL&lt;/code&gt; 경로를 합치면 실제 웹에서 접근 가능한 URL이 됩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;findstatic js/jquery-2.1.3.min.js&lt;/code&gt; : http://pystagram.com&lt;strong&gt;/assets/js/jquery-2.1.3.min.js&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;findstatic byebyejs/jquery-2.1.3.min.js&lt;/code&gt; : http://pystagram.com&lt;strong&gt;/assets/byebye/js/jquery-2.1.3.min.js&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_URL&lt;/code&gt;은 정적 파일이 실제 위치한 경로를 참조하며, 이 실제 경로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt; 설정 항목에 지정된 경로가 아닌 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt; 설정 항목에 지정된 경로입니다. 그런데 &lt;code class=&quot;highlighter-rouge&quot;&gt;static2&lt;/code&gt; 경로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;byebye&lt;/code&gt; 접두사가 붙어서 실제 물리 경로와 다릅니다. 이에 대해선 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt;에서 자세히 다루겠습니다.&lt;/p&gt;

&lt;h4 id=&quot;static_root&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt;는 Django 프로젝트에서 사용하는 모든 정적 파일을 한 곳에 모아넣는 경로입니다. 한 곳에 모으는 기능은 &lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py&lt;/code&gt; 파일의 &lt;code class=&quot;highlighter-rouge&quot;&gt;collectstatic&lt;/code&gt; 명령어로 수행합니다. Django가 모든 파일을 검사하여 정적 파일로 사용하는지 여부를 확인한 뒤 모으는 건 아니고, 각 Django 앱 디렉터리에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 디렉터리와 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;에 지정된 경로에 있는 모든 파일을 모읍니다.&lt;/p&gt;

&lt;p&gt;개발 과정에선, 정확히는 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;DEBUG&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;로 설정되어 있으면 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt; 설정은 작용하지 않으며, &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt;는 실 서비스 환경을 위한 설정 항목입니다. 그래서 개발 과정에선 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt;에 지정한 경로가 실제로 존재하지 않거나 아예 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt; 설정 항목 자체가 없어도 문제없이 동작합니다.&lt;/p&gt;

&lt;p&gt;그렇다면 실 서비스 환경에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt;는 왜 필요할까요? 이 경로에 있는 모든 파일을 웹 서버가 직접 제공(serving)하기 위함입니다. 실제 실습하며 확인해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;에 다음과 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt; 설정 항목을 추가합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;tuple&lt;/code&gt;형인 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;와는 달리 문자열 경로를 할당합니다. 이제 &lt;code class=&quot;highlighter-rouge&quot;&gt;collectstatic&lt;/code&gt; 명령어로 현 프로젝트가 사용하는 모든 정적 파일을 모읍니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ python manage.py collectstatic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;지정한 경로에 있는 기존 파일을 전부 덮어 쓰는데 정말로 모을 거냐고 묻습니다. 원본 파일을 덮어 쓰는 게 아니니 &lt;code class=&quot;highlighter-rouge&quot;&gt;yes&lt;/code&gt;라고 입력합니다. 정적 파일을 모을 경로를 &lt;code class=&quot;highlighter-rouge&quot;&gt;manage.py&lt;/code&gt; 파일이 있는 경로에 &lt;code class=&quot;highlighter-rouge&quot;&gt;staticfiles&lt;/code&gt; 디렉터리로 지정했으므로 이 디렉터리가 만들어지고, 이 안에 사용하는 모든 정적 파일이 &lt;strong&gt;복사&lt;/strong&gt;됩니다. 이 디렉터리 안을 보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;에 넣은 경로들 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;byebye&lt;/code&gt;라는 접두사를 붙인 디렉터리도 보입니다.&lt;/p&gt;

&lt;p&gt;이렇게 정적 파일을 모아놓은 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt;는 Django가 직접 접근하진 않습니다. Django가 접근하여 다루는 설정은 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;이며, &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt;는 정적 파일을 직접 제공(serving)할 웹 서버가 접근합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;collectstatic&lt;/code&gt; 명령어를 수행하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;나 앱 디렉터리에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 디렉터리 안에 있는 파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt;에 모으는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;에 지정된 경로인 경우 따로 명시한 접두사으로 디렉터리를 만들어 그 안에 파일을 복사하고, 앱 디렉터리에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 디렉터리인 경우는 앱 이름으로 디렉터리를 만들어 그 안에 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 디렉터리 안에 있는 파일을 복사합니다. 즉, 개발 단계(&lt;code class=&quot;highlighter-rouge&quot;&gt;DEBUG = True&lt;/code&gt;)에서는 정적 파일 URL 경로가 논리 개념이고, 서비스 환경(&lt;code class=&quot;highlighter-rouge&quot;&gt;DEBUG = False&lt;/code&gt;)에서는 실제 물리 개념인 정적 파일 URL 경로가 되는 것입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 경로가 동일해서 우선순위가 발생하는 경우에 &lt;code class=&quot;highlighter-rouge&quot;&gt;collectstatic&lt;/code&gt;을 수행하면 어떤 파일이 실제로 복사될까요? 물론 1순위 경로에 위치한 파일이 복사됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;photos/js/jquery-2.1.3.min.js&lt;/code&gt; 파일을 열어서 내용을 몽땅 지워서 0 byte 파일로 만들고, &lt;code class=&quot;highlighter-rouge&quot;&gt;collected_static&lt;/code&gt; 디렉터리를 지운 뒤에 다시 &lt;code class=&quot;highlighter-rouge&quot;&gt;collectstatic&lt;/code&gt; 명령어를 실행해 보세요. &lt;code class=&quot;highlighter-rouge&quot;&gt;collected_static&lt;/code&gt; 디렉터리 안의 &lt;code class=&quot;highlighter-rouge&quot;&gt;js&lt;/code&gt; 디렉터리 안에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;jquery-2.1.3.min.js&lt;/code&gt; 파일을 보면 0 byte인 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos/js/jquery-2.1.3.min.js&lt;/code&gt;이 아닌 정상 파일인 &lt;code class=&quot;highlighter-rouge&quot;&gt;js/jquery-2.1.3.min.js&lt;/code&gt;이 복사되어 있습니다.&lt;/p&gt;

&lt;p&gt;주의할 점. &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt; 경로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt; 등록된 경로와 같은 경로가 있어서는 안 됩니다. 남들이 잘 안 쓸만한 이상한 이름(&lt;code class=&quot;highlighter-rouge&quot;&gt;staticfiles&lt;/code&gt;?)을 쓰세요.&lt;/p&gt;

&lt;h4 id=&quot;djangocontribstaticfiles&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;'django.contrib.staticfiles'&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;개발 단계에서 정적 파일을 제공(serving)하는 기능은 Django에서 제공하는데, 사용 방법은 아주 간단합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;django.conf.urls.static&lt;/code&gt; 모듈에 있는 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 함수를 이용해 URL 패턴을 만들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;urlpatterns&lt;/code&gt;에 추가하는 것입니다. 지난 5회 강좌분에서 이미 사용한 바로 그 방식입니다. 이 함수를 조금 더 살펴볼까요?&lt;/p&gt;

&lt;p&gt;이 함수를 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에서 URL 패턴을 만드는 데 사용한 걸 보면 이 함수 자체가 정적 파일을 제공한다기 보다는 정적 파일 URL에 그런 기능을 하는 무언가를 연결할 것이라 예상되지요? 실제로 그렇게 동작합니다. 정적 파일에 접근할 URL 접두사(&lt;code class=&quot;highlighter-rouge&quot;&gt;staticfiles&lt;/code&gt;)를 첫 번째 인자로 넣고 정적 파일이 위치한 경로를 &lt;code class=&quot;highlighter-rouge&quot;&gt;document_root&lt;/code&gt;라는 키워드 인자로 전달하면, 이런 내용을 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.views.static.serve&lt;/code&gt;라는 뷰 함수가 사용합니다. 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;serve&lt;/code&gt; 함수는 서버에 위치한 파일을 읽어서(&lt;code class=&quot;highlighter-rouge&quot;&gt;open(fullpath, 'rb')&lt;/code&gt;) 스트리밍 방식으로 응답(&lt;code class=&quot;highlighter-rouge&quot;&gt;StreamingHttpResponse&lt;/code&gt;)합니다. 실제 파일 서빙을 하는 것입니다. 물론 성능은 웹 서버가 직접 서빙하는 것보다 떨어지므로 개발 단계에서만 쓰는 게 좋을텐데, &lt;code class=&quot;highlighter-rouge&quot;&gt;django.conf.urls.static&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 함수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;DEBUG&lt;/code&gt;가 True인 경우에만 이런 정적 파일 제공에 필요한 URL 패턴을 만듭니다. 간단히 말해서 &lt;code class=&quot;highlighter-rouge&quot;&gt;DEBUG=True&lt;/code&gt;인 경우에만 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 함수는 우리가 원하고 기대하는 동작을 합니다.&lt;/p&gt;

&lt;p&gt;그런데 &lt;strong&gt;Static file&lt;/strong&gt;은 이런 처리를 하지 않아도 개발 단계에서는 잘 제공(serving)됩니다. Media file(업로드 파일)은 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에 &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 함수를 사용해 정적 파일을 제공하도록 강제했지만, Static file은 그런 처리를 하지 않아도 저절로 제공(serving)됩니다. 이런 &lt;strong&gt;저절로&lt;/strong&gt; 동작하는 기능은 Django 프레임워크에 내장된 Django App인 &lt;code class=&quot;highlighter-rouge&quot;&gt;'django.contrib.staticfiles'&lt;/code&gt;가 맡고 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt; 파일을 열어서 &lt;code class=&quot;highlighter-rouge&quot;&gt;INSTALLED_APPS&lt;/code&gt; 항목을 보면 우리가 앞서 추가한 &lt;code class=&quot;highlighter-rouge&quot;&gt;'photos'&lt;/code&gt; 외에도 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib&lt;/code&gt;으로 시작하는 몇 가지가 더 있는데, 그 중에 &lt;code class=&quot;highlighter-rouge&quot;&gt;'django.contrib.staticfiles'&lt;/code&gt;가 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;'django.contrib.admin'&lt;/code&gt; 항목을 보니 지난 강좌에서 사용해 본 Django admin 기능도 Django App이라는 걸 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.staticfiles&lt;/code&gt; 앱에는 이 앱이 사용하는 URL 패턴을 담은 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt; 파일이 있는데, 이 파일 내용은 다음과 같습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def staticfiles_urlpatterns(prefix=None):
    &quot;&quot;&quot;
    Helper function to return a URL pattern for serving static files.
    &quot;&quot;&quot;
    if prefix is None:
        prefix = settings.STATIC_URL
    return static(prefix, view='django.contrib.staticfiles.views.serve')

# Only append if urlpatterns are empty
if settings.DEBUG and not urlpatterns:
    urlpatterns += staticfiles_urlpatterns()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;단순하지요? &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_URL&lt;/code&gt; 항목의 URL에 &lt;code class=&quot;highlighter-rouge&quot;&gt;django.contrib.staticfiles.views.serve&lt;/code&gt; 뷰 함수를 연결했는데, 이 내용은 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.DEBUG&lt;/code&gt;가 &lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;인 경우에 반영됩니다.&lt;/p&gt;

&lt;h4 id=&quot;정리&quot;&gt;정리&lt;/h4&gt;

&lt;p&gt;정리하면, 정적 파일이 있는 경로를 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;에 지정하면 개발 단계에서는 더 신경쓸 게 없습니다.&lt;/p&gt;

&lt;h3 id=&quot;3-media-file&quot;&gt;3. Media file&lt;/h3&gt;

&lt;h4 id=&quot;간단히-설명&quot;&gt;간단히 설명&lt;/h4&gt;

&lt;p&gt;Media file은 이용자가 웹에서 업로드한 정적 파일입니다. 미리 준비해놓고 제공하는 Static file과는 달리 언제 어떤 파일이 추가될 지 모르므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;findstatic&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;collectstatic&lt;/code&gt;같은 명령어는 Media file에 대해서는 무의미합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;에 Media file와 관련된 항목이 두 가지 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MEDIA_ROOT&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MEDIA_URL&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;파일 업로드와 관련하여 세부 조정하는 설정이 몇 가지 더 있지만, 대개는 기본 설정(&lt;code class=&quot;highlighter-rouge&quot;&gt;global_settings&lt;/code&gt;)대로 써도 무방합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MEDIA_ROOT&lt;/code&gt;는 이름이 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt;과 비슷한데, 업로드가 끝난 파일을 배치할 최상위 경로를 지정하는 설정 항목입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt;보다는 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;이 더 비슷한 역할을 하는데, &lt;a href=&quot;https://docs.djangoproject.com/en/dev/releases/1.3/#extended-static-files-handling&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;STATICFILES_DIRS&lt;/code&gt;는 Django 1.3판에 새롭게 도입&lt;/a&gt;된 설정이자 기능이다 보니 설정 항목 이름을 미처 교통정리하지 못했나 봅니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;MEDIA_ROOT&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_ROOT&lt;/code&gt;와 다른 경로를 지정해야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MEDIA_URL&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_URL&lt;/code&gt;과 이름도 비슷하고 역할도 비슷합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;/&lt;/code&gt;로 끝나는 URL 경로 문자열로 설정해야 한다는 점도 같습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;MEDIA_URL&lt;/code&gt;도 &lt;code class=&quot;highlighter-rouge&quot;&gt;MEDIA_ROOT&lt;/code&gt;와 마찬가지로 &lt;code class=&quot;highlighter-rouge&quot;&gt;STATIC_URL&lt;/code&gt;과 URL 경로가 달라야 합니다.&lt;/p&gt;

&lt;p&gt;주요 개념을 Static file 영역에서 설명하니 Media file은 간결하게 정리 되는군요.&lt;/p&gt;

&lt;h4 id=&quot;지난-media-file-관련-코드-수정&quot;&gt;지난 Media file 관련 코드 수정&lt;/h4&gt;

&lt;p&gt;지난 5회에서 Media file 관련 설정을 하며 models.py 파일도 고쳤습니다. 이에 대한 내용을 설명하겠습니다.&lt;/p&gt;

&lt;p&gt;먼저 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings.py&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;MEDIA_URL&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;MEDIA_ROOT&lt;/code&gt; 부분을 추가했습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MEDIA_URL = '/upload_files/'

MEDIA_ROOT = os.path.join(BASE_DIR, 'uploads')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Media file에 접근하는 URL이 &lt;code class=&quot;highlighter-rouge&quot;&gt;/upload_files/&lt;/code&gt;로 시작하며, 실제 파일이 위치하는 서버 상 경로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;MEDIA_ROOT&lt;/code&gt;에 할당했습니다.&lt;/p&gt;

&lt;p&gt;다음엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;urls.py&lt;/code&gt;에 Media file을 제공(serving)하는 URL 패턴 등록 부분을 고쳤습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;urlpatterns += static('/upload_files/', document_root=settings.MEDIA_ROOT)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; 함수에 첫 번째 인자로 Media file URL을, 키워드 인자 &lt;code class=&quot;highlighter-rouge&quot;&gt;document_root&lt;/code&gt;로 Media file이 위치한 경로를 전달했습니다.&lt;/p&gt;

&lt;p&gt;마지막으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;photos&lt;/code&gt; 앱의 &lt;code class=&quot;highlighter-rouge&quot;&gt;models.py&lt;/code&gt; 파일에서 이미지 파일이 저장될 경로를 지정한 &lt;code class=&quot;highlighter-rouge&quot;&gt;upload_to&lt;/code&gt; 필드 옵션을 고쳤습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Photo(models.Model):
    image = models.ImageField(upload_to='%Y/%m/%d/orig')
    filtered_image = models.ImageField(upload_to='%Y/%m/%d/filtered')
    # 후략
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;upload_to='uploads/%Y/%m/%d/orig'&lt;/code&gt; 부분에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;uploads/&lt;/code&gt;를 떼버린 것입니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;uploads&lt;/code&gt;는 이미 &lt;code class=&quot;highlighter-rouge&quot;&gt;MEDIA_ROOT&lt;/code&gt;에 지정되어 있으므로 더이상 업로드 경로에 넣을 필요가 없습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;강좌 6편을 마칩니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/hannal/start_with_django_webframework/tree/l06&quot;&gt;6편까지 진행한 전체 소스 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;2015년 4월 기준으로 제 블로그는 실제로 이런 방식으로 운영합니다. 그다지 자주 내용물을 고치거나 새로 만들지 않기 때문에 오히려 정적으로 자원을 제공하는 것이 더 효율성 있기 때문입니다. 주 자원은 &lt;a href=&quot;https://pages.github.com/&quot;&gt;Github Pages&lt;/a&gt;라는 기능을 이용하여 제공하고, 가변하는 내용물인 댓글은 &lt;a href=&quot;https://disqus.com/&quot;&gt;Disqus&lt;/a&gt;라는 서비스를 이용하여 본문에서 분리해서 운영합니다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;Django로 생성한 프로젝트를 Django 프로젝트라 하고, Django 프로젝트는 뭔가를 수행하는 기능 단위인 Django App을 모아놓은 좀 더 큰 단위입니다. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  
  <entry>
    <title>예전엔 말이야</title>
    <link href="/2015/04/kill-once_upon_a_time/"/>
    <updated>2015-04-05T08:57:49+09:00</updated>
    <id>/2015/04/kill-once_upon_a_time</id>
    <content type="html">&lt;p&gt;요즘,&lt;br /&gt;
대화 중에 옛날에 이런 게 있었다거나 이게 10년 전에는 이러했다거나 처음 이 일을 시작한 게 20년 전이라거나 또는 내 세대 때는 이러한 일이 있었는데 라는 표현을 자주 쓴다. 그런 표현을 무심코 내뱉다가 바로 아차!하며 표현을 바꾸려 하지만 이미 나간 말이라 거둘 방법이 없다. 꼰대스러워서 쓰지 않겠다고 매번 다짐하지만 어쩐지 갈수록 더 자주 쓰고 있다.&lt;/p&gt;

&lt;p&gt;이야기 주제에 초점을 맞추면 그만이다. &lt;strong&gt;묻지도 않은&lt;/strong&gt; 지난 경험을 말하는 건 향신료로 요리에 넣지 않은 재료의 맛과 향을 흉내내는 것과 다를 바 없다. 이야기 주제에 자신없기 때문에 나오는 방어 심리이다.&lt;/p&gt;

&lt;p&gt;겸손 여부는 문제 원인이 아니다. 난 아직 겸손하고 말고 할 수준도 못 될만큼 공부하고 경험하는 단계이다. 능력을 발휘해 돈을 벌고 누군가를 가르치기도 하지만, 내가 뛰어나서 그렇다기 보다는 현재 내 능력이 필요한 이들이 있어 기여하고, 내 경험과 지식 수준이 필요한 이들이 있어서 가르칠 수 있기 때문이라고 여긴다. 세상엔 다양성이 존재하니까.&lt;/p&gt;

&lt;p&gt;고민한 끝에 몸과 마음에 여유가, 그리고 생활에 잉여가 부족하기 때문이라는 결론을 내렸다. 각 대상에 대해 많이 생각하지 못하고 경험도 부족하니, 대상의 본질에 대해 생각을 표현하지 못하고 자꾸 과거 경험치를 꺼내는 것이다.&lt;/p&gt;

&lt;p&gt;더이상 꼰대스러운 행동이나 말투, 생각이 내 안에서 일어나는 걸 용납하지 않겠다. 건강과 여유보다 중요하지 않은 일을 줄여야겠다. 잉여를 되살려 경험과 관점을 깊고 풍부하게 만드는 데 쓰겠다.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Python 3에서 함수의 키워드 인자 강제와 주석문</title>
    <link href="/2015/03/keyword-only-arguments_and_annotations_for_python3/"/>
    <updated>2015-03-22T01:50:49+09:00</updated>
    <id>/2015/03/defining_function_for_python3_statement</id>
    <content type="html">&lt;p&gt;Python 3에 도입된 함수 선언 문법 중 키워드 인자를 강제하는 방법과 주석문(&lt;code class=&quot;highlighter-rouge&quot;&gt;annotation&lt;/code&gt;)이 있다. Python의 매력 요소 중 하나가 깔끔하고 명료한 코드라 생각하는데, 이 두 문법은 기호를 남발하는 코드처럼 보여서 좀 불만스럽지만 코드 문맥(context)을 읽는 데엔 참 유익하다. 그나마 &lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt; 기호가 사용되는 건 아니라서 다행이랄까?! :)&lt;/p&gt;

&lt;h3 id=&quot;위치-인자-개수-지정&quot;&gt;위치 인자 개수 지정&lt;/h3&gt;

&lt;p&gt;Python은 함수 매개 인자 방식으로 위치 인자(positional argument)와 키워드 인자(keywords argument)를 지원한다. 위치 인자는 함수로 전달하는 매개 인자를 순서대로 나열하는 것이고, 키워드 인자는 인자 이름과 인자에 할당할 값을 특정하는 것이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def args_func(arg1, arg2, arg3):
    print(arg1, arg2, arg3)

args_func('hello', 'world', '!')
args_func('!', arg3='hello', arg2='world')
args_func('world', arg3='!', arg2='hello')
args_func('hello', '!', arg3='world')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위 코드에서&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;args_func('hello', 'world', '!')&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello world !&lt;/code&gt;를 출력하고,&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;args_func('!', arg3='hello', arg2='world')&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;! world hello&lt;/code&gt;를 출력한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;args_func('world', arg3='!', arg2='hello')&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;world hello !&lt;/code&gt;를 출력하며,&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;args_func('hello', '!', arg3='world')&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello ! world&lt;/code&gt;를&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;출력한다. 위치 인자, 키워드 인자 순서로 전달만 하면 어떤 인자를 위치 인자로 전달하고, 어떤 인자를 키워드 인자로 전달하는지에 별다른 제한은 없다.&lt;/p&gt;

&lt;p&gt;Python 3는 키워드 인자를 강제하는 문법을 지원한다. 바로 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 문자를 쓰는 것이다&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def args2_func(arg1, *, arg2, arg3):
    print(arg1, arg2, arg3)

args2_func('hello', 'world', '!')
args2_func('!', arg3='hello', arg2='world')
args2_func('world', arg3='!', arg2='hello')
args2_func('hello', '!', arg3='world')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 이후에 나열된 매개 인자는 반드시 키워드 인자로 전달돼야 한다. 위 코드에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;args2_func&lt;/code&gt; 함수를 실행하는 네 개 실행 줄 중 첫 번째와 네 번째는 &lt;code class=&quot;highlighter-rouge&quot;&gt;TypeError&lt;/code&gt; 예외가 일어난다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: args2_func() takes 1 positional argument but 3 were given
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;args2_func&lt;/code&gt; 함수는 위치 인자를 1개 취하는데, 이 개수보다 많은 인자가 위치 인자로 전달되었다는 뜻이다.&lt;/p&gt;

&lt;p&gt;그렇다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 이전에 나열된 매개 인자를 키워드 인자로 값을 전달하면 어떻게 될까?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;args2_func(arg1='hello', arg2='world', arg3='!')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;아무 문제도 발생하지 않는다. 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;는 위치 인자 개수를 특정하거나(exact) &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 앞에 나열된 인자를 위치 인자로 강제하는 것이 아니라 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 이후에 나열되는 인자는 반드시 키워드 인자로 전달 받도록 강제하는 것이다. 만약 위치 인자를 단 한 개도 허용하지 않고자 한다면 다음과 같이 함수 매개 인자를 선언하면 된다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def kwargs_func(*, arg1, arg2, arg3):
    print(arg1, arg2, arg3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이 함수는 모든 매개 인자를 키워드 인자로 전달해야 한다.&lt;/p&gt;

&lt;h3 id=&quot;주석문-annotation&quot;&gt;주석문 (annotation)&lt;/h3&gt;

&lt;p&gt;annotation 문법은 함수 매개 인자와 반환 값에 대한 주석(annotation)을 지정하는 것이다&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def anno_func(arg1: str, arg2: 'also str', arg3: 1 is True) -&amp;gt; bool:
    print(arg1, arg2, arg3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;표현된 코드를 보면 마치 인자의 형(&lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt;)을 지정하는 것 같지만, 실제로는 주석이기 때문에 인자의 형이 무엇이 되든 영향을 받지 않아서 다음과 같이 함수를 호출해도 아무 문제가 발생하지 않는다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;anno_func(1, True, 'world')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;반환하는(return) 값의 형도 주석으로 설명한 것과 달라도 무방하다. &lt;code class=&quot;highlighter-rouge&quot;&gt;anno_func&lt;/code&gt;은 주석으로 반환 값을 &lt;code class=&quot;highlighter-rouge&quot;&gt;bool&lt;/code&gt;이라 명기했지만, 실제로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt;문이 따로 없기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;None&lt;/code&gt; 값을 반환한다. 물론, 아무 문제도 없다.&lt;/p&gt;

&lt;p&gt;이렇게 지정한 주석은 함수 객체에 &lt;code class=&quot;highlighter-rouge&quot;&gt;__annotations__&lt;/code&gt; 속성에 담겨 있으며, 사전형(&lt;code class=&quot;highlighter-rouge&quot;&gt;dict&lt;/code&gt;) 객체이다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(anno_func.__annotations__)
print(anno_func.__annotations__['arg1'])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;재밌는 점은 &lt;code class=&quot;highlighter-rouge&quot;&gt;__annotations__&lt;/code&gt;에는 주석으로 지정한 값(&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;)이 그대로 할당되어 있다는 점이다. 이 점을 이용하면 함수 매개 인자를 특정할 수 있다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def static_args_func(arg1: str, arg2: str, arg3: int) -&amp;gt; bool:
    args = locals()
    for _k, _v in args.items():
        arg_type = static_args_func.__annotations__[_k]

        if isinstance(_v, arg_type):
            continue

        raise TypeError(
            &quot;The type of '{}' does not match '{}' type&quot;.format(
                _k, arg_type.__name__
            )
        )
    print(arg1, arg2, arg3)

static_args_func(1, 2, 3)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;static_args_func&lt;/code&gt; 함수의 &lt;code class=&quot;highlighter-rouge&quot;&gt;arg1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;arg2&lt;/code&gt; 인자는 주석으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt;형을 명기했다. 그래서 사전형 속성인 &lt;code class=&quot;highlighter-rouge&quot;&gt;__annotations__&lt;/code&gt;의 &lt;code class=&quot;highlighter-rouge&quot;&gt;arg1&lt;/code&gt;키에는 명기한 값인 &lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt;이 할당되어 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;__annotations__&lt;/code&gt;에 할당되어 있는 주석 값을 이용해 &lt;code class=&quot;highlighter-rouge&quot;&gt;arg1&lt;/code&gt;과 같은 함수 매개 인자의 형을(&lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt;) 검사한 것이 &lt;code class=&quot;highlighter-rouge&quot;&gt;if not isinstance(_v, arg_type):&lt;/code&gt; 부분이다.&lt;/p&gt;

&lt;p&gt;이 함수를 &lt;code class=&quot;highlighter-rouge&quot;&gt;static_args_func(1, 2, 3)&lt;/code&gt;와 같이 호출하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;arg1&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;arg2&lt;/code&gt;에 대해 코드에서 지정한 &lt;code class=&quot;highlighter-rouge&quot;&gt;TypeError&lt;/code&gt; 예외가 일어난다.&lt;/p&gt;

&lt;p&gt;다음 코드는 가변 매개 인자도 형 검사를 한다. 더이상 형 검사를 하지 않는 위치부터 나머지 인자까지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Ellipsis&lt;/code&gt; 형(&lt;code class=&quot;highlighter-rouge&quot;&gt;...&lt;/code&gt;)을 썼다. 즉, 두 번째 인자까지는 형 검사를 하고, 이후 인자는 형 검사를 생략한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def type_checking_func(*args: (int, int, ...)):
    annotations = type_checking_func.__annotations__

    if (
        not isinstance(annotations, dict) or
        len(annotations) == 0
    ):
        return type_checking_func(*args)

    try:
        _check_index = annotations['args'].index(Ellipsis)
    except ValueError:
        _check_index = len(annotations) - 1

    for i, _v in enumerate(args[:_check_index]):
        arg_type = annotations['args'][i]

        if isinstance(_v, arg_type):
            continue

        raise TypeError(
            &quot;The type of '{}' does not match '{}' type&quot;.format(
                _v, arg_type.__name__
            )
        )
    print(*args)

type_checking_func(1, 2, '3', 'a')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;인자의 형을 검사하는 기능을 장식자(&lt;code class=&quot;highlighter-rouge&quot;&gt;decorator&lt;/code&gt;)로 만들어서 여러 함수에 간편하게 사용하면 더 낫다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def check_argument_type(func):
    def wrapper(*args):
        annotations = func.__annotations__
        if (
            not isinstance(annotations, dict) or
            len(annotations) == 0
        ):
            return func(*args)

        try:
            check_index = annotations['args'].index(Ellipsis)
        except ValueError:
            check_index = len(annotations['args']) - 1

        for _i, _v in enumerate(args[:check_index]):
            _arg_type = annotations['args'][_i]

            if isinstance(_v, _arg_type):
                continue

            raise TypeError(
                &quot;The type of '{}' does not match '{}' type&quot;.format(
                    _v, _arg_type.__name__
                )
            )
        return func(*args)
    return wrapper

@check_argument_type
def hello_func(*args: (int, int, ...)):
    print(*args)

hello_func(1, 2, '3', 'a')
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Python스러운 구현인 지 아닌 지 모르겠지만, 함수 매개 인자가 어떤 자료형으로 넘어올 지 몰라서 받는 스트레스는 줄어들 것 같다. :)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://gist.github.com/hannal/12597a1466307f4290a4&quot;&gt;Python 3에서 함수의 키워드 인자 강제와 주석문 예제 코드&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-3102/&quot;&gt;PEP-3102 : Keyword-Only Arguments&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-3107/&quot;&gt;PEP-3107 : Function Annotations&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  
  <entry>
    <title>개발 생활 - 6</title>
    <link href="/2015/03/devlife-s1-06/"/>
    <updated>2015-03-17T04:13:40+09:00</updated>
    <id>/2015/03/devlife-06</id>
    <content type="html">&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-01/&quot;&gt;개발 생활 - 1&lt;/a&gt; : PDF 문서 생성 서버&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;개발 생활 - 2&lt;/a&gt; : 연산된 데이터 수집 작업자&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-03/&quot;&gt;개발 생활 - 3&lt;/a&gt; : 전자우편 알림 서버&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;개발 생활 - 4&lt;/a&gt; : Python과 Django 강의&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-05/&quot;&gt;개발 생활 - 5&lt;/a&gt; : 공부 자료&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-06/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;개발 생활 - 6&lt;/code&gt;&lt;/a&gt; : 앞으로 계획&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;5-앞으로-계획&quot;&gt;5. 앞으로 계획&lt;/h3&gt;

&lt;h4 id=&quot;개요&quot;&gt;개요&lt;/h4&gt;

&lt;p&gt;지난 6~7개월 동안 학습과 실무가 겹친 개발 생활을 보냈다. 내가 뭘 할 수 있고, 하고 싶은 건 무엇인지, 재밌다고 여기는 건 무엇이며, 앞으로 뭘 할 것인지를 찾는 시간이었다.&lt;/p&gt;

&lt;p&gt;다음 단계는 현재 내가 맡고 있는 분야와 관심 갖고 있는 분야에 대한 기초와 기본부터 계발하여 제대로 이해한 기술로 구현하려 한다.&lt;/p&gt;

&lt;p&gt;프로그래밍 언어는 Python을 주력으로 사용하고, Go 비중을 높여갈 계획이다. 추후엔 주 Go를 주로 사용하고 Python을 특정 목적용으로 사용할 것으로 예상한다. &lt;a href=&quot;http://julialang.org/&quot;&gt;Julia&lt;/a&gt;, &lt;a href=&quot;http://nim-lang.org/&quot;&gt;Nim&lt;/a&gt;가 재밌어 보이고, Scala, Java, C++은 별로 끌리진 않지만 공부할 필요성을 느낀다. 하지만 현재 진행하고 있거나 계획한 공부 대상으로도 벅차서 Scala, Java, C++은 당분간 공부하진 않을 것이다.&lt;/p&gt;

&lt;p&gt;테스트 케이스, 문서화, 배포/배치 등 여러 부분을 자동화하고 있고 더 많이 자동화 할 예정이다. 맡은 프로젝트가 늘어나고 각 프로젝트 구현단이 확장되면서 개발과 운영 복잡도가 증가하다 보니 자연스레 기존 자동화 도구나 방법이 필요한 이유를 이해하여 필요로 하게 됐다.&lt;/p&gt;

&lt;h4 id=&quot;pdf-문서-생성-서버&quot;&gt;PDF 문서 생성 서버&lt;/h4&gt;

&lt;p&gt;현재(2015년 3월 기준) PDF 문서 생성 서버를 리팩토링하고 있으며, 리팩토링 후 신규 버전을 개발할 예정이다. 신규 버전은 다음 내용을 목표로 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메모리 사용량 줄이기 (lazy evaluation)&lt;/li&gt;
  &lt;li&gt;PDF 생성을 병렬로 처리&lt;/li&gt;
  &lt;li&gt;Python 3 지원&lt;/li&gt;
  &lt;li&gt;캐쉬(cache) 강화&lt;/li&gt;
  &lt;li&gt;전자우편 알림 서버(&lt;code class=&quot;highlighter-rouge&quot;&gt;postman&lt;/code&gt;) 연동&lt;/li&gt;
  &lt;li&gt;통계 기능 추가&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Sentry&lt;/code&gt; 연동&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;편의점-프로젝트-연산된-데이터-수집-작업자&quot;&gt;편의점 프로젝트 (연산된 데이터 수집 작업자)&lt;/h4&gt;

&lt;p&gt;4월 이후에 리팩토링을 한 후 소소한 업그레이드를 계획하고 있다. 회사 개발 일정이나 계획에 따로 잡은 건 아니어서 짬짬히 시간 내어 해결할 범위로 구상하고 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PyPy&lt;/code&gt;로 이전&lt;/li&gt;
  &lt;li&gt;통계 기능 추가&lt;/li&gt;
  &lt;li&gt;Sentry 연동&lt;/li&gt;
  &lt;li&gt;CEP(Complex Event Processing) 적용&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;전자우편-알림-서버&quot;&gt;전자우편 알림 서버&lt;/h4&gt;

&lt;p&gt;현재 새로운 알림 조건을 추가하고 있으며, 4월 이후 개인화 된 소식지(newsletter) 기능을 준비한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;전자우편 발송부를 Go 언어로 이전&lt;/li&gt;
  &lt;li&gt;애플리케이션 서버들 간 통신 방법 변경&lt;/li&gt;
  &lt;li&gt;알림 조건 종류 확장&lt;/li&gt;
  &lt;li&gt;모바일 푸시 알림 기능 추가 (&lt;code class=&quot;highlighter-rouge&quot;&gt;mqtt&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;개인화 된 소식지 기능 추가 (data processing, batch)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;공부&quot;&gt;공부&lt;/h4&gt;

&lt;p&gt;공부할 게 많은데, 책을 기준으로 나열하면 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;동시성, 병렬성
    &lt;ul&gt;
      &lt;li&gt;입문자를 위한 병렬 프로그래밍 (ISBN : 9791185890159)&lt;/li&gt;
      &lt;li&gt;Pattern-Oriented Software Architecture, Volume 2: Patterns for Concurrent and Networked Objects (ISBN : 0471606956)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그래밍
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;클린 코드&lt;/em&gt; (ISBN : 9788966260959)&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;프로그램 디자인, 어떻게 할 것인가&lt;/em&gt; (ISBN : 9788991268975)&lt;/li&gt;
      &lt;li&gt;Pattern-Oriented Software Architecture, Volume 1: A System of Patterns (ISBN : 9780471958697)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시스템
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;리눅스 시스템 프로그래밍&lt;/em&gt; (ISBN : 9788968481482)&lt;/li&gt;
      &lt;li&gt;컴퓨터 구조 및 설계 (ISBN : 9788996276531)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;네트워크
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;트위스티드&lt;/em&gt; (ISBN : 9788966261154)&lt;/li&gt;
      &lt;li&gt;컴퓨터 네트워킹 하향식 접근 (ISBN : 9788945006585)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;언어
    &lt;ul&gt;
      &lt;li&gt;Programming in Go (ISBN : 9780321774637)&lt;/li&gt;
      &lt;li&gt;The Go Programming Language (ISBN : 9780134190440. 2015년 8월 출간 예정)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;데이터, 통계 관련
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;파이썬을 활용한 베이지안 통계&lt;/em&gt; (ISBN : 9788968481147)&lt;/li&gt;
      &lt;li&gt;파이썬 라이브러리를 활용한 데이터 분석 (ISBN : 9788968480478)&lt;/li&gt;
      &lt;li&gt;Building Machine Learning Systems with Python (ISBN : 9788960775367)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;알고리즘
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;알고리즘 기초&lt;/em&gt; (ISBN : 9791156000129)&lt;/li&gt;
      &lt;li&gt;문제로 풀어보는 알고리즘 (ISBN : 9788966260461)&lt;/li&gt;
      &lt;li&gt;알고리즘 문제 해결 전략 (ISBN : 9788966260546)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수학
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;수학독본&lt;/em&gt; (ISBN : 9788935640379)&lt;/li&gt;
      &lt;li&gt;착한 수학 (ISBN : 9788993827866)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;현재(2015년 3월 기준) 보고 있는 책은 따로 표시했으며, 이외엔 다음에 읽거나 틈틈히 부분 참고하며 읽을 책들이다.&lt;/p&gt;

&lt;h4 id=&quot;잉여&quot;&gt;잉여&lt;/h4&gt;

&lt;p&gt;잉여 시간이 나면 Lego mindstorm과 Arduino를 갖고 놀며, &lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;Open stack&lt;/code&gt;을 구현 관점에서 분석할 계획이다.&lt;/p&gt;

&lt;h4 id=&quot;집필&quot;&gt;집필&lt;/h4&gt;

&lt;p&gt;Python과 Django를 도구로 삼은 입문서를 준비하고 있다. 함께 논의하고 있는 편집자가 믿음직스러워서 정말 출간할 수 있겠다는 기대감이 든다. 학습하고, 개발하고, 가르치는 경험을 잘 녹여내어 올해 안에 출간하고 싶다.&lt;/p&gt;

&lt;h4 id=&quot;개발-환경&quot;&gt;개발 환경&lt;/h4&gt;

&lt;p&gt;대개는 문서를 &lt;code class=&quot;highlighter-rouge&quot;&gt;markdown&lt;/code&gt;으로 작성하는데, &lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;Python과 Django 강의&lt;/a&gt; 이후로 IPython을 사용하는 빈도가 늘고 있다. 최근엔 Python 뿐만 아니라 다른 프로그래밍 언어도 지원하는 &lt;a href=&quot;http://jupyter.org/&quot;&gt;Jupyter&lt;/a&gt;를 사용하고 있다. 앞으로 많은 문서를 Jupyter를 이용할 생각이다.&lt;/p&gt;

&lt;p&gt;코드 편집기는 Sublime text 3를 주로 사용하며, &lt;code class=&quot;highlighter-rouge&quot;&gt;PyCharm&lt;/code&gt; 등 JetBrains사의 도구를 사용하려 몇 번 시도했으나 좀처럼 적응하지 못하고 있다. 마음에 드는 기능이 많은데, 미묘하게 느린 화면 반응을 견디기 힘들다. &lt;a href=&quot;http://www.sourcetreeapp.com/&quot;&gt;SourceTree&lt;/a&gt;도 답답해서 터미널에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;을 콘솔로 쓰고 있으니, 당분간 IDE에 적응하는 데 적지않은 노력을 들이거나 결국 포기할 것 같다.&lt;/p&gt;

&lt;h4 id=&quot;마치며&quot;&gt;마치며&lt;/h4&gt;

&lt;p&gt;전업 프로그래머가 된 이후로도 사업 개발이나 기획 업무를 맡아달라는 제안을 받고 있지만, 현재 내가 참여하는 조직들(?)에서는 전부 프로그래밍 관련 일만 하고 있다. 이 조직들 모두 내게 권한과 기회를 위임하고 지원해주는 덕분에 힘든 시기를 즐겁게 보냈다.&lt;/p&gt;

&lt;p&gt;미숙해서 문제를 푸느라 고생하는 상황에 처했을 때, 누군가에게 물어봐서 문제를 빨리 해결하고 싶은 충동을 많이 느꼈다. 이 문제 좀 풀어주세요, 라는 말이 목까지 치밀어 올라온 문제도 몇 개 있었다. 하지만, 내가 부딪힌 문제 대부분은 스스로 해결해야 의미있는 단계라는 걸 알고 있었고, 거의 모두 스스로 해결했다&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;지인이 (프로그래밍으로)개발하는 생활을 만족하느냐고 물었다. 재밌고 만족한다고 답했는데, 아직은 혼자 고민하여 스스로 문제를 해결하는 데 들이는 노력이 크지 않은 단계여서 재밌다고 여기는 것일 것이다. 여태껏 겪어 온 문제보다 더 어려운 난관에 부딪히면 그 재미는 (아마도) 줄어들 것이고, 끝내 내 능력으로 풀어내지 못해 좌절할 지도 모른다.&lt;/p&gt;

&lt;p&gt;괜찮다. 프로그래머 생활을 만족하는 이유는 난관을 극복하며 성장하는 즐거움 뿐만 아니라 내 생각을 표현하는 방법으로써 매력과 재미를 느끼기 때문이다. 가령, 요리나 춤, 노래, 대화는 취미나 관심사로 재밌을지 몰라도 직업으로 내 생각을 표현할 방법으로 삼을만큼 재밌지도 매력있게 느껴지지도 않는다.&lt;/p&gt;

&lt;p&gt;지난 6~8개월 동안 겪은 개발 생활은 즐거웠다. 더 재밌고 즐겁고 만족스러운 개발 생활을 보내기 위해 계속 노력하려 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;편의점 프로젝트&lt;/a&gt;에서 SQL Query를 짜는 문제 하나는 결국 동료가 해결해 주었다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  
  <entry>
    <title>개발 생활 - 5</title>
    <link href="/2015/03/devlife-s1-05/"/>
    <updated>2015-03-14T21:13:40+09:00</updated>
    <id>/2015/03/devlife-05</id>
    <content type="html">&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-01/&quot;&gt;개발 생활 - 1&lt;/a&gt; : PDF 문서 생성 서버&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;개발 생활 - 2&lt;/a&gt; : 연산된 데이터 수집 작업자&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-03/&quot;&gt;개발 생활 - 3&lt;/a&gt; : 전자우편 알림 서버&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;개발 생활 - 4&lt;/a&gt; : Python과 Django 강의&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-05/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;개발 생활 - 5&lt;/code&gt;&lt;/a&gt; : 공부 자료&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-06/&quot;&gt;개발 생활 - 6&lt;/a&gt; : 앞으로 계획&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4-공부-자료&quot;&gt;4. 공부 자료&lt;/h3&gt;

&lt;h4 id=&quot;개요&quot;&gt;개요&lt;/h4&gt;

&lt;p&gt;2014년 7월부터 2015년 2월까지 지낸 개발 생활 중 공부하거나 참고한 자료를 정리했다. 미처 따로 기록하지 못 한 자료는 기재하지 않았다.&lt;/p&gt;

&lt;p&gt;일부는 부분 참고를 했고, 일부는 여전히 공부하느라 참고하고 있다.&lt;/p&gt;

&lt;h4 id=&quot;책&quot;&gt;책&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;파이썬 완벽 가이드
    &lt;ul&gt;
      &lt;li&gt;ISBN : 9788966260256&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;파이썬 인 프랙티스
    &lt;ul&gt;
      &lt;li&gt;ISBN : 9788998139650&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;실전 파이썬 프로그래밍
    &lt;ul&gt;
      &lt;li&gt;ISBN : 9788966261246&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Linux System Programming
    &lt;ul&gt;
      &lt;li&gt;ISBN : 9788968481482&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;열혈강의 파이썬
    &lt;ul&gt;
      &lt;li&gt;ISBN : 9788989345770&lt;/li&gt;
      &lt;li&gt;강의 준비할 때 참고&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Python Network Programming
    &lt;ul&gt;
      &lt;li&gt;ISBN : 9781430230038&lt;/li&gt;
      &lt;li&gt;웹 소켓 서버와 전자우편 알림 서버 개발에 참고&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;트위스티드
    &lt;ul&gt;
      &lt;li&gt;ISBN : 9788966261154&lt;/li&gt;
      &lt;li&gt;비동기 처리 학습&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Programming in Python 3, 2nd Edition
    &lt;ul&gt;
      &lt;li&gt;ISBN : 9780321680563&lt;/li&gt;
      &lt;li&gt;Python 3 준비하기 위해 부분 참고&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;웹-자료&quot;&gt;웹 자료&lt;/h4&gt;

&lt;h5 id=&quot;python&quot;&gt;Python&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.python.org&quot;&gt;Python 공식 문서&lt;/a&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.python.org/3/library/asyncio-task.html&quot;&gt;Tasks and coroutines&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.flowdas.com/thinkpython/&quot;&gt;Think Python&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://legacy.python.org/dev/peps/pep-0008/&quot;&gt;PEP 8&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.eairship.kr/271&quot;&gt;금지된 엑시노아의 비공정 - 파이썬 강좌&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.flowdas.com/blog/asyncio-python-tulip/&quot;&gt;asyncio - Python Tulip&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@cookatrice/why-python-is-slow-looking-under-the-hood-7126baf936d7&quot;&gt;파이썬은 왜 느릴까요? 내부 원리를 살펴 봅시다.&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.pycon.kr/2014/program/2&quot;&gt;위대한 dict 이해하고 사용하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.python.org/doc/essays/list2str/&quot;&gt;Python Patterns - An Optimization Anecdote&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://openlook.org/wp/?p=801&quot;&gt;파이썬을 두루 이해하는 데 도움 되는(?) 퀴즈&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.dabeaz.com/generators/index.html&quot;&gt;Generator Tricks for Systems Programmers&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cafepy.com/article/python_types_and_objects/python_types_and_objects.html&quot;&gt;Python Types and Objects&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://techspot.zzzeek.org/2015/02/15/asynchronous-python-and-databases/&quot;&gt;Asynchronous Python and Databases&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.python-guide.org/&quot;&gt;The Hitchhiker’s Guide to Python!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;python-관련-frameworks나-libraries&quot;&gt;Python 관련 frameworks나 libraries&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;Django
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://docs.djangoproject.com&quot;&gt;Django 공식 문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://medium.com/cs-math/11-things-i-wish-i-knew-about-django-development-before-i-started-my-company-f29f6080c131&quot;&gt;11 Things I Wish I Knew About Django Development Before I Started My Company&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.looah.com/article/view/2025&quot;&gt;2014년에 Django로 개발하면서 실수한 부분&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://blog.etianen.com/blog/2013/06/08/django-querysets/&quot;&gt;Using Django querysets effectively&lt;/a&gt;
        &lt;ul&gt;
          &lt;li&gt;번역 : &lt;a href=&quot;http://raccoonyy.github.io/using-django-querysets-effectively-translate/&quot;&gt;Django에서 쿼리셋 효과적으로 사용하기&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.michelepasin.org/blog/2010/07/20/the-power-of-djangos-q-objects/&quot;&gt;The power of django’s Q objects&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;gevent
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.gevent.org/contents.html&quot;&gt;gevent 공식 문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://sdiehl.github.io/gevent-tutorial/&quot;&gt;gevent tutorial&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.pycon.kr/2014/program/3&quot;&gt;제약을 넘어 : Gevent&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://blog.pythonisito.com/2011/07/gevent-zeromq-websockets-and-flot-ftw.html&quot;&gt;Gevent, ZeroMQ, WebSockets, and Flot FTW!&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://blog.miguelgrinberg.com/post/easy-websockets-with-flask-and-gevent/page/9&quot;&gt;Easy WebSockets with Flask and Gevent&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Celery
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://celery.readthedocs.org/&quot;&gt;Celery 공식 문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://zapier.com/blog/async-celery-example-why-and-how/&quot;&gt;Async Celery by Example: Why and How&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://celery.readthedocs.org/en/latest/userguide/periodic-tasks.html&quot;&gt;Periodic Tasks&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;SQLAlchemy
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://docs.sqlalchemy.org/&quot;&gt;SQLAlchemy 공식 문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.pythoncentral.io/understanding-python-sqlalchemy-session/&quot;&gt;Understanding Python SQLAlchemy’s Session&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이외
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://docs.python-requests.org/&quot;&gt;Requests&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://siriux.net/2013/06/nginx-and-websockets/&quot;&gt;nginx and WebSockets&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://flask.pocoo.org/docs&quot;&gt;Flask 공식 문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://jinja.pocoo.org/docs&quot;&gt;Jinja2 공식 문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://kombu.readthedocs.org&quot;&gt;Kombu 공식 문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://ipython.org/documentation.html&quot;&gt;IPython 공식 문서&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://nbviewer.ipython.org/github/re4lfl0w/ipython/blob/master/books/python_data_analysis/ch03_Introduction%20IPython.ipynb&quot;&gt;IPython 소개&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;go&quot;&gt;Go&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://go-tour-kr.appspot.com/&quot;&gt;A Tour of Go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.golang-book.com/&quot;&gt;An introduction to programming in Go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://code.google.com/p/golang-korea/wiki/EffectiveGo&quot;&gt;Go언어 잘 사용하는 방법&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gobyexample.com/&quot;&gt;Go by Example&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://talks.golang.org/2012/waza.slide&quot;&gt;Concurrency is not Parallelism&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;redis&quot;&gt;Redis&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.joinc.co.kr/modules/moniwiki/wiki.php/man/12/REDIS/DataModeling&quot;&gt;REDIS 데이터 모델링 예제들&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://charsyam.wordpress.com/category/cloud/redis/&quot;&gt;CharSyam’s Redis posts&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;이외&quot;&gt;이외&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.codeok.net/&quot;&gt;CODEOK&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://sentry.readthedocs.org/&quot;&gt;Sentry&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://natepinchot.com/2014/01/31/building-static-wkhtmltopdf/&quot;&gt;Building static wkhtmltopdf (and static QT)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://ghebook.blogspot.kr/2010/10/permutation-combination.html&quot;&gt;순열(順列, permutation)과 조합(組合, combination)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.rfc-editor.org/rfc-index.html&quot;&gt;RFC Index&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://bespokebytes.com/start-getting-up-and-running-with-upstart/&quot;&gt;Start getting up and running with Upstart&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://lqez.github.io/blog/fool-upstart.html&quot;&gt;Fool Upstart&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>개발 생활 - 4</title>
    <link href="/2015/03/devlife-s1-04/"/>
    <updated>2015-03-09T04:33:40+09:00</updated>
    <id>/2015/03/devlife-04</id>
    <content type="html">&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-01/&quot;&gt;개발 생활 - 1&lt;/a&gt; : PDF 문서 생성 서버&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;개발 생활 - 2&lt;/a&gt; : 연산된 데이터 수집 작업자&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-03/&quot;&gt;개발 생활 - 3&lt;/a&gt; : 전자우편 알림 서버&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;개발 생활 - 4&lt;/code&gt;&lt;/a&gt; : Python과 Django 강의&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-05/&quot;&gt;개발 생활 - 5&lt;/a&gt; : 공부 자료&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-06/&quot;&gt;개발 생활 - 6&lt;/a&gt; : 앞으로 계획&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3-python과-django-강의&quot;&gt;3. Python과 Django 강의&lt;/h3&gt;

&lt;h4 id=&quot;개요&quot;&gt;개요&lt;/h4&gt;

&lt;p&gt;2014년 12월 4일부터 2015년 1월 31일까지 &lt;a href=&quot;http://www.fastcampus.co.kr&quot;&gt;패스트캠퍼스&lt;/a&gt;에서 Python과 Django를 이용해 &lt;a href=&quot;http://www.fastcampus.co.kr/camp_wpa/&quot;&gt;웹서비스를 개발하는 커리큘럼으로 강의&lt;/a&gt;를 했다. 나는 이론 부분을, 함께 강의한 고빈섭님은 실습 부분을 담당했고, 김구영님은 조교로 강의를 도와주셨다.&lt;/p&gt;

&lt;p&gt;패스트캠퍼스에는 &lt;a href=&quot;http://www.fastcampus.co.kr/camp_wpb/&quot;&gt;웹 프로그래밍 입문&lt;/a&gt; 과정이 있는데, 내가 강의를 맡은 &lt;code class=&quot;highlighter-rouge&quot;&gt;웹 서비스 개발&lt;/code&gt; 과정은 입문 과정의 후속 과정이다. 그래서 초기 교육 과정 이름은 가칭 웹 프로그래밍 중급이었다가 실전 웹 서비스 개발에 초점을 맞추어 교육 과정 이름이 웹 서비스 개발로 바뀌었다.&lt;/p&gt;

&lt;p&gt;패스트캠퍼스에서 내게 제안한 중급 과정 강의를 수락한 동기는 집필이었다. 내가 프로그래머로 전업을 결심하기 전에 한 출판사로부터 집필 제안을 받아서, 몇 몇 개발자에게 의견을 구하고 Django 입문 강좌의 후속 강좌인 &lt;a href=&quot;http://blog.hannal.com/category/start-with-django-webframework/&quot;&gt;날로 먹는 Django 웹프레임워크&lt;/a&gt; 강좌 연재를 시작하면서 집필을 준비하고 있었다. 하지만 목차를 구상하는 게 쉽지 않아 좀처럼 진도를 나가지 못하고 있던 차에 패스트캠퍼스로부터 제안을 받은 것이다.&lt;/p&gt;

&lt;h4 id=&quot;교육-재료-환경&quot;&gt;교육 재료, 환경&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;프로그래밍 재료 : Python 2.7, Django 1.7&lt;/li&gt;
  &lt;li&gt;교재 재료 : 수강생 교재는 IPython으로 작성, 강사 발표는 Apple Keynote로 작성&lt;/li&gt;
  &lt;li&gt;소통 공간 : 페이스북 비공개 그룹&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;강의-준비-과정&quot;&gt;강의 준비 과정&lt;/h4&gt;

&lt;p&gt;교육 과정이 시작되기 전에 나부터 교육할 필요가 있었다. 경험이나 직관으로 알던 것에서 그치지 않고, 제대로 설명하여 정확히 이해시켜야 하기 때문이다. 더구나 나는 입문 과정을 강의하는 게 아니기 때문에 명확하게  이해시키는 걸 넘어 더 깊은 내용을 설명할 줄 알아야 했다.&lt;/p&gt;

&lt;p&gt;곧바로 여러 Python 책과 공식 문서로 공부했다. 한창 &lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;편의점 프로젝트&lt;/a&gt;를 진행하던 시기였기 때문에 내 서재 책상엔 개발 관련 책 대여섯 권이 늘 펼쳐져 있었고, 웹브라우저엔 관련 자료에 대한 탭이 스무 개 이상 열려 있었다. 한 달 동안 책 다섯 권을 정독하고, 모든 예제를 실습하였다.&lt;/p&gt;

&lt;p&gt;그 다음 공부 주제는 Django로 잡았다. 내가 Django를 얼마만큼 제대로 알고 있는 지 파악해야 해서 Django를 이용해 인스타그램 같은 웹 서비스를 서로 다른 구현 방법과 구조로 세 번 만들었다. 그 중 한 버전은 블로그에 연재 중인 강좌에 사용하고&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, 다른 한 버전은 강의 실습용으로 정했다. 그러고나서 Django 공식 문서를 보며 하나 하나 뜯어보고 다듬었는데, 각 기능마다 다른 사람이 구현한 방법을 웹에서 찾아다녔고, 구현 방법이 다른 경우 Django 소스를 열어서 Django의 작동 방식이나 의도를 분석했다. 이 과정에 약 4주가 걸렸고, Django 소스 코드 중 많은 부분에 대해 리뷰 아닌 리뷰를 두 차례 했다.&lt;/p&gt;

&lt;p&gt;마지막으로 Django 릴리즈 노트와 &lt;a href=&quot;https://github.com/django/django/commits/master&quot;&gt;Django의 master 브랜치&lt;/a&gt;에 쌓인 commit들을 훑으며 주목할만한 변화를 찾아 보았다. Django 1.0 이후로 Django를 사용하지 않아서 주요 변동 이력을 알지 못했기 때문이다.&lt;/p&gt;

&lt;p&gt;학습을 일단락하고 강의를 준비했다. 나는 markdown 문서 형식을 애용하지만, &lt;a href=&quot;http://ipython.org/&quot;&gt;IPython&lt;/a&gt;으로 교재를 만들어 보기로 했다. IPython은 2014년 초에 회사 개발 프로젝트에 도입하면서&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 처음 접했는데, 상상력을 일으키는 재밌는 도구라 여겨왔다. 프로젝터에 띄울 강의 자료도 IPython으로 작성하려 했지만, 가독성이 좋지 않아 Apple Keynote로 작성하기로 했다.&lt;/p&gt;

&lt;h4 id=&quot;강의-과정&quot;&gt;강의 과정&lt;/h4&gt;

&lt;p&gt;첫 수업에서 나는 무척 당황했다. 여러 수강자가 예상보다 내 강의를 어려워했기 때문이다. 입문 단계는 뗀 사람을 대상으로 하는 커리큘럼이니 입문서나 자료에 나오는 내용에서 그치지 않고 좀 더 이론 부분을 다뤘는데, 일부 수강자를 보니 무척 혼란스러워 하는 표정이었다. 가령, Python에서 모든 데이터는 객체라는 내용을 설명할 때, &lt;strong&gt;Python에서 객체가 무엇인지&lt;/strong&gt; 설명했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 데이터는 객체(object)
    &lt;ul&gt;
      &lt;li&gt;객체 구조 : 신원(identity), 타입(type, class), 값(value)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;number = 1&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;number&lt;/code&gt;는 신원, &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;은 값, 이 값이 할당된(assigned) 객체의 타입은 &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;모든 객체의 조상은 &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt;이며, &lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt;은 모든 타입의 조상. &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt;의 인스턴스이며, &lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt;의 하위 클래스. &lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt;은 자기 자신에 대한 &lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;동적 형(type) 변환 : 객체의 타입이 변하는 게 아니라 객체의 신원이 가리키는(reference) 대상(값)이 바뀌는 것.&lt;/li&gt;
  &lt;li&gt;변수, 즉 신원 자체는 객체나 값이 아니다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;del&lt;/code&gt;문은 객체를 지우는 것이 아니라 객체 참고 관계를 끊는 것.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1 == True&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;1 is True&lt;/code&gt;의 차이
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;True&lt;/code&gt;의 값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;이고, &lt;code class=&quot;highlighter-rouge&quot;&gt;False&lt;/code&gt;의 값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;값 비교는 &lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt; 연산자로, 신원 비교는 &lt;code class=&quot;highlighter-rouge&quot;&gt;is&lt;/code&gt; 연산자로 평가.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하지만, 일부 수강자가 “객체”라는 것 자체를 생소해 하거나 잘 모르는 상황이었다. 그들 입장에선 내가 어렵게 강의를 준비하고 설명한 것이었고, 결국 미리 준비한 강의 자료와 교재를 전면 수정해야 했다.&lt;/p&gt;

&lt;p&gt;커리큘럼은 이론 부분과 실습 부분으로 구성했고, 나는 이론을 담당했다. 그러다보니 실습할 내용에 대해 이론 부분을 여러 방면으로 준비했다.&lt;/p&gt;

&lt;p&gt;가령, Django의 모델 필드형 중 &lt;code class=&quot;highlighter-rouge&quot;&gt;TextField&lt;/code&gt;를 Django 공식 문서에서는 큰(large) 텍스트를 담는 필드라고 설명하는데, 나는 SQLite 3는 &lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt;형으로 약 1기가 바이트, PostgreSQL은 길이 제한이 없는 &lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt;, MySQL은 &lt;code class=&quot;highlighter-rouge&quot;&gt;longtext&lt;/code&gt;형으로 약 4기가 바이트, Oracle은 8~12테라 바이트를 담는 &lt;code class=&quot;highlighter-rouge&quot;&gt;NCLOB&lt;/code&gt;형이라고 설명하는 것이다. 수강자가 얼마나 긴 문자열을 담느냐는 질문을 하는데 &lt;code class=&quot;highlighter-rouge&quot;&gt;CharField&lt;/code&gt;보다 긴, 게시판의 글 본문에 쓸만큼 긴 문자열이라고 대답하고 싶진 않았다.&lt;/p&gt;

&lt;p&gt;또는, 흥미롭게 구현된 Django 기능이 있는 경우, 그 기능이 작성된 Django 소스를 직접 설명하기도 했다. 예를 들어, Django의 &lt;code class=&quot;highlighter-rouge&quot;&gt;settings&lt;/code&gt;는 수강자들이 재밌다고 느낄만한 Python 기법이 잘 녹아있는 모듈이라서 가볍게 훑고 지나가지 않고 동작하는 방식에 대해 설명했다. Django 자체보다는 Python 기법에 대한 내용이다보니 다른 Django 자료에서는 잘 다루지 않는 내용이고, 내 강의를 듣기 때문에 접하는 내용이었다. 가능하면 이런 내용을 다루려 했다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/uploads/2015/03/django_conf_settings.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;수업은 4회차부터 강의 목표와 계획을 완전히 수정했다. 수강자들이 수업 당시에는 수업 내용을 완전히 이해하지 못하더라도 교재를 보며 복습하여 언젠가는 이해하는 것으로 목표를 바꿨다. 일명 “교재라도 남기자”. 그래서 교재도 최대한 서술형으로 풀어서 문장을 작성했다. 마치 내가 교재를 강의 원고로 삼아 그대로 읽는 것처럼 작성했고, 발표용 슬라이드는 목차처럼 활용하도록 작성했다. 그러다보니 매 수업에 사용하는 교재는 100여 장을 넘기곤 했다. 한 수강자는 우스개소리로 100만원이 넘는 Python + Django 책이라고 말하기도 했다.&lt;/p&gt;

&lt;p&gt;서술형 교재는 IPython으로 작성했다. 의도와 목표는 교재를 IPython으로 열어서 코드를 교재 안에서 직접 실행(run)하고 실습하는 상호작용 교재로 활용하도록 하는 것이었지만, 의도대로 활용되는 것 같진 않았다. 그래서 소스 문법 강조가(highlighting) 잘 된 문서로라도 활용하였고, 실제로 교재도 IPython 파일을 HTML 파일로 내보낸(export) 문서도 함께 배포하였다.&lt;/p&gt;

&lt;p&gt;실습을 본격 시작한 수업부터는 매 수업에 진행한 전체 소스 코드도 배포하였다. 그러니까, 4회 수업까지 진행한 소스 코드, 5회 수업까지 진행한 소스 코드를 구분하여 매 수업 때 마다 배포한 것이다. 처음엔 &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt;으로 관리하여 각 수업에 진행한 소스 이력에 tag를 달아서 접근하도록 하려 했다. 하지만, 이 교육 과정으로 입문한 것이나 마찬가지인 수강자는 새로운 개념이 등장할 때마다 힘들어해서 git을 수업에 도입하진 않았다.&lt;/p&gt;

&lt;p&gt;이렇게 교재를 만들어 배포하다보니 일단 수업엔 참여해서 최대한 듣고 따라오고, 수업 이후엔 내가 작성한 소스 코드를 기반으로 실습하거나 복습하고, 설명은 교재를 읽는 사례가 나타났다. 수강자 나름대로 적응하고 수업과 교재를 활용하는 것이다.&lt;/p&gt;

&lt;p&gt;점차 강의에 익숙해지다보니 분량 조절이 맞아서 수업 시간 운용도 안정되었다. 교재를 만드는 건 여전히 힘들었지만, 강의 진행은 한결 편안해졌다. 수강자 개개인을 알아가면서 강의와 교재에 예제나 보충 설명을 반영하기도 했다. 글로 강좌를 연재하는 것과는 다른 매력이었다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://getbootstrap.com/&quot;&gt;Bootstrap&lt;/a&gt;을 적용하고, &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku&lt;/a&gt;에 개발한 프로젝트를 배치(deployment)하는 것으로 전체 강의를 마쳤다. Heroku 무료판은 무척 느린데다 국내에서 사용 사례가 많지 않아서 Heroku에 서비스를 배치하는 것에 주제를 맞추지 않고, 프로젝트를 배치하고 배포하는 과정을 이해하는 데 맞추었다. 즉, Heroku가 자동으로 처리해주는 부분은 무엇이고, Amazon Web Service 등을 이용할 경우 어느 부분까지 사람이 해야 하며, 어떻게 하는 것이 좋은 지 설명하였다.&lt;/p&gt;

&lt;h4 id=&quot;우여곡절&quot;&gt;우여곡절&lt;/h4&gt;

&lt;p&gt;초반 3주는 무척 힘든 시간을 보냈다. 강의 자료와 교재를 전면 재작성 하다보니 매주 시간에 쫓겼고, 회사 업무도 마감에 임박한 상황이라 정신 없는 나날이었다. 무엇보다도 내가 과의욕 상태이다보니 난이도나 분량을 조절하지 못하여 스트레스를 자초한 탓이 가장 컸다.&lt;/p&gt;

&lt;p&gt;개인 사정으로 수업을 목요일과 토요일로 잡은 것도 좋지 않았다. 수업 간격이 좁다보니 수강자는 복습할 시간 여력이 없었고, 매 수업마다 100여 장이 넘는 교재를 작성하는 나 역시 수업 자료를 만들 시간이 부족했다. 특히 초반 2주는 주말에도 내 수업이 잡혀있다 보니 밤샘하기 일쑤였다.&lt;/p&gt;

&lt;p&gt;실습 환경을 맞추어 예외 상황을 피하려는 목적으로 VirtualBox에 Ubuntu를 가상으로 설치한 건 득보다는 실이 컸다. 대다수가 VirtualBox에 Ubuntu를 설치하는 것에서부터 난관에 부딪혔고, 너무 느리게 동작하여 답답했다. 또, 시간이 부족하여 Linux 사용법에 대해서는 전혀 다루지 않다보니 디렉터리 이동과 같은 쉘 사용 기초를 어려워하는 수강자도 있었다. 그에 반해 한 수강자는 끝까지 Windows에서 개발과 실습을 했는데, 자잘한 문제에 부딪혔지만 그래도 실습 전 과정을 무사히 치러내 다행스러우면서도 다소 허무하기도 했다. 난 Debian 계열 Linux를 좋아하지만, 실제로는 개발은 Mac OS X에서 하고 실 서비스는 Redhat 계열 Linux에서 하다보니 나 조차도 강의 진행에 시행착오를 겪기도 했다.&lt;/p&gt;

&lt;p&gt;강의에 대해서도 고민이 많았다. 나는 &lt;a href=&quot;http://www.slideshare.net/yongho&quot;&gt;하용호&lt;/a&gt;님의 발표나 강의를 좋아하여 그의 강의 방식을 분석하고 좇으려 했지만, 교재 작성하는 데 시간에 쫓겨서 흉내조차 내지 못 했다. “교재라도 남기자”로 강의 계획을 변경한 요인엔 내 강의 운영이 부족한 탓도 있다.&lt;/p&gt;

&lt;p&gt;수강자들마다 프로그래밍 소양이나 수준이 상당히 다르다보니 수강자가 할 만한 질문이나 겪을만한 오류 상황을 최대한 폭넓게 예측하고 준비하는 것도 힘들었다. 그런 강의 준비 과정에서 &lt;a href=&quot;https://github.com/django/django/compare/master...hannal:ticket_24181&quot;&gt;number format의 구분자 문자열이 뒤집히는 Django의 버그&lt;/a&gt;를 발견해 Django 프로젝트에 소스를 제출하는 즐거운 경험을 했지만&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;, 강의 준비 자체는 무척 고되었다. 실제로 준비한 강의 자료 대부분은 수업 시간이 부족하기도 하고 수강자가 질문하지 않아서 활용되지 못하였다.&lt;/p&gt;

&lt;h4 id=&quot;정리&quot;&gt;정리&lt;/h4&gt;

&lt;p&gt;초반 혼란기를 극복한 60% 수강자는 마지막 수업까지 남아 함께 했다. VirtualBox에 Ubuntu Linux를 설치하면서 Linux를 제대로 접한 한 수강자는 아예 자신의 랩탑에 Linux를 설치하여 다루었고, 굉장히 사소한 오타나 실수로 Python 인터프리터 오류를 일으켜 어쩔 줄 몰라하던 수강자는 내가 힌트를 주는 것만으로도 문제 원인을 파악해 스스로 해결할만큼 성장했다. 놀랍고 기뻤다.&lt;/p&gt;

&lt;p&gt;잔존율 50%를 목표로 두었는데 예상보다 높은 잔존율을 달성한 점도, 질문 수준이 나날이 높아진 점도 보람찼다. 질문과 답변이 왕성하게 오간 교육 과정이라는 패스트캠퍼스측 피드백도 기분 좋았다. 누군가 성장하는 데 기여하는 건 정말 뿌듯하다. 그리고, 다른 이가 성장하도록 돕는 과정에서 나 역시 성장하는 것도 좋은 경험이다.&lt;/p&gt;

&lt;p&gt;곧 &lt;a href=&quot;http://www.fastcampus.co.kr/camp_wpa/&quot;&gt;웹 서비스 개발 2기&lt;/a&gt;를 시작한다. 1기 때 구축한 수업 자료도 있고 내 강의량을 좀 줄였기에 1기 때에 비해 좀 더 수월하길 바라본다.&lt;/p&gt;

&lt;p&gt;아참, 애초 강의의 목적이었던 집필에 대해 조금 언급하자면, 목차 작업을 얼추 마쳐가고 있다. :)&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;이 말은 연재 중인 강좌에 필요한 기반 마련은 진작 끝냈다는 뜻이다. 단지 너무 바빠서 강좌 글 자체를 작성하지 못하고 있다. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;당시 우리 회사 CTO이자 공동창업자인 Spike^ekipS님이 도입했는데, IPython을 비롯해 내가 접한 개발 도구나 라이브러리, 기술 상당 수는 그가 알려준 것이며, 코드도 그에게서 영향을 받았다. 개발자로서 내게 영향을 준 사람은 두 명(Spike^ekipS, cpascal)인데, 두 사람 모두 뛰어난 해커이다. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;Django 1.8판에 반영되었다. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
  
  <entry>
    <title>개발 생활 - 3</title>
    <link href="/2015/03/devlife-s1-03/"/>
    <updated>2015-03-04T22:05:40+09:00</updated>
    <id>/2015/03/devlife-03</id>
    <content type="html">&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-01/&quot;&gt;개발 생활 - 1&lt;/a&gt; : PDF 문서 생성 서버&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;개발 생활 - 2&lt;/a&gt; : 연산된 데이터 수집 작업자&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-03/&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;개발 생활 - 3&lt;/code&gt;&lt;/a&gt; : 전자우편 알림 서버&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-04/&quot;&gt;개발 생활 - 4&lt;/a&gt; : Python과 Django 강의&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-05/&quot;&gt;개발 생활 - 5&lt;/a&gt; : 공부 자료&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.hannal.com/2015/03/devlife-s1-06/&quot;&gt;개발 생활 - 6&lt;/a&gt; : 앞으로 계획&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2-개발-프로젝트&quot;&gt;2. 개발 프로젝트&lt;/h3&gt;

&lt;h4 id=&quot;2-3-전자우편-알림-서버&quot;&gt;2-3. 전자우편 알림 서버&lt;/h4&gt;

&lt;h5 id=&quot;개요&quot;&gt;개요&lt;/h5&gt;

&lt;p&gt;전자우편 알림 서버는 특정 사건(event)이 발생하면 관련된 사람에게 그 사건에 대해 알리는 역할을 한다. 가령, K와 C영업인이 한날이라는 고객을 담당하고 있는데, C담당자가 고객과 영업 관련 일정을 잡을 경우, K담당자에게도 이에 대한 내용을 전자우편으로 안내하는 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요구사항
    &lt;ol&gt;
      &lt;li&gt;사건이나 상황(event)이 발생하면, 이와 관련된 담당자나 팀에 즉시 전자우편으로 그 내용을 보낸다.&lt;/li&gt;
      &lt;li&gt;비밀번호 찾기 등 고객 홈페이지에서 발생하는 안내나 통지 행위도 처리한다.&lt;/li&gt;
      &lt;li&gt;여러 상황에 처한 고객에게 상황에 맞는 전자우편을 자동으로 보낸다.
        &lt;ul&gt;
          &lt;li&gt;예) 특정 기간 이상 접속하지 않은 고객에게 서비스 이용 안내와 매물을 추천&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;내가 정한 추가 목표치
    &lt;ul&gt;
      &lt;li&gt;Python 3로 작성한다.&lt;/li&gt;
      &lt;li&gt;프로그래밍 언어나 라이브러리, 프레임워크를 이전(migration)할 가능성을 염두에 두고 구조를 짠다.&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/&quot;&gt;PEP 8&lt;/a&gt;을 최대한 지킨다.&lt;/li&gt;
      &lt;li&gt;병렬로 작업(알림 처리)을 수행한다.&lt;/li&gt;
      &lt;li&gt;Unittest를 작성한다.&lt;/li&gt;
      &lt;li&gt;오류 내역을 효율성 있게 관리한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;개발-환경&quot;&gt;개발 환경&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;언어 : Python 3.4, Go 1.3&lt;/li&gt;
  &lt;li&gt;사용 라이브러리, 프레임워크
    &lt;ul&gt;
      &lt;li&gt;ORM : &lt;a href=&quot;http://www.sqlalchemy.org/&quot;&gt;SQLAlchemy&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;반복 예약과 분산 처리 : &lt;a href=&quot;http://www.celeryproject.org/&quot;&gt;Celery&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;템플릿 : &lt;a href=&quot;http://jinja.pocoo.org/&quot;&gt;Jinja2&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;오류 내역 관리 : &lt;a href=&quot;http://www.getsentry.com&quot;&gt;Sentry&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;PEP 8 검사 : &lt;a href=&quot;https://pypi.python.org/pypi/flake8&quot;&gt;Flake 8&lt;/a&gt;, &lt;a href=&quot;https://github.com/SublimeLinter/SublimeLinter3&quot;&gt;SublimeLinter&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;HTTP 처리 : &lt;a href=&quot;http://docs.python-requests.org/en/latest/&quot;&gt;Requests&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;개발-과정&quot;&gt;개발 과정&lt;/h5&gt;

&lt;p&gt;먼저 이름부터 붙였다. Mailer라는 비공식 이름이 통용되었지만 좀 더 일상과 대중에 친숙한 단어인 postman이라 프로젝트 이름을 붙였다. 보이지 않는 곳에서 나대지 않고 조용히 일하는 느낌이 들도록 머릿글자도 소문자로 표기했다.&lt;/p&gt;

&lt;p&gt;작동 흐름은 간단했다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;알림 전자우편
    &lt;ol&gt;
      &lt;li&gt;전자우편 발송 요청(request)을 API Server가 받으면 각 요청을 발송 대기함에 쌓음.&lt;/li&gt;
      &lt;li&gt;발송 작업자(worker)가 대기함에 있는 발송 대상을 가지고 와서 전자우편 발송 서비스에 전달.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;개인 또는 그룹을 대상으로 하는 소식지(newsletter)
    &lt;ol&gt;
      &lt;li&gt;일정 주기 마다 소식지 주제 별 수신자를 수집(build).
        &lt;ul&gt;
          &lt;li&gt;예) 가입 후 일정 기간 동안 로그인을 안 한 이용자들에게 서비스 안내 전자우편 발송.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;수신자 그룹을 전자우편 발송 서비스에 생성.&lt;/li&gt;
      &lt;li&gt;생성한 수신자 그룹으로 전자우편 발송.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;SMTP 서버를 직접 구축하진 않기로 했다. 개발팀에서 프로그래머는 개발과 운영, 관리를 수행하고 있는데다 여러 개 제품이 이미 운영되고 있었기 때문에 되도록 관리할 대상을 줄여야 했기 때문이다. 그래서 전자우편 발송 서비스를 이용하기로 하고, 몇 개 업체를 검토한 끝에 &lt;a href=&quot;https://www.mailjet.com&quot;&gt;Mailjet&lt;/a&gt;을 이용하기로 결정했다. API도 잘 만들어져 있고, SMTP를 제공하며, 이미 쓰고 있는 지인이 소개해주어 무료 서비스를 사용해봤는데 기대만큼 만족스러웠다.&lt;/p&gt;

&lt;p&gt;또한, 고객 지원도 아주 빠르고 친절했다. 예를 들어, 무료 서비스는 한 달에 발송 가능한 전자우편 개수가 무척 적게 제한되어 있는데, 이 개수를 모르던 나는 몇 백 개째부터는 전자우편이 발송이 안 되고 대기 상태에 머물러있자 이것 저것 설정을 변경하며 방황하고 있었다. 그러자 놀랍게도 몇 십 분 후에 대시보드 페이지에 도움이 필요하느냐는 안내 버튼이 출력되었고, 이 버튼을 눌러 실시간 대화를 나누어 문제를 파악하고 처리할 수 있었다. 그때가 한국 시간으로 14~15시 경이었기에 꽤 놀랐다. 비용도 한 달에 30,000건 발송하는 정도는 한 달에 약 9 USD이면 되는 수준이라 바로 유료 전환했다.&lt;/p&gt;

&lt;p&gt;postman 프로젝트는 여러 차례 구조를 세웠다 무너뜨리며 설계를 되풀이했다. 그렇다고 해서 처음부터 크게 구조를 잡은 건 아니고, 1차 버전은 특정 상황(event)이 발생하면 담당자에게 이에 대해 개별 전자우편을 보내어 알리는 기능만 개발하는 범위여서 확장하거나 변경될 여지를 두고 구조를 잡았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;발송부(sender)
    &lt;ul&gt;
      &lt;li&gt;발송 서버에 연결하는 API&lt;/li&gt;
      &lt;li&gt;일정 시간 마다 발송 대기함에서 대기 작업물 처리자(periodic worker)&lt;/li&gt;
      &lt;li&gt;각 전자우편에 지정된 템플릿으로 전자우편 제목과 본문을 만드는 서식부&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;발송 대기함에 쌓는 기능부&lt;/li&gt;
  &lt;li&gt;수신자 구성부(builder)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mailjet에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;REST API&lt;/code&gt;로 개별 전자우편을 발송하는 API를 제공했지만, 발송 서버에 연결하는 부분은 SMTP로 처리하였다. 이 방식이 HTTP로 연결하여 요청하는 것보다 좀 더 빨랐다. 쌓인 전자우편을 여러 개 보내야 하는 경우가 생기는데, HTTP/1.x는 매 요청마다 Mailjet 서버에 연결하고 끊기를 되풀이한다. 그에 반해 SMTP는 연결을 유지한다.&lt;/p&gt;

&lt;p&gt;Python으로 SMTP는 &lt;code class=&quot;highlighter-rouge&quot;&gt;smtplib&lt;/code&gt; 모듈을 이용하여 간단하게 다룬다. 다만, 웹에 있는 대부분 예제는 Python 2용이어서 Python 3.4에서는 문제가 발생하는데, 원인은 패키지나 모듈 배치가 바뀐 탓이다. 다행히 Python 공식 문서에 &lt;a href=&quot;https://docs.python.org/3/library/email-examples.html&quot;&gt;email: Examples&lt;/a&gt;라는 문서에 아주 자세한 예제가 나와있다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-02/&quot;&gt;편의점 프로젝트&lt;/a&gt;과는 달리 postman 프로젝트는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Celery&lt;/code&gt;를 이용하여 일정 시간마다 지정한 작업이 진행되도록 하였다. &lt;a href=&quot;http://celery.readthedocs.org/en/latest/userguide/periodic-tasks.html&quot;&gt;Periodic Tasks&lt;/a&gt;를 이용했는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;periodic_task&lt;/code&gt;라는 장식자(&lt;code class=&quot;highlighter-rouge&quot;&gt;decorator&lt;/code&gt;)를 사용했다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from datetime import timedelta

from celery.decorators import periodic_task

notify_staff_settings = {
    'notify_staff': {
        'run_every': timedelta(minutes=1),
    },
}

@periodic_task(**notify_staff_settings)
def notify_staff():
    pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;템플릿 엔진인 &lt;code class=&quot;highlighter-rouge&quot;&gt;Jinja2&lt;/code&gt;는 &lt;a href=&quot;http://www.djangoproject.com&quot;&gt;Django&lt;/a&gt;의 템플릿 문법과 유사하고, &lt;a href=&quot;http://blog.hannal.com/2015/02/devlife-s1-01/&quot;&gt;제안서를 PDF로 만드는 문서 서버&lt;/a&gt;를 만들면서 다뤄서 친숙했다. 다만, 템플릿 전체가 아니라 블록 단위로 내용을 가져오려고 하는 부분은 문서에 예제가 자세히 나오지 않아서 조금 애먹었다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{% block subject %}
[공실] {{ building.name }}에 새로운 공실
{% endblock %}

{% block body %}
  {{ building.id }} - {{ product.id }}
  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이런 템플릿이 있는 경우, 전자우편 제목은 &lt;code class=&quot;highlighter-rouge&quot;&gt;subject&lt;/code&gt; 블록에 있는 내용을, 본문은 &lt;code class=&quot;highlighter-rouge&quot;&gt;body&lt;/code&gt; 블로에 있는 내용을 사용하는 것이다. 템플릿에서 전자우편 제목과 본문을 만들면 알림 전자우편 제목이나 본문 형식(format)이 바뀌어도 Python 애플리케이션 코드는 변동되지 않으므로 애플리케이션 서버를 재가동하지 않아도 되고, 템플릿이 읽히는 다음 작업 시기에 곧바로 변동 내역이 반영된다는 장점이 있다.&lt;/p&gt;

&lt;p&gt;Jinja에서 템플릿을 렌더링하면 템플릿 컨텍스트(변수나 필터 등)가 반영된 최종 결과물 문자열이 반환된다. 나는 이걸 &lt;code class=&quot;highlighter-rouge&quot;&gt;subject&lt;/code&gt; 블록 따로, &lt;code class=&quot;highlighter-rouge&quot;&gt;body&lt;/code&gt; 블록 따로 다루고 싶었고, 당연히(?) Jinja로 이런 처리가 가능하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from jinja2 import (
    Environment,
    FileSystemLoader,
)

_template_engine = Environment(
    loader=FileSystemLoader(settings.TEMPLATE_PATH),
    trim_blocks=True,
)

_template = _template_engine.get_template('test.html')
_context = _template.new_context({
    'title': 'Hello world',
})

email_subject = ''.join(_template.blocks['subject'](_context))
email_body = ''.join(_template.blocks['body'](_context))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;오류 내역은 벼르고 별렀던 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sentry&lt;/code&gt;를 도입하여 관리했다. 그동안은 로그를 쌓거나 출력하여 문제를 추적했는데, 로그가 쌓이면 문제를 추적하기 불편했고, &lt;code class=&quot;highlighter-rouge&quot;&gt;traceback&lt;/code&gt; 정보가 제대로 나오지 않아 문제 파악도 힘들었다. Sentry 역시 전자우편 발송 서버와 마찬가지로 실 서버는 Sentry 회사가 제공하는 서비스를 이용하고, 개발 중에는 내 작업 PC에 직접 설치하여 관리했다. 사용법도 간단하다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;from raven import Client as RavenClient

raven_client = RavenClient(SENTRY_APIKEY)

@raven_client.capture_exceptions
def notify_staff():
    pass
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;우여곡절&quot;&gt;우여곡절&lt;/h5&gt;

&lt;p&gt;Mailjet에서 제공하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;REST API&lt;/code&gt;로 개별 전자우편을 발송하는 과정에서 적지않은 시행착오를 겪었다. REST API를 다루려고 &lt;code class=&quot;highlighter-rouge&quot;&gt;Requests&lt;/code&gt; 라이브러리를 사용했는데 자꾸 요청이 Mailjet 서버로부터 거절되었다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Curl&lt;/code&gt;을 이용하면 잘 작동하였다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl -X POST --user &quot;$MJ_APIKEY_PUBLIC:$MJ_APIKEY_PRIVATE&quot; \
    https://api.mailjet.com/v3/send/message \
    -F from='Miss Mailjet &amp;lt;ms.mailjet@example.com&amp;gt;' \
    -F to=mr.mailjet@example.com \
    -F subject='Hello World!' \
    -F text='Greetings from Mailjet.'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이는 HTTP에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;Post&lt;/code&gt; 방식으로 데이터를 보낼 때 컨텐트 타입을 &lt;code class=&quot;highlighter-rouge&quot;&gt;multipart/form-data&lt;/code&gt;로 보내는 &lt;a href=&quot;https://www.ietf.org/rfc/rfc2388.txt&quot;&gt;RFC 2388&lt;/a&gt;를 따르는 것이며, 이를 Requests 라이브러리를 이용하여 다음과 같이 처리한다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_res = requests.post(
    'https://api.mailjet.com/v3/send/message',
    auth=(
        '$MJ_APIKEY_PUBLIC',
        '$MJ_APIKEY_PRIVATE'
    ),
    data={
        'from': 'Miss Mailjet &amp;lt;ms.mailjet@example.com&amp;gt;',
        'to': 'mr.mailjet@example.com',
        'subject': 'Hello World!',
        'text': 'Greetings from Mailjet.',
    },
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;하지만, 무슨 이유에서인지 Mailjet쪽에서 발송을 거절했다. &lt;a href=&quot;http://www.getpostman.com/&quot;&gt;Postman&lt;/a&gt;이라는 HTTP 클라이언트로 보내도 잘 작동했는데, 유독 Requests로는 실패했다. 그래서 HTTP Header를 하나씩 까보니 Requests는 파일을 첨부하면 Curl 등 다른 소프트웨어와는 미묘하게 다른 HTTP Header를 만든다는 걸 발견했고, Mailjet은 이런 요청은 거부하는 민감한 동작을 했다. 어차피 SMTP를 이용해 보낼 계획이어서 SMTP로 직접 발송하여 문제는 해결했지만, 찝찝한 마음이 남았다. 현재는(2015년 3월 기준) 문제없이 발송된다.&lt;/p&gt;

&lt;p&gt;Celery를 사용하는 인터페이스 부분을 추상화하는 과정도 뜻대로 되지 않은 부분이 많았다. 언제든지 Celery를 걷어내고 다른 라이브러리를 사용해도 문제가 없도록 패키지와 모듈 구성을 구성하였는데, 문제가 발생했을 때 문제를 추적하기 불편하였고 추상화 한 것에 비해 실제 Celery를 사용하는 부분 인터페이스가 많지 않았다. 결국은 Celery 인터페이스 이름만 바꾼 것에 가까운 반쪽짜리 추상화가 되고 말았다. 어설픈 추상화는 안 하느니만 못 하다.&lt;/p&gt;

&lt;p&gt;Python 3를 사용하는 데엔 별다른 시행착오를 겪지 않았다. Python 3 기능을 그다지 깊게 사용하지 않기도 했지만, 지난 프로젝트부터 Python 3를 대비하고 준비한 게 도움이 됐다. 그리고, postman 프로젝트에 사용한 외부 라이브러리도 모두 Python 3를 지원했다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://spoqa.github.io/2012/08/03/about-python-coding-convention.html&quot;&gt;PEP 8&lt;/a&gt;을 도입하는 것도 무난했다. PEP 8 검사에 사용한 Flake8의 Sublime Text용 부가기능(plugin)이 Sublime Text 2에서 잘 작동하지 않아 엉겁결에 Sublime Text 3로 이전한 것 빼고는 별달리 어렵거나 힘든 상황은 맞이하지 않았다. &lt;a href=&quot;https://www.python.org/dev/peps/pep-0008/#maximum-line-length&quot;&gt;한 줄을 80열 미만으로 코드를 작성하는 것&lt;/a&gt;을 제외하면.&lt;/p&gt;

&lt;p&gt;Unittest는 만족스럽게 사용하진 못 했다. 딸 출산이 임박한 시기에 이르자 마음이 급해져 다시 원래 개발하던 방식으로 돌아가고 말았던 것이다. 결국 Unittest를 쓰지 않아 겪는 불편을 개발 막바지에 그대로 다시 겪었다.&lt;/p&gt;

&lt;p&gt;Linux에서 프로세스를 관리하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;upstart&lt;/code&gt;용 프로세스 구동 스크립트를 작성하는 데 꽤 고생했다. 그동안 Linux의 init을 쓰거나 Python용 프로세스 관리 도구인 &lt;a href=&quot;http://supervisord.org/&quot;&gt;Supervisor&lt;/a&gt;를 써왔는데, &lt;a href=&quot;http://www.codeok.net/%EC%84%9C%EB%B2%84%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC%20%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94%20%EC%98%AC%EB%B0%94%EB%A5%B8%20%EB%B0%A9%EB%B2%95&quot;&gt;서버 프로세스를 관리하는 올바른 방법&lt;/a&gt;에 대한 글을 읽고 upstart를 사용하기로 했다. 그런데 AWS AMI에서 돌아가는 upstart는 상당히 오래된 버전이어서 웹에서 참고한 자료가 별 도움이 되지 않았다. 가령, &lt;code class=&quot;highlighter-rouge&quot;&gt;uid&lt;/code&gt;나 &lt;code class=&quot;highlighter-rouge&quot;&gt;gid&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;chdir&lt;/code&gt; 같은 명령어가 동작하지 않았다. 워낙 간단한 스크립트여서 무작정 시도했는데, 동작하지 않아 결국 로그를 찍으며 문제를 해결했다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;script
  exec &amp;gt;/tmp/postman_sender.log 2&amp;gt;&amp;amp;1
  exec sudo -u ec2-user /bin/sh -c &quot;/.../postman_run.sh&quot;
end script
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h5 id=&quot;정리&quot;&gt;정리&lt;/h5&gt;

&lt;p&gt;postman 프로젝트는 코딩보다는 설계와 추상화, 그리고 외부 도구 연계에 시간을 많이 썼다. 그동안 Celery나 SQLAlchemy 등 도구의 단편만 다뤘는데, 이번 프로젝트를 진행하면서 좀 더 깊게 들여다보고 시험해 보았다.&lt;/p&gt;

&lt;p&gt;이번 프로젝트는 여러 모로 무척 바빠서 공부를 많이 하지 못 했다. 이 프로젝트에 사용한 기술의 하부 영역을 더 이해하려고 리눅스 시스템 프로그래밍(C언어)과 Python twisted를 공부하였지만, 다소 지지부진하게 진도가 나갔다.&lt;/p&gt;

&lt;p&gt;Go 언어로 작성한 코드는 Go 언어에 좀 더 친숙해진 정도 성과를 거두었다. 워낙 간단한 코드이기 때문이다. 나중에 시간을 내어 발송할 전자우편을 구성(build)하는 부분과 발송 부분을 분리하여 발송 부분을 Go 언어로 재작성하면 좋을 것 같다.&lt;/p&gt;

</content>
  </entry>
  
</feed>