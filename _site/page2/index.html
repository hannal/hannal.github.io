<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <script src="//cdn.optimizely.com/js/3144930209.js"></script>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on iPhones and stuff-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="icon" type="image/png" href="http://blog.hannal.com/favicon.ico" />
  <link rel="alternate" type="application/rss+xml" title="Kay on the rails RSS Feed" href="http://blog.hannal.coom/feed.xml" />
  <title>
    
      Kay on the rails &middot; 
    
  </title>
  <meta property="og:title" content="Kay on the rails &middot; " />
  <meta property="og:site_name" content="Kay on the rails"/>
  <meta property="og:url" content="http://blog.hannal.com" />
  <meta property="fb:app_id" content="308847979152210" />
  <meta property="og:type" content="article" />

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  <!-- Icons -->
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ko_KR/sdk.js#xfbml=1&appId=308847979152210&version=v2.0";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Kay as known as Hannal walks on the rails
</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    <a class="sidebar-nav-item" href="/category/essay/">한날의 낙서</a>
    <a class="sidebar-nav-item" href="/category/kay-on-the-team/">팀과 함께하는 한날</a>
    <a class="sidebar-nav-item" href="/category/start-with-django-lectures/">Django 입문자용 강좌</a>
    <a class="sidebar-nav-item" href="/category/start-with-django-webframework/">Django 중급자용 강좌</a>
    <a class="sidebar-nav-item" href="/category/flaskon-startup-diary/">플라스콘 창업 일지</a>
    <a class="sidebar-nav-item" href="/category/devlife/">개발 생활</a>
    <a class="sidebar-nav-item" href="/category/game/">게임 생활</a>
  </nav>

  <nav class="sidebar-nav" style="margin-top: 1.2em;">
    <a class="sidebar-nav-item" href="/profile/">소개합니다</a>
    <a class="sidebar-nav-item" href="/fingers/">손 끝에 맺힌 글</a>
    <a class="sidebar-nav-item" href="/copyright/">저작권</a>

    
    <span class="sidebar-nav-item">Alpha v</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2016. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Kay on the rails</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2015/10/start_with_django_webframework_10/">
        10. 이용자가 올린 사진 목록 보기
      </a>
    </h1>

    <span class="post-date">02 Oct 2015</span>

    <ul>
<li><a href="http://blog.hannal.com/category/start-with-django-webframework/">날로 먹는 Django 웹프레임워크 강좌 목차</a></li>
<li>마지막 갱신일시 : 2015년 10월 2일 12시 45분</li>
</ul>

<p>사진을 게시하였으니 저장된 사진을 가져와 나열하는 기능이 필요합니다. 로그인한 이용자가 사진을 게시하는 기능을 만들었으니 이용자 단위로 사진을 가져와 보여주는 개인 프로필 공간을 만들어 보겠습니다. 이번 편은 <code>QuerySet</code> 객체를 이용해 데이터를 찾는 방법을 다룹니다.</p>

<p>아참, 강좌를 연재하는 중에 Django 1.8판이 출시되었습니다. 그래서 <a href="http://blog.hannal.com/2014/9/start_with_django_webframework_03/">3편 Photo 앱과 모델 만들기</a>과 <a href="http://blog.hannal.com/2014/11/start_with_django_webframework_05/">5편 url에 view 함수 연결해서 사진 출력하기</a>, <a href="http://blog.hannal.com/2015/05/start_with_django_webframework_07/">7편 사진 게시물 제출하여 게시하기</a>에 관련 내용을 추가 반영했습니다.</p>

<h3>개인 프로필 기능용 앱 만들기</h3>

<p>강좌 <a href="http://blog.hannal.com/2014/8/start_with_django_webframework_01/">1편 Pystagram 기획</a>에서 개인 프로필 공간(이하 프로필 페이지)은 다음 기능을 포함합니다.</p>

<ul>
<li>간단한 소개</li>
<li>팔로잉, 팔로워</li>
<li>이용자가 올린 사진</li>
</ul>

<p>프로필 페이지를 비롯해서 이용자의 대외 노출 기능은 모두 별도 Django 앱을 만들어 다루겠습니다. 꼭 앱으로 나누지 않아도 되지만, 같은 목적이나 맥락끼리 기능을 구분하여 앱으로 묶어 관리하는 게 낫습니다. 터미널 쉘에서 <code>manage.py</code> 파일을 이용해 앱을 추가합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(pystagram) $ python manage.py startapp profiles
</code></pre></div>
<h3>URL 패턴 만들기</h3>

<p>이번 편에서는 “이용자가 올린 사진”을 나열하는 기능을 구현하는데, 페이지 URL은 <code>/user/&lt;이용자 ID&gt;/</code> 패턴입니다. 이전 편까지는 URL 패턴을 <code>settings.py</code> 파일이 있는 시작 패키지의 <code>urls.py</code>에 등록하였는데, 프로필 공간에 들어가는 기능이나 페이지에 필요한 URL은 따로 분리하여 연결하는 방식을 쓰겠습니다. <code>profiles</code> 앱 디렉터리에 <code>urls.py</code> 파일을 만들어서 이 모듈에 프로필 관련 URL을 등록하고, 시작 패키지의 <code>urls.py</code>에서는 앱 <code>urls.py</code>를 <code>include()</code> 함수로 포함시키는 방식입니다. Django Admin에 사용하는 URL 패턴을 이 방식으로 포함시켜 사용합니다.</p>

<p>먼저 시작 패키지, 그러니까 <code>settings.py</code> 파일이 있는 디렉터리에 있는 <code>urls.py</code> 파일을 열고 다음 내용을 추가합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    url(
        r&#39;^user/&#39;,
        include(profile_urls, namespace=&#39;profiles&#39;),
    ),
</code></pre></div>
<p>이 내용을 추가한 <code>urlpatterns</code> 변수는 다음과 같습니다<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup>.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">urlpatterns = [
    url(
        r&#39;^photo/(?P&lt;photo_id&gt;\d+)/$&#39;,
        &#39;photo.views.single_photo&#39;,
        name=&#39;view_single_photo&#39;
    ),
    # 중략
    url(
        r&#39;^user/&#39;,
        include(profile_urls, namespace=&#39;profiles&#39;),
    ),
]
</code></pre></div>
<p><code>user/</code>로 시작하는 URL인 경우 <code>profile_urls</code> 객체를 포함시켜 연결(매핑)하고, 이 영역의 이름공간(<code>namespace</code>)을 <code>profiles</code>으로 명명하였습니다. <code>profile_urls</code>가 뜬금없이 나타났는데, 이 객체는 <code>profiles</code> 앱의 <code>urls.py</code>에 있는 <code>urlpatterns</code> 객체를 <code>profile_urls</code> 이름으로 가져온 것입니다. <code>urlpatterns</code> 위에 다음 코드를 추가합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">from profiles.urls import urlpatterns as profile_urls

urlpatterns = [
    # 중략
]
</code></pre></div>
<p>이와 같은 방식은 <code>patterns()</code> 함수를 이용해 <code>prefix</code>를 지정하여 특정 URL 이하에 대해 뷰 함수를 연결하는 방식과 같습니다.</p>

<p>이번엔 <code>profile_urls</code>로 import 할 프로필 앱의 <code>urlpatterns</code>를 만듭니다. <code>profiles</code> 디렉터리에 <code>urls.py</code> 파일을 만들고 URL 패턴을 추가합니다. </p>
<div class="highlight"><pre><code class="language-text" data-lang="text">from django.conf.urls import url

from . import views

urlpatterns = [
    url(
        r&#39;^(?P&lt;username&gt;[\w.@+-]+)/$&#39;,
        views.profile,
        name=&#39;profile&#39;
    ),
]
</code></pre></div>
<p>URL 정규표현식 패턴은 <code>[\w.@+-]+)/$</code>인데, 영문자, 공백, <code>_</code>, <code>.</code>, <code>@</code>, <code>+</code>, <code>-</code> 문자가 하나 이상인 문자열입니다. 이 정규표현식은 Django에 내장된 <code>User</code> 모델의 <code>username</code>에 사용되는 패턴과 동일합니다. 이 정규표현식에 해당하는 문자열을 <code>username</code>으로 받아 뷰 함수에 인자로 전달합니다. 이 URL은 <code>user/</code>로 시작하는 경우에 해당되니 종합하면 <code>/user/[\w.@+-]+)/</code>인 경우에 <code>profile</code> 뷰 함수를 호출합니다. 이 URL 패턴의 이름은 <code>url()</code> 함수에 <code>name</code> 인자로 <code>profile</code>이라 명명하였습니다.</p>

<p><code>urls.py</code> 파일이 있는 현재 경로(<code>.</code>)에 있는 <code>views</code> 모듈을 읽어온 뒤 이 객체에 있는 <code>profile</code> 속성을 뷰 함수로 연결합니다. 즉, 현재 앱의 <code>views.py</code>를 사용하는 것이며, 사용할 뷰 함수를 직접 읽어와(<code>import</code>) 함수 객체를 <code>url()</code> 함수에 인자로 직접 전달합니다.</p>

<h3>뷰 함수와 템플릿 뼈대 만들기</h3>

<p>이번엔 <code>profiles</code> 앱의 <code>views.py</code> 파일에 <code>profile()</code> 뷰 함수를 추가합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># coding: utf-8

from __future__ import unicode_literals

from django.shortcuts import render

def profile(request, username):
    return render(request, &#39;profile.html&#39;, {})
</code></pre></div>
<p><code>urls.py</code>에서 이용자 이름(ID) 문자열을 <code>username</code>으로 받아내어 뷰 함수로 전달하도록 하였으므로 <code>profile()</code> 함수에서도 두 번째 인자로 <code>username</code>을 지정해야 합니다.</p>

<p>뷰 함수는 뼈대부터 만들 것이므로 뷰 함수에서 사용할 뷰 함수 템플릿을 <code>&#39;profile.html&#39;</code>로 지정합니다.</p>

<p><code>profile.html</code> 템플릿 파일은 앱용 템플릿 디렉터리(<code>APP_DIRS</code><sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>)에 만듭니다. <code>profiles</code> 앱 디렉터리 안에 <code>templates</code> 디렉터리를 새로 만들고, 그 안에 <code>profile.html</code> 템플릿 파일을 만든 뒤 다음 내용을 추가합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{% extends &#39;layout.html&#39; %}

{% block content %}
profile page
{% endblock %}
</code></pre></div>
<p>드디어 뼈대를 만들었습니다. <code>manage.py runserver</code>로 개발용 내장 웹서버를 구동하고 <code>http://localhost:8000/user/hannal/</code>과 같은 URL로 접근하면 프로필 페이지가 나타납니다.</p>

<p>하지만, 이 글 내용 그대로 수행했다면 반갑지 않은 화면이 나타납니다.</p>

<p><img src="/assets/uploads/2015/10/10-not_exist_template_file_error.png" alt=""></p>

<p><code>profile.html</code> 템플릿 파일이 존재하지 않는다는 내용입니다. 이 파일이 분명히 있는데 저 오류가 발생한다면 <code>settings.py</code>에 <code>INSTALLED_APPS</code> 설정에 우리가 새로 생성한 <code>profiles</code> 앱을 추가하지 않아서 그렇습니다. <code>profile.html</code> 템플릿 파일은 <strong><code>profiles</code> 앱 디렉터리</strong>의 <code>templates</code> 디렉터리에 있습니다. 앱 디렉터리에 있다는 의미는 Django가 앱 디렉터리라는 걸 인식해야 한다는 의미입니다. 그래서 <code>INSTALLED_APPS</code>에 추가하는 것입니다. <code>settings.py</code>의 <code>INSTALLED_APPS</code> 항목에 <code>&#39;profiles&#39;</code> 문자열을 추가하면 됩니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">INSTALLED_APPS = (
    &#39;django.contrib.admin&#39;,
    &#39;django.contrib.auth&#39;,
    &#39;django.contrib.contenttypes&#39;,
    &#39;django.contrib.sessions&#39;,
    &#39;django.contrib.messages&#39;,
    &#39;django.contrib.staticfiles&#39;,
    &#39;photo&#39;,
    &#39;profiles&#39;,
)
</code></pre></div>
<p><img src="/assets/uploads/2015/10/10-profile_page_01.png" alt=""></p>

<h3>접속한 페이지의 이용자 정보 가져오기</h3>

<p>접속한 프로필 페이지의 이용자 이름은 뷰 함수에 <code>username</code> 인자로 전달됩니다. 우리는 Django에서 제공하는 <code>User</code> 모델을 사용하므로 이 모델의 <code>username</code> 모델 필드를 검색(lookup)하는 데 사용하여 이용자를 찾습니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">from django.shortcuts import get_object_or_404
from django.contrib.auth import get_user_model

def profile(request, username):
    User = get_user_model()
    user = get_object_or_404(User, username=username)

    return render(request, &#39;profile.html&#39;, {
        &#39;current_user&#39;: user,
    })
</code></pre></div>
<p><code>get_user_model()</code> 함수는 <code>settings.py</code> 모듈의 <code>AUTH_USER_MODEL</code> 설정 항목을 기준으로 Django 프로젝트가 사용하는 이용자 모델을 가져옵니다. 자세한 내용은 <a href="http://blog.hannal.com/2015/06/start_with_django_webframework_08/">8편 로그인, 로그아웃 하기</a> 편을 참고하세요.</p>

<p><code>get_object_or_404()</code> 함수는 지정한 모델과 검색 조건으로 데이터를 가져오려 해보고 없으면 HTTP 404 오류를 일으키는 함수입니다. 두 종류 인자를 필요로 하는데, 첫 번째 인자는 데이터를 찾고 가져올 대상 모델 클래스를 받고, 나머지 인자는 검색에 사용합니다. <code>get_object_or_404(User, username=username)</code>는 <code>User</code> 모델에서 <code>username</code> 모델 필드의 값이 뷰 함수에 인자로 전달된 <code>username</code>과 같은 것을 찾는 내용입니다. <code>/user/hannal/</code> URL로 접근하면 뷰 함수의 <code>username</code> 인자의 값은 <code>&#39;hannal&#39;</code> 문자열이므로 <code>get_object_or_404(User, username=&#39;hannal&#39;)</code>을 실행합니다. 이 함수는 데이터 하나를 특정 지어 반한하므로 여러 데이터가 조건에 해당되선 안 됩니다. 데이터가 없는 경우 <code>django.http</code> 모듈에 있는 <code>Http404</code> 예외 오류를 일으킵니다.</p>

<p>데이터가 있는 경우 <code>user</code>에 할당하고, 이 객체는 <code>profile.html</code> 템플릿에 템플릿 맥락 요소(context)로 전달하며, 템플릿 안에서 템플릿 변수로 사용할 이름은 <code>current_user</code>입니다.</p>

<p>이번엔 <code>profile.html</code> 템플릿 파일을 수정합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{% extends &#39;layout.html&#39; %}

{% block content %}
님의 프로필 페이지

&lt;ul&gt;
{% for photo in current_user.photo_set.all %}
    &lt;li&gt;&lt;img src=&quot;&quot; /&gt;&lt;/li&gt;
{% empty %}
    &lt;li&gt;게시한 사진이 없습니다.&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;

{% endblock %}
</code></pre></div>
<p>눈여겨 볼 부분은 <code>current_user.photo_set.all</code>입니다. 이 부분은 Python 코드로 표현하면 <code>current_user.photo_set.all()</code>입니다. Django 템플릿 엔진은 Python의 함수나 클래스와 같이 호출 가능한(callable) 객체를 템플릿 안에서 소괄호를 쳐서 직접 호출하는 걸 허용하지 않습니다. 객체 이름이나 메서드 이름만 명시하면 Django가 대상의 자료형을 검사해서 호출 가능한 객체인 경우 대신 호출하여 수행합니다. 소괄호를 사용하지 못하므로 함수나 메서드에 인자를 전달하지도 못합니다. 인자를 전달하려면 Django 템플릿 필터나 태그를 직접 만들어 사용해야 합니다.</p>

<p><img src="/assets/uploads/2015/10/10-profile_page_02.png" alt=""></p>

<h3>QuerySet 객체</h3>

<h4>연관 객체 참조 (related objects reference)</h4>

<p><code>current_user.photo_set.all()</code>는 접속한 프로필 페이지의 이용자(<code>current_user</code>)가 소유한(own) 모든 사진 게시물을 가져오는 코드입니다. 하나씩 살펴 보겠습니다.</p>

<p>먼저 <code>current_user</code>는 뷰 함수에서 <code>user</code>입니다. <code>user</code>는 <code>User</code> <strong>모델</strong> 클래스로 데이터를 가져와 연결시켜(mapping) Python 인스턴스 객체로 생성한 것입니다. 그런데 <code>User</code> 모델은 우리가 앞서 만든 <code>photo</code> 앱의 <code>Photo</code> 모델이 <code>ForeignKey</code>로 연결되어 있습니다. 이용자 한 명이 사진을 여러 개 가지므로 <code>User</code> 모델이 1, <code>Photo</code> 모델은 다수(n) 관계라서 <code>User</code> 모델 기준으로는 1:N(OneToMany) 관계입니다.</p>

<p>이 관계가 중요한데요. Django는 모델이 관계(relationship)를 맺고 있으면 연결 당한 쪽에 <strong>연관 객체 참조 속성</strong>이라는 특별한 속성을 만듭니다. 연결하는 쪽은 모델 필드로 연결하는 대상 모델을 가리키고 있지만, 연결 당하는 쪽은 Python 코드상으로는 알 도리가 없습니다. <code>User</code> 모델과 <code>Photo</code> 모델을 놓고 보면, <code>Photo</code> 모델엔 <code>user = models.ForeignKey(settings.AUTH_USER_MODEL)</code> 모델 필드를 만들어서 연결하는 모델이 <code>User</code> 모델이라는 것이 드러나지만, <code>User</code> 모델엔 아무런 조치를 취하지 않으므로 Python 코드만으로는 <code>Photo</code> 모델이 자신을 연결하는지는 알지 못합니다. 하지만 Django는 모델 관계를 파악하여 연결 당하는 쪽에 연결하는 모델에 대한 접근 경로를 객체 속성(attribute)으로 만들어 줍니다.</p>

<p>일 대 다(<code>ForeignKey</code>)나 다 대 다(<code>ManyToManyField</code>) 관계는 연결 당하는 특정 데이터에 연결하는 쪽의 여러 데이터가 관계를 맺습니다. 이처럼 <strong>1</strong>쪽에 <strong>N</strong>으로 연결되는 경우, <strong>1</strong>쪽에 N쪽 모델 이름을 참조하여 속성을 만듭니다. 이 속성은 따로 지정하지 않으면 N쪽 모델 이름을 소문자 Snake case 표기로 만들고 <code>_set</code>을 덧붙인 이름을 갖습니다. <code>User</code> 모델과 <code>Photo</code> 모델로 놓고 보면 <code>User</code> 모델의 인스턴스 객체에 <code>photo_set</code> 속성이 만들어 집니다.</p>

<h4>QuerySet 객체</h4>

<p>연관 객체 참조 속성은 Django 모델의 <code>QuerySet</code> 객체입니다. <code>QuerySet</code>은 이름에서 드러나듯이 Query 집합(set)입니다. Django model manager는 크게 두 종류 객체를 반환하는데, 하나는 <code>QuerySet</code> 객체이고 다른 하나는 <code>QuerySet</code> 객체가 아닌 객체입니다. <code>QuerySet</code>엔 다음과 같은 특징이 있습니다.</p>

<ul>
<li>Model manager의 API를 포함 (정확히는 QuerySet API를 manager가 상속 받아 사용)</li>
<li> 꼬리에 꼬리를 무는 연산(evaluation). 일명 chaining 연산.

<ul>
<li>단 QuerySet(또는 model manager)의 메서드가 반환하는 객체가 QuerySet이어야 함.</li>
</ul></li>
<li>지연 평가 연산과 캐쉬 처리</li>
<li>순서열(<code>str</code>, <code>list</code>, <code>tuple</code>) 연산 지원</li>
</ul>

<p>이러한 특성은 <code>QuerySet</code>의 역할에 기인합니다. <code>QuerySet</code>은 사용자의 요청을 받아 질의(query)를 생성합니다. 이 요청이 데이터베이스에서 데이터를 가져와야만 하는 것이면 생성한 질의를 데이터베이스로 보냅니다. 그렇지 않으면 생성한 질의는 그대로 보관한 <code>QuerySet</code> 객체를 복제하여 새로 반환합니다. 이 경우 반환한 객체도 <code>QuerySet</code> 객체이므로 또 다시 model manager API를 이용해 요청을 보낼 수 있습니다. 이런 과정을 반복합니다. 데이터베이스에 질의를 보내 데이터를 가져오면 그 데이터를 보관해두며, 이 <code>QuerySet</code> 객체의 데이터를 사용하는 경우 보관된 데이터를 사용합니다. 몇 번을 접근하더라도 보관된 데이터를 그대로 재사용합니다.</p>

<ul>
<li>지연 평가 연산 : 데이터베이스에 접근해야 할 때까지 질의를 보내지 않고 질의를 생성해 조합하며 쌓는 동작</li>
<li>캐쉬 처리 : 보관한 데이터를 재사용해 데이터에 접근할 때마다 데이터베이스에 질의를 요청하지 않음</li>
<li>chaining : <code>QuerySet</code> 객체를 반환하는 경우, 그 객체를 이용해 요청을 이어나감</li>
</ul>

<p>우리가 앞서 만든 <code>Photo</code> 모델 클래스로 예를 들겠습니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">qs = Photo.objects.filter(pk__in=(1, 2, 3, 4, ))  # 첫 번째 요청.
qs = qs.filter(description__contains=&#39;te&#39;)  # 두 번째 요청.
qs.count()  # 세 번째 요청.
qs.count()  # 네 번째 요청.
</code></pre></div>
<p>총 네 번 <code>QuerySet</code> 객체의 메서드를 호출했습니다.</p>

<ol>
<li>첫 번째 요청은 <code>pk</code> 모델 필드(기본키, primary key)가 1, 2, 3, 4인 데이터를 가져오라는 질의를 만듭니다. SQL 질의문으로 <code>SELECT * FROM &quot;photo_photo&quot; WHERE &quot;photo_photo&quot;.&quot;id&quot; IN (1, 2, 3, 4)</code>을 생성한 채 일단 기다립니다.</li>
<li>두 번째 요청은 <code>description</code> 모델 필드로 <code>te</code> 문자열을 포함하는 데이터를 가져오라는 질의를 만듭니다. 기존 질의문을 조합한 만드므로 질의문은 <code>SELECT * FROM &quot;photo_photo&quot; WHERE (&quot;photo_photo&quot;.&quot;id&quot; IN (1, 2, 3, 4) AND &quot;photo_photo&quot;.&quot;description&quot; LIKE %te% ESCAPE &#39;\&#39;)</code>가 됩니다. 여전히 데이터베이스에 질의를 보내지 않고 기다립니다.</li>
<li>세 번째 요청은 여태까지 누적한 탐색(lookup) 조건에 해당하는 모든 데이터의 개수를 가져오는 <code>count()</code> 메서드입니다. 데이터베이스에 질의를 보내야만 확인 가능한 데이터입니다. 여태까지 만든 질의문을 비로소 데이터베이서에 요청합니다.</li>
<li>네 번째 요청도 <code>count()</code> 메서드입니다. 이미 캐쉬된 데이터가 있어서 데이터베이스에 질의하지 않고 보관하고 있는 데이터에서 개수를 가져와 반환합니다.</li>
</ol>

<p><code>count()</code> 메서드는 개수를 숫자로 반환하며, 숫자는 정수형(<code>int</code>) 객체여서 더이상 <code>QuerySet</code> 객체의 특성을 사용하지 못합니다. 이렇게 <code>QuerySet</code> 객체를 반환하지 않는 model manager API는 다음과 같습니다.</p>

<table><thead>
<tr>
<th>메서드</th>
<th>반환하는 객체</th>
<th>설명</th>
</tr>
</thead><tbody>
<tr>
<td><code>get()</code></td>
<td>모델 클래스의 인스턴스 객체</td>
<td>조건에 해당하는 특정 데이터를 가져온다.</td>
</tr>
<tr>
<td><code>first()</code></td>
<td>모델 클래스의 인스턴스 객체</td>
<td><code>QuerySet</code>에 보관된 데이터 중 첫 번째 데이터를 가져온다.</td>
</tr>
<tr>
<td><code>last()</code></td>
<td>모델 클래스의 인스턴스 객체</td>
<td><code>QuerySet</code>에 보관된 데이터 중 마지막 데이터를 가져온다.</td>
</tr>
<tr>
<td><code>earliest()</code></td>
<td>모델 클래스의 인스턴스 객체</td>
<td>인자로 전달해 지정한 모델 필드를 기준으로 가장 첫 번째 데이터를 가져온다.</td>
</tr>
<tr>
<td><code>latest()</code></td>
<td>모델 클래스의 인스턴스 객체</td>
<td>인자로 전달해 지정한 모델 필드를 기준으로 가장 마지막 데이터를 가져온다.</td>
</tr>
<tr>
<td><code>count()</code></td>
<td><code>int</code> 객체</td>
<td><code>QuerySet</code>에 보관된 질의를 기준으로 개수를 가져오거나 보관된 데이터의 개수를 가져온다.</td>
</tr>
<tr>
<td><code>exists()</code></td>
<td><code>bool</code> 객체</td>
<td><code>QuerySet</code>에 보관된 질의 또는 보관된 데이터를 기준으로 데이터가 존재하는 지 여부를 가져온다.</td>
</tr>
<tr>
<td><code>get_or_create()</code></td>
<td>모델 클래스의 인스턴스 객체</td>
<td>조건에 해당하는 특정 데이터를 가져오고 없으면 인자로 전달한 내용으로 데이터를 저장한 후 가져온다.</td>
</tr>
<tr>
<td><code>update_or_create()</code></td>
<td>모델 클래스의 인스턴스 객체</td>
<td>특정 데이터를 수정하고, 그 데이터가 없으면 인자로 전달한 내용으로 데이터를 저장한 후 가져온다.</td>
</tr>
</tbody></table>

<p>이외에도 몇 가지 더 있는데 강좌 진행 중 사용하면 자세히 다루겠습니다. </p>

<p><code>QuerySet</code> 객체를 반환하는 메서드도 살펴 보겠습니다.</p>

<table><thead>
<tr>
<th>메서드</th>
<th>설명</th>
</tr>
</thead><tbody>
<tr>
<td><code>all()</code></td>
<td>전체 데이터를 가져온다.</td>
</tr>
<tr>
<td><code>filter()</code></td>
<td>인자로 전달한 조건에 해당하는 데이터를 가져온다.</td>
</tr>
<tr>
<td><code>exclude()</code></td>
<td>인자로 전달한 조건에 해당하지 않는 데이터를 가져온다.</td>
</tr>
<tr>
<td><code>order_by()</code></td>
<td>지정한 모델 필드로 정렬하여 가져온다.</td>
</tr>
<tr>
<td><code>reverse()</code></td>
<td><code>QuerySet</code>에 저장된 데이터를 뒤집어서 가져온다.</td>
</tr>
<tr>
<td><code>select_related()</code></td>
<td>N:1(ManyToOne, <code>ForeginKey</code>)으로 연결된 데이터를 함께 가져온다. 데이터베이스의 <code>JOIN</code> 처리.</td>
</tr>
<tr>
<td><code>prefetch_related()</code></td>
<td>N:N(<code>ManyToManyField</code>)으로 연결된 함께 데이터를 가져온다. 데이터베이스의 <code>JOIN</code> 처리</td>
</tr>
<tr>
<td><code>using()</code></td>
<td>지정한 데이터베이스에서 데이터를 가져온다. 기본은 <code>default</code>로 지정된 데이터베이스.</td>
</tr>
</tbody></table>

<p>이번 편에서는 <code>all()</code>, <code>filter()</code>와 <code>order_by()</code>을 다루며, 다른 메서드는 사용할 때 자세히 다루겠습니다.</p>

<h4><code>filter()</code> 메서드</h4>

<p><code>photo_set</code>을 설명하려고 먼 길 다녀왔네요. <code>photo_set</code> 속성은 <code>QuerySet</code> 객체입니다. 그냥 객체는 아니고 조건이 걸려있는 <code>QuerySet</code>입니다. <code>photo_set</code>은 <code>User</code> 모델의 인스턴스 객체에서 사용하는데, 이 말은 <code>User</code> 모델로 가져온 이용자 데이터를 담고 있는 인스턴스 객체, 즉 특정 이용자에 연결된 <code>photo_set</code>입니다. 이를 <code>Photo</code> 모델로 풀어쓰면 다음 코드와 같습니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">current_user = User.objects.get(username=&#39;hannal&#39;)
photos = Photo.objects.filter(user=current_user)
</code></pre></div>
<p>이 코드는 <code>username</code>이 <code>&#39;hannal&#39;</code>인 이용자를 <code>current_user</code>에 할당하고, 소유주(<code>user</code>)가 <code>current_user</code>인 모든 사진 게시물(<code>Photo</code>)을 찾아서 <code>photos</code>에 할당합니다. 간단히 말해 <code>username</code>이 <code>&#39;hannal&#39;</code>인 이용자의 모든 사진 게시물을 가져오는 것이지요.</p>

<p><code>filter()</code> 메서드는 검색(lookup) 조건을 <a href="http://blog.hannal.com/2015/03/keyword-only-arguments_and_annotations_for_python3/">키워드 인자</a>를 받습니다. 인자 이름(key)는 모델 필드의 탐색 방식이고 전달하는 객체(value)는 검색할 값입니다. <code>filter(description=&#39;hannal&#39;)</code>로 키워드 인자를 전달하면 모델 필드 <code>description</code>의 값이 <code>hannal</code>과 일치하는 데이터를 찾습니다.</p>

<p>하지만 검색 방식이 이렇게 단순하진 않습니다. <code>hannal</code> 문자열과 일치하는 게 아니라 <code>hannal</code> 문자열을 포함한다든지 지정한 숫자보다 큰 값을 갖는 데이터를 찾는 식으로 다양한 검색 방식이 필요한데, Django는 모델 필드 이름에 <code>__탐색키워드</code>를 덧붙인 인자 이름으로 이러한 검색을 지원합니다. 예를 들어 <code>hannal</code> 문자열을 포함하는 데이터를 찾는 조건이라면 <code>filter(description__contains=&#39;hannal&#39;)</code>와 같이 <code>__contains</code>를 모델 필드인 <code>description</code>에 덧붙입니다.</p>

<table><thead>
<tr>
<th>탐색 키워드</th>
<th>설명</th>
</tr>
</thead><tbody>
<tr>
<td><code>contains</code></td>
<td>지정한 문자열을 포함</td>
</tr>
<tr>
<td><code>in</code></td>
<td>리스트나 튜플에 담긴 값들에 해당</td>
</tr>
<tr>
<td><code>gt</code></td>
<td>지정한 값을 <strong>초과</strong></td>
</tr>
<tr>
<td><code>gte</code></td>
<td>지정한 값 <strong>이상</strong></td>
</tr>
<tr>
<td><code>lt</code></td>
<td>지정한 값 <strong>미만</strong></td>
</tr>
<tr>
<td><code>lte</code></td>
<td>지정한 값 <strong>이하</strong></td>
</tr>
<tr>
<td><code>year</code></td>
<td>지정한 연도. <code>DateField</code>나 <code>DateTimeField</code> 필드에 한함</td>
</tr>
<tr>
<td><code>month</code></td>
<td>지정한 월. <code>DateField</code>나 <code>DateTimeField</code> 필드에 한함</td>
</tr>
<tr>
<td><code>day</code></td>
<td>지정한 일. <code>DateField</code>나 <code>DateTimeField</code> 필드에 한함</td>
</tr>
</tbody></table>

<p>탐색 키워드 역시 자주 쓰는 것만 소개하였으며, 이외 탐색 키워드는 사용할 때 자세히 다루겠습니다.</p>

<p>여러 탐색 조건을 지정해도 되는데, 함수에 키워드 인자 여러 개를 넣는 방법과 동일합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Photo.objects.filter(user=current_user, description__contains=&#39;te&#39;)
Photo.objects.filter(user=current_user).filter(description__contains=&#39;te&#39;)
</code></pre></div>
<p>두 코드는 동일한 역할을 합니다. 이 코드는 사진 게시물의 <code>user</code>가 <code>current_user</code>이고(AND), <code>description</code>에 <code>&#39;te&#39;</code> 문자열이 포함된 모든 데이터를 가져옵니다. 쉼표로 구분해 여러 키워드 인자를 전달하든 <code>filter()</code> 메서드를 체인으로 반복해서 부르든 동일하게 <code>AND</code> 조합으로 데이터를 찾습니다. <code>OR</code> 조합으로 찾으려면 별도 조치를 취해야 하는데, 나중에 다루겠습니다.</p>

<p>정리하면, <code>User</code> 모델 클래스의 인스턴스 객체에 있는 <code>photo_set</code> 속성은 <code>Photo</code> 모델 클래스와 연결되어 만들어졌으며, <code>QuerySet</code> 객체로 만들어졌는데 이 <code>QuerySet</code> 객체는 <code>photo_set</code> 속성이 속한 <code>User</code> 인스턴스 객체의 데이터를 기반으로 합니다. <code>photo_set</code>은 <code>QuerySet</code> 객체이므로 체인 연결하듯이 후속 <code>QuerySet</code>의 메서드를 사용할 수 있습니다. <code>current_user.photo_set.all()</code>은 <code>all()</code> 메서드를 쓴 것입니다. <code>Photo.objects.filter(user=current_user).all()</code>과 동일한 역할을 합니다.</p>

<h3>사진 정렬하여 나열하기</h3>

<p>프로필 페이지에서 사진은 저장된 등록된 순서대로 나열됩니다. 별도로 지정하지 않으면 기본키(primary key)를 기준으로 하여 순서대로 나열되기 때문입니다. <code>QuerySet</code>으로 가져오는 데이터를 정렬하는 방법은 크게 두 가지입니다.</p>

<ul>
<li><code>order_by()</code> 메서드로 정렬할 모델 필드 이름 지정</li>
<li>모델에 정렬할 기본(default) 기준을 지정</li>
</ul>

<p><code>order_by()</code>는 <a href="http://blog.hannal.com/2015/03/keyword-only-arguments_and_annotations_for_python3/">위치 인자</a>로 정렬 기준으로 삼을 모델 필드 이름을 문자열로 받습니다. 여러 개를 지정하면 정렬 우선순위에 따라 정렬합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Photo.objects.order_by(&#39;created_at&#39;)  # created_at 순서대로.
Photo.objects.order_by(&#39;-created_at&#39;)  # created_at 역순으로.
</code></pre></div>
<p>첫 번째 구문은 전체 사진 게시물을 <code>created_at</code> 모델 필드 기준으로 하여 순서대로 가져옵니다. 역순으로 가져오려면 모델 필드 이름 앞에 <code>-</code>를 덧붙이면 되며 두 번째 구문이 <code>created_at</code> 역순으로 정렬하는 것입니다. 만약 <code>created_at</code>, 즉 생성일시가 완전히 동일한 경우에는 기본키 역순으로 정렬하도록 하려면 인자를 추가하면 됩니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">Photo.objects.order_by(&#39;-created_at&#39;, `-pk`)
</code></pre></div>
<p>무작위 순서로 정렬하려면 <code>Photo.objects.order_by(&#39;?&#39;)</code>처럼 <code>&#39;?&#39;</code>를 인자로 전달하면 되는데, 주의할 점은 상당히 느립니다. 되도록이면 쓰지 않길 권합니다.</p>

<p>모델에 정렬할 기본 기준을 정하려면 모델에 <code>Meta</code> 클래스를 만들고, <code>Meta</code> 클래스 안에 <code>ordering</code> 속성을 만들어 정렬할 모델 필드 이름을 나열하면 됩니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">class Photo(models.Model):
    user = models.ForeignKey(settings.AUTH_USER_MODEL)
    image_file = models.ImageField(upload_to=&#39;%Y/%m/%d&#39;)
    filtered_image_file = models.ImageField(
        null=True,
        upload_to=&#39;static_files/uploaded/%Y/%m/%d&#39;
    )
    description = models.TextField(max_length=500, blank=True)
    created_at = models.DateTimeField(auto_now_add=True, auto_now=False)

    class Meta:
        ordering = (&#39;-created_at&#39;, &#39;-pk&#39;, )

    # 후략
</code></pre></div>
<p>나중에 자세히 다루겠지만, 템플릿에서는 함수 호출하듯이 소괄호(<code>(</code>과 <code>)</code>)를 사용하여 객체 호출을 직접 하지 못합니다. <code>profile.html</code> 템플릿 파일에서 <code>{% for photo in current_user.photo_set.all %}</code>와 같은 구문을 <code>{% for photo in current_user.photo_set.order_by(&#39;-created_at&#39;, &#39;-pk&#39;) %}</code>와 같이 쓰지 못합니다. 그래서 정렬하려면 뷰 함수에서 정렬한 데이터를 별도 변수에 할당하여 이 변수를 템플릿에 전달해야 합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text"># photo/views.py

def profile(request, username):
    User = get_user_model()
    user = get_object_or_404(User, username=username)
    photos = user.photo_set.order_by(&#39;-created_at&#39;, &#39;-pk&#39;)

    return render(request, &#39;profile.html&#39;, {
        &#39;current_user&#39;: user,
        &#39;photos&#39;: photos,
    })
</code></pre></div><div class="highlight"><pre><code class="language-text" data-lang="text">{# photo/templates/profile.html #}
&lt;ul&gt;
{% for photo in photos %}
    &lt;li&gt;&lt;img src=&quot;&quot; /&gt;&lt;/li&gt;
{% empty %}
    &lt;li&gt;게시한 사진이 없습니다.&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;
</code></pre></div>
<p>또는 모델에서 정렬 기준을 정의하여 따로 <code>order_by()</code> 메서드를 쓰지 않더라도 기본으로 지정한 기준대로 정렬되도록 처리해도 됩니다.</p>

<p>이 강좌에서는 명시한 정렬 기준이 코드에 드러나는 차원에서 뷰 함수에서 정렬하겠습니다.</p>

<hr>

<p>강좌 10편을 마칩니다. 정말 오랜만에 연재했네요. 이제 몇 회만 더 연재하면 강좌 1부가 끝납니다. 강좌 분량이 많아지면서 처음 계획을 바꿨습니다.</p>

<ul>
<li>1부 : Django 전반을 두루 겪기</li>
<li>2부 : 1부에서 다루지 않은 내용을 더 자세히 다루기</li>
<li>3부 : 앞단 만들고 배포하기</li>
</ul>

<p>올해 안에 1부를 마치도록 노력하겠습니다.</p>

<ul>
<li><a href="https://github.com/hannal/start_with_django_webframework/tree/10-fullsource/pystagram">10편까지 진행한 전체 소스 코드</a></li>
</ul>

<hr>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p><a href="http://blog.hannal.com/2014/11/start_with_django_webframework_05/">5편 url에 view 함수 연결해서 사진 출력하기</a> 부록에 변화한 <code>urlpatterns</code>에 대한 내용을 2015년 10월에 추가하였습니다.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>Django 1.8판부터 템플릿 설정 정책이 바뀌었으며, 이에 대한 내용은 <a href="http://blog.hannal.com/2014/9/start_with_django_webframework_03/">3편 Photo 앱과 모델 만들기</a> 부록으로 2015년 10월에 추가하였습니다.&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2015/07/celery_chord_and_chain/">
        Celery의 Subtask 기능을 이용하여 Chord와 Chain로 작업 분산해서 다루기
      </a>
    </h1>

    <span class="post-date">08 Jul 2015</span>

    <h3>웹페이지 긁어오기</h3>

<p>Python으로 웹페이지 열 곳을 긁어와서 하나로 합쳐 보겠습니다. Python HTTP library인 <a href="http://docs.python-requests.org/en/latest/">requests</a>를 쓰면 아주 간단합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">import requests

def fetch_page_by_url(url):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text

merged_text = []
for i in range(0, 10):
    result = fetch_page_by_url(
        &#39;http://localhost:8000/{}.html&#39;.format(i)
    )

    if result is not None:
        merged_text.append(result)

do_something(merged_text.join(&#39;&#39;))
</code></pre></div>
<h3>Celery를 이용해 비동기 방식으로 긁어오기</h3>

<p>차례대로 긁어오니 열 개 페이지를 모두 가져오기 전까지는 결과를(<code>do_something(merged_text.join(&#39;&#39;))</code>) 확인하지 못합니다. <a href="https://docs.python.org/3/library/multiprocessing.html">multiprocessing</a>을 이용해 여러 프로세스로 동시성을 확보해도 되지만, 분산 작업 큐 시스템인 <a href="http://celery.readthedocs.org/en/latest/">Celery</a>로 쉽고 간편하게 비동기 처리하기도 합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">from celery import Celery

app = Celery(__name__)

@app.task
def fetch_page_by_url(url):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text

merged_text = []
for i in range(0, 10):
    result = fetch_page_by_url.apply_async(
        &#39;http://localhost:8000/{}.html&#39;.format(i)
    )

    if result is not None:
        merged_text.append(result)

do_something(merged_text.join(&#39;&#39;))
</code></pre></div>
<p>이 코드에는 문제가 있습니다. Celery 작업 수행 객체로 장식된(decorated) <code>fetch_page_by_url</code> 객체의 <code>apply_async()</code> 메서드를<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup> 이용하여 <strong>비동기</strong>로 작업을 수행하는데, 이 메서드가 반환하는 객체는 <code>res.text</code>가 아니라 Celery 결과 작업을 다루는 객체입니다. 게다가 비동기로 작업을 수행하고 바로 프로그램 수행 제어권을 호출자에게 반환하므로 <code>fetch_page_by_url.apply_async(...)</code> 호출이 되자마자 바로 다음 구문을 수행하는데, 웹 페이지를 가져오는 작업이 끝났는지 여부는 알지 못 합니다.</p>

<p>이 문제를 피하려면 <code>get()</code> 메서드를 이용합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">    if result.get() is not None:
        merged_text.append(result)
</code></pre></div>
<p><code>get()</code> 메서드는 비동기로 수행하는 작업 객체(<code>fetch_page_by_url()</code>)가 작업을 마치고 값을 반환하기를 <strong>동기식</strong>으로 기다려서 반환합니다. 어?! 이렇게 할 거라면 굳이 Celery를 쓸 필요가 없지요. Celery에게 여러 작업을 맡겨서 비동기로 처리하고, 비동기로 처리한 결과를 받아다 뭔가를 하려면 다른 방법을 써야 합니다. 이 글에서는 <code>chain</code>와 <code>chord</code>을 사용하겠습니다.</p>

<h3>chain 기능</h3>

<p><code>chain</code> 기능은 이름에서 전해지듯이 작업을 체인처럼 줄줄이 수행합니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">from celery import chain

@app.task
def fetch_page_by_url(url, append_text=None):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        if append_text is None
            return res.text
        else:
            res.text + append_text

tasks = []
for i in range(0, 10):
    tasks.append(
        fetch_page_by_url.subtask(
            &#39;http://localhost:8000/{}.html&#39;.format(i)
        )
    )

result = chain(tasks)()
</code></pre></div>
<p><code>subtask()</code>는 Celery 작업 객체를 하위 작업으로 수행하는 메서드입니다<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup>. <code>fetch_page_by_url</code> 객체를 하위 작업으로 수행하는 작업 열 개를 담아 <code>chain()</code>에 전달하면 <code>chain()</code>은 순서대로 작업을 수행합니다. 각 작업이 반환하는 객체는 다음 작업자에게 인자로 전달합니다. 첫 번째 <code>fetch_page_by_url()</code> 함수가 반환하는 웹페이지 문자열을 두 번째 <code>fetch_page_by_url()</code>는 두 번째 인자로 받는 것이죠. 그래서 두 번째 <code>fetch_page_by_url()</code>부터는 앞 작업자가 반환하는 결과를 넘겨 받는 것이지요.</p>

<p>다른 예를 들어 보겠습니다. 숫자 두 개를 인자로 전달하면 두 숫자를 더하는 작업자를 쓰겠습니다.</p>

<ol>
<li>첫 번째 셈은 1 + 1 입니다.</li>
<li>두 번째 셈은 첫 번째 덧셈 결과를 받아서 10을 더합니다.</li>
<li>세 번째 셈은 두 번째 덧셈 결과를 받아서 100을 더합니다.</li>
</ol>

<p>이걸 <code>chain()</code>을 이용하면 다음과 같습니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">do_chain_tasks = chain(add.s(1, 1), add.s(10), add.s(100))
do_chain_tasks()
</code></pre></div>
<p><code>chain()</code>도 바로 작업을 수행하는 게 아니라 Celery 작업 객체를 반환하며<sup id="fnref3"><a href="#fn3" rel="footnote">3</a></sup>, 이 작업 객체를 실행해야 합니다. 바로 위 코드는 <code>chain(...)()</code>라는 구문을 나눈 것입니다.</p>

<p>재밌는 점은 Celery는 비트 연산으로도 <code>chain()</code> 작업 객체를 만들어 준다는 점입니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">(
    fetch_page_by_url.s(&#39;http://localhost:8000/0.html&#39;) |
    fetch_page_by_url.s(&#39;http://localhost:8000/1.html&#39;) |
    fetch_page_by_url.s(&#39;http://localhost:8000/2.html&#39;) |
    fetch_page_by_url.s(&#39;http://localhost:8000/3.html&#39;)
).apply_async()
</code></pre></div>
<p>참 꼼꼼하게 만들어 놨어요. :)</p>

<h3>chord 기능</h3>

<p><code>chain()</code>을 이용해 비동기로 열 개 작업을 수행하고 그 결과를 합쳤는데, 아쉬운 마음이 듭니다. 전체 작업 자체는 분명 비동기로 시작한 게 맞지만, 웹페이지를 긁어오는 작업도 동시에 분산해서 처리하면 더 효율이 좋을 겁니다. <code>chord()</code>는 하위 작업을 동시에 수행하고, 각 작업자가 반환하는 값을 callback 실행 객체로 전달해줍니다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">from collections import MutableSequence
from celery import chord

@app.task
def fetch_page_by_url(url):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text

@app.task
def merge_text(texts):
    assert(isinstance(texts, MutableSequence))
    return texts.join(&#39;&#39;)

tasks = []
for i in range(0, 10):
    tasks.append(
        fetch_page_by_url.s(&#39;http://localhost:8000/{}.html&#39;.format(i))
    )

do_chain_tasks = chord(tasks)
do_chain_tasks(merge_text.s())
</code></pre></div>
<p><code>fetch_page_by_url()</code> 함수가 원래대로(?) 돌아왔고, <code>merge_text()</code> 함수가 새로 추가됐습니다. <code>merge_text()</code>는 전달받은 인자 <code>texts</code>를 합치는 일을 하는데, <code>fetch_page_by_url()</code>가 반환하는 문자열을 담은 리스트형(<code>list</code>) 객체입니다. 맨 처음에 비동기로 작성한 코드에서 웹페이지 문자열을 리스트로 담은 <code>merged_text</code>와 같습니다.</p>

<p><code>chord()</code>는 각 작업자(<code>fetch_page_by_url()</code>)가 반환하는 값을 리스트형으로 모아서 callback 객체에게 인자로 전달합니다. <code>chord()</code>로 만든 Celery 작업 객체로 callback 객체를 전달할 때 인자를 지정하지 않아도 됩니다. 알아서 넣어 줍니다.</p>

<p>근데 이 코드엔 사소하다면 사소하고 심각하다면 심각한 문제가 있습니다. 작업들을 비동기로 수행하다보니 웹페이지 문자열이 우리가 원하는 순서대로 담겨져 <code>merge_text()</code>로 전달된다는 보장이 없습니다. 작업이 먼저 끝나는 순서대로 결과가 담기니 0 - 1 - 2 - 3 ... 순서가 될 지 9 - 4 - 7 - 1 순서가 될 지는 아무도 모릅니다.</p>

<p>여러 해결책이 있겠지만, 각 작업자마다 순번을 주고, <code>merge_text()</code>는 이 순번대로 문자열을 합치면 되겠네요.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">@app.task
def fetch_page_by_url(url, num):
    res = requests.get(url)

    if int(res.status_code / 100) == 2:
        return res.text, num

@app.task
def merge_text(texts):
    assert(isinstance(texts, MutableSequence))
    texts.sort(key=lambda x: x[1])
    return texts.join(&#39;&#39;)

tasks = []
for i in range(0, 10):
    tasks.append(
        fetch_page_by_url.s(
            &#39;http://localhost:8000/{}.html&#39;.format(i), i
        )
    )
</code></pre></div>
<p>각 <code>fetch_page_by_url()</code>에 두 번째 인자로 순번(<code>i</code>)을 전달하고, <code>fetch_page_by_url()</code>는 받은 순번을 웹페이지 문자열과 함께 그대로 반환합니다. <code>merge_text()</code>가 전달받은 <code>texts</code>엔 각 <code>fetch_page_by_url()</code> 결과가 <code>[(문자열, 0), (문자열, 3), ...]</code> 형태로 담깁니다. 그래서 각 항목의 두 번째(<code>[1]</code>) 값으로 정렬하고 나서 한 문자열로 합친 것입니다.</p>

<ul>
<li><a href="http://celery.readthedocs.org/en/latest/userguide/canvas.html#the-primitives">Canvas: Designing Workflows : The primitives</a></li>
<li><a href="http://celery.readthedocs.org/en/latest/userguide/tasks.html#avoid-launching-synchronous-subtasks">Tasks : Avoid launching synchronous subtasks</a></li>
</ul>

<hr>

<div class="footnotes">
<hr>
<ol>

<li id="fn1">
<p>대개는 <code>delay()</code>라는 메서드로 줄여서 수행합니다.&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>대개는 <code>s()</code>로 줄인 메서드 이름을 씁니다.&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

<li id="fn3">
<p><code>chain</code>과 <code>chord</code>는 함수처럼 생겼지만 클래스입니다.&nbsp;<a href="#fnref3" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page3">Older</a>
  
  
    
      <a class="pagination-item newer" href="/">Newer</a>
    
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-33535239-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-KS9HDB"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KS9HDB');</script>
<!-- End Google Tag Manager -->
 <!--[if lt IE 9]>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <![endif]-->
    <!--[if gte IE 9]><!-->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <!--<![endif]-->
    </body>
</html>
