<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <script src="//cdn.optimizely.com/js/3144930209.js"></script>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on iPhones and stuff-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="icon" type="image/png" href="http://blog.hannal.com/favicon.ico" />
  <link rel="alternate" type="application/rss+xml" title="Kay on the rails RSS Feed" href="http://blog.hannal.coom/feed.xml" />
  <title>
    
      Kay on the rails &middot; 
    
  </title>
  <meta property="og:title" content="Kay on the rails &middot; " />
  <meta property="og:site_name" content="Kay on the rails"/>
  <meta property="og:url" content="http://blog.hannal.com" />
  <meta property="fb:app_id" content="308847979152210" />
  <meta property="og:type" content="article" />

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  <!-- Icons -->
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">

  <style>
  .posts h2.post-title {
    font-size: 1.6em !important;
  }

  .post-parting-line {
    border-top: 7px solid #eee !important;
    border-bottom: 7px solid #fff !important;
  }
  </style>
</head>


  <body>
    <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ko_KR/sdk.js#xfbml=1&appId=308847979152210&version=v2.0";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Kay as known as Hannal walks on the rails
</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    <a class="sidebar-nav-item" href="/category/essay/">한날의 낙서</a>
    <a class="sidebar-nav-item" href="/category/kay-on-the-team/">팀과 함께하는 한날</a>
    <a class="sidebar-nav-item" href="/category/start-with-django-lectures/">Django 입문자용 강좌</a>
    <a class="sidebar-nav-item" href="/category/start-with-django-webframework/">Django 중급자용 강좌</a>
    <a class="sidebar-nav-item" href="/category/flaskon-startup-diary/">플라스콘 창업 일지</a>
    <a class="sidebar-nav-item" href="/category/devlife/">개발 생활</a>
    <a class="sidebar-nav-item" href="/category/game/">게임 생활</a>
  </nav>

  <nav class="sidebar-nav" style="margin-top: 1.2em;">
    <a class="sidebar-nav-item" href="/profile/">소개합니다</a>
    <a class="sidebar-nav-item" href="/fingers/">손 끝에 맺힌 글</a>
    <a class="sidebar-nav-item" href="/copyright/">저작권</a>

    
    <span class="sidebar-nav-item">Alpha v</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2017. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Kay on the rails</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h2 class="post-title">
      <a href="/2014/8/start_with_django_webframework_02/">
        2. 개발 환경 꾸리기
      </a>
    </h2>

    <span class="post-date">25 Aug 2014</span>

    <ul>
  <li><a href="http://blog.hannal.com/category/start-with-django-webframework/">날로 먹는 Django 웹프레임워크 강좌 목차</a></li>
  <li>마지막 갱신일시 : 2017년 1월 29일 18시 00분</li>
</ul>

<p>이번 2편에서는 Pystagram을 만드는 데 필요한 개발 도구를 설치하겠습니다. 저는 Mac OS를 쓰기 때문에 Mac OS 환경을 기준으로 설명하며, 윈도우나 리눅스 환경용 설명은 웹에 있는 관련 자료로 대신하겠습니다.</p>

<h3 id="1-python-설치">1. Python 설치</h3>

<h4 id="1-mac-os-linux">(1) Mac OS, Linux</h4>

<h5 id="python-설치">Python 설치</h5>

<p>Python은 현재 두 개 큰 버전이 배포되고 사용됩니다. 2 버전과 3 버전입니다. 우리가 사용할 Python 버전은 3.4 이상입니다. 터미널을 연 뒤에 다음 명령어를 입력해보세요. $는 입력하지 마시고요<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ python --version
</code></pre>
</div>

<p>아마도 <code class="highlighter-rouge">Python 버전</code> 형식인 문장이 출력될 겁니다. 대개는 버전이 2.7대입니다. 2버전대의 최신 버전은 <a href="https://www.python.org/download">Python 공식 웹사이트에서 내려받아 설치</a>하거나 패키지 관리 도구로 설치하면 됩니다. 패키지 관리 도구로 프로그램과 같은 패키지를 관리하면 편하니 패키지 관리 도구를 권합니다. Mac OS라면 <a href="http://brew.sh/">Homebrew</a>를 많이 씁니다. 저도 Homebrew로 설치하겠습니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ brew install python3
</code></pre>
</div>

<p>Homebrew가 설치되어 있지 않다면 <a href="http://brew.sh/#install">brew부터 설치</a>해야 하며, brew 설치할 때 xcode 관련 도구인 Command Line Tools가 요구되기도 합니다. 대개는 관련 과정이 함께 안내되는데, 실수로 그냥 넘어갔거나 안내되지 않았다면 다음 명령어로 Command Line Tools를 설치하면 됩니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ xcode-select --install
</code></pre>
</div>

<p>Debian 계열 Linux라면 운영체제에 내장된 apt-get을 씁니다. Redhat 계열 Linux는 yum을 사용합니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ apt-get install python3
</code></pre>
</div>

<p>그런데 아마 접근 권한 문제로 설치되지 않을 겁니다. 오류 내용을 잘 보면 <code class="highlighter-rouge">Permission denied</code> 문구가 포함되어 있지요. 이런 경우 <code class="highlighter-rouge">sudo</code> 명령어도 써야 합니다. sudo는 다른 이용자(대개는 최고권한자(superuser 또는 root))의 권한으로 sudo 명령어 뒤에 나오는 내용을 수행하는 프로그램입니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ sudo apt-get install python3
</code></pre>
</div>

<p>그러면 비밀번호를 묻는데, 시스템 관리자 권한이 있는 계정의 비밀번호를 입력합니다. Mac OS라면 대개는 현재 로그인한 자신의 계정이 이미 시스템 관리자 권한을 갖고 있으므로 자신의 계정 비밀번호를 입력하면 됩니다.</p>

<h4 id="2-windows">(2) Windows</h4>

<p>제가 Mac OS를 사용하다 보니 Windows 환경에서 Python을 설치하는 방법에 관해서는 설명하기 어렵습니다. 그래서 설치 관련 글을 소개하는 걸로 대신하겠습니다.</p>

<ul>
  <li><a href="http://goo.gl/v1ikhD">파이썬 윈도우 설치</a></li>
  <li><a href="http://docs.python-guide.org/en/latest/starting/install/win/">Installing Python on Windows</a></li>
</ul>

<h3 id="2-개발-환경-구축">2. 개발 환경 구축</h3>

<p>여기서부터는 Mac OS, Linux 구분을 하지 않습니다. 다만, Windows는 제가 실제 설치와 작동을 확인하기 어려우니 설치 관련 자료를 별첨하겠습니다.</p>

<h4 id="1-pip-설치">(1) pip 설치</h4>

<p>pip는 Python에 사용되는 각종 패키지<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>를 설치하거나 업그레이드, 삭제 등을 하는 관리 도구입니다. 이 도구를 설치하는 이유는 Django를 비롯하여 Python에 유용한 패키지를 쉽고 편하게 관리하기 위해서입니다.</p>

<p>설치는 간단합니다. pip를 설치해주는 스크립트인 <a href="https://bootstrap.pypa.io/get-pip.py">get-pip.py</a> 파일을 받아서<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup> 실행하면 됩니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ python3 get-pip.py
</code></pre>
</div>

<p>별문제 없이 설치가 끝날 겁니다. <code class="highlighter-rouge">OSError: [Errno 13] Permission denied:</code> 이런 식으로 오류가 발생하며 설치가 중단된다면 <code class="highlighter-rouge">sudo</code>를 이용하여 시스템 관리자 권한으로 설치하면 됩니다.</p>

<p>이외 다른 방법으로 pip를 설치하실 거라면 <a href="https://pip.pypa.io/en/latest/installing.html">pip installation</a> 문서를 참조하세요. pip는 Mac OS, Linux, 그리고 윈도우에서도 설치되고 작동합니다.</p>

<h4 id="2-virtualenv-설치">(2) virtualenv 설치</h4>

<p>virtualenv는 가상으로 Python 환경을 만드는 도구입니다. Virtual Environment를 줄인 이름이겠지요?!</p>

<p>실제 환경인 주 시스템(운영체제)에 패키지를 설치하면 패키지가 바뀔 때마다 그 패키지를 사용하는 프로젝트 모두가 영향을 받습니다. 예를 들어, Django 1.6 버전을 기반으로 Pystagram을 개발하였는데, 얼마 후 1.6버전과 호환성이 떨어지는 Django 1.7버전이 출시됐다고 가정하겠습니다. 만약 Django 1.7 버전을 설치한다면 Django 1.6 버전에서 잘 작동하던 Pystagram에 문제가 발생할 지도 모릅니다.</p>

<p>Pystagram은 Django 1.6 버전을 기반으로, Hannal 프로젝트는 Django 1.5 버전 기반으로, Kay 프로젝트는 Django 1.7 버전 기반으로 환경을 분리하면 되는데, 한 시스템에서 이런 환경을 가상으로 분리하여 편하게 관리하도록 도와주는 도구가 바로 virtualenv입니다. Python 패키지 뿐만 아니라 사용할 Python 버전도 가상 환경으로 분리할 수 있습니다. 한 시스템에 여러 Python 버전을 설치하고, 버전에 따라 사용할 Python을 프로젝트 마다 지정할 수 있는 것이죠.</p>

<p>가상 Python 환경을 만드는 도구는 몇 가지가 있는데, 우리는 Python 3에 내장된 virtualenv(venv)를 사용합니다. <code class="highlighter-rouge">python3 -m venv</code> 명령어를 실행해서 다음과 같은 사용법 안냇말이 나오면 Python 3에 내장된 venv를 사용할 수 있습니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ python3 -m venv                                               │~
usage: venv [-h] [--system-site-packages] [--symlinks | --copies] [--clear]                                    │~
            [--upgrade] [--without-pip] [--prompt PROMPT]                                                      │~
            ENV_DIR [ENV_DIR ...]                                                                              │~
venv: error: the following arguments are required: ENV_DIR
</code></pre>
</div>

<p>만약 <code class="highlighter-rouge">No module named venv</code> 문구가 있다면 따로 설치해야 합니다. Mac OS에선 <code class="highlighter-rouge">brew install pyenv</code>를 실행하면 되고, Debian 계열 Linux에선 <code class="highlighter-rouge">sudo apt-get install python3-venv</code>를 실행하면 됩니다.</p>

<h4 id="3-sqlite-설치">(3) SQLite 설치</h4>

<p>데이터를 저장하는 데 필요한 데이터베이스는 <a href="http://www.sqlite.org/">SQLite</a>를 사용할 겁니다. 실제 서비스를 운영하기엔 부족하지만, 공부하는 데엔 참 좋습니다.</p>

<p>Mac OS나 Linux 계열 운영체제엔 SQLite 3가 보통은 이미 설치되어 있습니다.</p>

<div class="language-sh highlighter-rouge"><pre class="highlight"><code><span class="gp">$ </span>sqlite3
SQLite version 3.8.5 2014-06-04 14:06:34
Enter <span class="s2">".help"</span> <span class="k">for </span>usage hints.
Connected to a transient <span class="k">in</span>-memory database.
Use <span class="s2">".open FILENAME"</span> to reopen on a persistent database.
sqlite&gt;
</code></pre>
</div>

<p>그래서 SQLite 3 설치를 신경써야 하는 경우는 흔하지 않으며, 여러분이 SQLite 3이 설치되어 있지 않아서 문제를 겪는 경우도 드뭅니다. 하지만 그 드문 일을 대비해 설치하는 과정을 다루겠습니다.</p>

<p>Mac OS에서는 Homebrew로 설치하거나 버전 업그레이드를 하면 편합니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ brew update
$ brew upgrade
$ brew install sqlite3
$ brew link --force sqlite
</code></pre>
</div>
<p>하지만 이미 <code class="highlighter-rouge">sqlite3</code>이 설치되어 있다는 경고가 표시되며 설치되지 않을 겁니다. 이미 설치되어 있을 테니까요.</p>

<p>Debian 계열 Linux라면 apt-get으로 설치하면 됩니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ apt-get install sqlite3 libsqlite3-dev
</code></pre>
</div>

<p><code class="highlighter-rouge">libsqlite3-dev</code>는 SQLite 3 개발용 라이브러리입니다.</p>

<p>그런데 패키지 관리 도구로 설치가 안 되거나 직접 소스를 직접 컴파일하여 설치하고 싶다면 <a href="http://sqlite.org/download.html">sqlite.org의 Download</a> 페이지에 가서  “Source Code” 영역에 있는 <code class="highlighter-rouge">sqlite-autoconf</code>로 이름이 시작하는 파일을 받습니다. 파일 확장자는 <code class="highlighter-rouge">tar.gz</code>입니다. 이 소스 파일을 다음과 같이 컴파일하여 설치하면 됩니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ ./configure --prefix=/usr/local
$ make
$ sudo make install
</code></pre>
</div>

<p>SQLite 3가 <code class="highlighter-rouge">/usr/local/</code> 에 설치되고, <code class="highlighter-rouge">/usr/local/bin/</code>에 <code class="highlighter-rouge">sqlite3</code> 파일이 생깁니다. 하지만 패키지 관리 도구로 설치되지 않을 정도로 오래된 운영체제라면 <strong>직접</strong> 소스 컴파일해서 프로그램을 설치하느니 운영체제를 더 최신 버전으로 업그레이드 하는 게 나을 것 같습니다. :)</p>

<p>Python으로 SQLite 3를 사용하는 데 필요한 인터페이스는 대개 Mac OS나 Linux에 기본 내장되어 있습니다. Python 쉘에서 간단히 확인할 수 있습니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>import sqlite3
</code></pre>
</div>

<h5 id="windows에-sqlite-3-설치">Windows에 SQLite 3 설치</h5>

<ul>
  <li><a href="http://goo.gl/buqvp3">윈도우 sqlite 설치</a></li>
</ul>

<h3 id="3-django-설치">3. Django 설치</h3>

<h4 id="가상-환경-생성과-진입">가상 환경 생성과 진입</h4>

<p>이제 드디어 Django를 설치할 차례입니다. virtualenv로 가상 환경을 만들고 그곳에 Django를 설치하겠습니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ python3 -m venv env_pystagram
</code></pre>
</div>

<p>python3에 내장된 <code class="highlighter-rouge">venv</code>를 이용하여 <code class="highlighter-rouge">env_pystagram</code>라 이름 붙인 가상 환경을 만드는 명령입니다. 잠깐 멈칫하다가 <code class="highlighter-rouge">env_pystagram</code> 이름으로 된 디렉터리가 만들어집니다. 이 디렉터리가 바로 Python 가상 환경입니다.</p>

<p>Python 가상 환경을 활성화하려면 Python 가상 환경 디렉터리 안에 있는 파일을 이용해야 합니다. Mac OS나 Linux 계열에선 다음 명령어를 실행합니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ source env_pystagram/bin/activate
</code></pre>
</div>

<p><code class="highlighter-rouge">env_pystagram</code> 디렉터리 안에 있는 <code class="highlighter-rouge">bin</code> 디렉터리에 <code class="highlighter-rouge">activate</code> 파일을 이용한 겁니다. Windows에선 다음 명령어를 실행합니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ env_pystagram\Scripts\activate.bat
</code></pre>
</div>

<p><code class="highlighter-rouge">env_pystagram</code> 디렉터리 안에 있는 <code class="highlighter-rouge">Scripts</code> 디렉터리의 <code class="highlighter-rouge">activate.bat</code> 파일을 실행한 겁니다.</p>

<p>가상 환경에 잘 진입하면 쉘 프롬프트에 가상 환경 이름이 덧붙어 표시됩니다.</p>

<p>가상 환경에서 빠져 나오려면 <code class="highlighter-rouge">deactivate</code> 명령어를 실행하세요. 그러면 쉘 프롬프트에 <code class="highlighter-rouge">(pystagram)</code> 부분이 표시되지 않는데, <code class="highlighter-rouge">pystagram</code>이라 이름 붙인 가상 환경에서 빠져 나와서 그렇습니다.</p>

<h4 id="django-설치">Django 설치</h4>

<p>Django를 pystagram 가상 환경에 설치하기 위해 다시 가상 환경을 활성화하고 <code class="highlighter-rouge">pip</code> 명령으로 django 최신 버전을 설치합니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>(env_pystagram)$ pip install django
</code></pre>
</div>

<p>주 시스템에 설치하지 않고 가상 환경에 설치하기 때문에 관리자 권한은 필요 없어서 <code class="highlighter-rouge">sudo</code>를 쓰지 않았습니다.</p>

<p>설치가 잘 됐는지 확인해 보겠습니다.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>(pystagram)$ python -c "import django; print(django.__file__)" 
</code></pre>
</div>

<p>화면에 Django가 설치된 경로가 표시됩니다. 경로를 잘 보면 Python 가상 환경의 하위 경로에 Django가 설치됐다는 걸 알 수 있습니다.</p>

<h3 id="4-편리한-도구-설치">4. 편리한 도구 설치</h3>

<p>Pystagram을 만드는 데 필요한 Python 패키지는 그때그때 설치하겠습니다. 대신 Pystagram을 편하게 만드는 데 좋은 도구는 먼저 소개하겠습니다. 사용 여부는 여러분 마음입니다. :)</p>

<h4 id="1-postman---rest-client">(1) Postman - REST Client</h4>

<p><a href="http://www.getpostman.com/">Postman - REST Client</a>는 HTTP 기반으로 동작하는 API를 편리하게 호출하는 클라이언트(client)입니다. 서버에 기능을 구현한 후 동작 여부를 확인하려면 클라이언트에서 접근할 수 있는 인터페이스(interface)를 만들어야 합니다. 이 클라이언트쪽 인터페이스를 만드는 것 자체가 귀찮기도 하지만, 오류를 확인하고 추적하는 디버깅(debuging) 환경이 미비하여 문제를 파악하기도 불편합니다. Postman은 개발에 용이한 클라이언트 인터페이스를 제공하는 도구입니다.</p>

<h4 id="2-편집기">(2) 편집기</h4>

<p>프로그래밍은 해본 적이 없고 정말 Python 등으로 Hello world만 출력해본 분이라면 코딩에 필요한 편집기를 아직 결정하지 못하셨을 겁니다. Django로 프로그래밍을 하는 데 필요한 전용 편집기는 따로 없습니다. 편집기는 다양하며 취향에 맞는 걸 쓰면 됩니다.</p>

<ul>
  <li>Atom (무료)</li>
  <li>Notepad (일명 메모장. 유료 운영체제에 기본 내장)</li>
  <li>PyCharm (무료, 유료)</li>
  <li>Sublime Text (유료)</li>
  <li>Vim (무료)</li>
</ul>

<p>저는 Sublime Text 2/3를 구입하여 사용하고 있으며, Vim도 많이 씁니다. 무료인데 꽤 잘 만들어졌고 빠르게 개선되고 있는 Atom도 좋습니다.</p>

<p>Apple Pages나 Microsoft Word 같은 도구는 코딩에 적합하지 않습니다. :)</p>

<h3 id="5-python">5. Python</h3>

<p>이 강좌는 Python 입문자를 대상으로 하지 않으므로 Python 문법 등에 대해서는 다루지 않습니다. 대신 Python 관련하여 몇 가지 규칙을 정하고, 여러분은 이 규칙을 따르시길 권합니다.</p>

<h4 id="1-들여쓰기">(1) 들여쓰기</h4>

<p>Python의 언어 문법은 코드를 들여 쓰는 규칙(indentation)을 엄격히 따릅니다. 같은 맥락에 있는 코드는 들여 쓰는 깊이가 같아야 합니다. 들여 쓰는 깊이는 탭(tab)으로 만드는데, 이 탭은 한 자리 공백(space) 문자로 표현하는 소프트 탭(soft tab) 방식과 자판에 있는 탭 키로 표현하는 하드 탭(hard tab) 방식이 있습니다.</p>

<p>저는 <a href="http://legacy.python.org/dev/peps/pep-0008/#indentation">스페이스 네 칸을 탭 한 칸으로 표현하는 소프트탭 방식</a>을 쓰겠습니다.</p>

<hr />

<p>이것으로 강좌 2편을 마칩니다. 분량이 적을 거라 예상했는데, 왜 설치하고 왜 그렇게 설치하는지 설명하려다 보니 예상보다 길게 썼네요.</p>

<p>3편에서는 Django로 프로젝트를 만들고 데이터베이스에 데이터도 넣어볼 겁니다. 그럼 3편에서 만나요.</p>

<p>아참. 9월 초까지 블로그를 분리하고 이전하느라 접속이 잘 안 될 수 있습니다. :)</p>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>$ 기호는 보통은 쉘 프롬프트(shell prompt)를 뜻합니다. 즉, $가 있다면 터미널을 열어서 쉘에서 실행한다는 의미입니다.&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>Python Package : 모듈은 함수나 변수, 클래스를 모아 놓은 파일이며, 패키지는 모듈을 묶어놓은 것이다. <a href="https://docs.python.org/2/tutorial/modules.html#packages">Python Modules - Packages</a> 참조.&nbsp;<a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>wget을 사용하면 터미널에서 파일을 간편하게 받습니다. <code class="highlighter-rouge">wget 주소(URL)</code> 라고 입력하면 끝이지요. wget은 brew나 apt-get으로 설치하면 되며, <a href="http://gnuwin32.sourceforge.net/packages/wget.htm">윈도우용 wget</a>도 있습니다.&nbsp;<a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>
  <hr class="post-parting-line" />
  
  <div class="post">
    <h2 class="post-title">
      <a href="/2014/8/start_with_django_webframework_01/">
        1. Pystagram 기획
      </a>
    </h2>

    <span class="post-date">18 Aug 2014</span>

    <ul>
  <li><a href="http://blog.hannal.com/category/start-with-django-webframework/">날로 먹는 Django 웹프레임워크 강좌 목차</a></li>
  <li>마지막 갱신일시 : 2014년 08월 16일 17시 40분</li>
</ul>

<p>앞으로 우리는 Django를 이용해 <a href="http://www.instagram.com">Instagram</a>과 비슷한 서비스를 만들 겁니다. 비슷한 서비스 중에는 <a href="http://www.kakao.com/story?locale=ko">카카오 스토리</a>가 있지요. Django를 활용하여 만드는 것이지만 이름으로 조합하기 까다로우니 Python을 조합하여 Pystagram이라 이름을 짓도록 하겠습니다.</p>

<p>자, 이제 우리가 만들 것을 기획해 볼까요?</p>

<h3 id="1-개요">1. 개요</h3>

<p>Instagram은 친구 및 가족들과 일상을 사진이나 동영상으로 찍어서 필터를 적용해 빠르고, 멋지고, 재미있게 공유할 수 있는 앱이라고 소개되어 있습니다. Pystagram은 Instagram을 기본으로 삼되 좀 더 단순하게 만들 겁니다. 그리고 쉽고 편하게 올리는 걸 최우선 정책 요소로 삼겠습니다. 이용자는 사진만 올릴 수 있고, 몇 가지 필터를 적용할 수 있습니다. 사진을 다루고 나면 동영상은 여러분이 직접 다룰 수 있게 될 겁니다.</p>

<h3 id="2-pystagram-기능">2. Pystagram 기능</h3>

<h4 id="1-사진">(1) 사진</h4>

<p>사진은 Pystagram에서 이용자가 활동하고 다른 사람과 교류하는 핵심 매체입니다. 서비스를 만드는 데 들어간 이미지를 제외한 모든 사진은 이용자가 올린 것이고, 이 사진에 댓글을 달거나 좋다는 표시를 남기지요. 이용자가 사진 관련해서 하는 행동을 기반으로 기능을 정리해 보겠습니다.</p>

<ul>
  <li>사진 올리기
    <ul>
      <li>필터 적용</li>
      <li>미리보기 이미지(thumbnail image)</li>
      <li>사진 자르기, 크기 조절</li>
    </ul>
  </li>
  <li>사진 보기
    <ul>
      <li>좋아요 표시 남기기</li>
      <li>댓글 남기기, 지우기</li>
    </ul>
  </li>
  <li>사진 삭제</li>
  <li>사람 태그 달기</li>
</ul>

<h5 id="사진-올리기">사진 올리기</h5>

<p><img src="http://blog.hannal.com/assets/uploads/2014/08/01-instagram_04.png" alt="인스타그램 사진 올리기 화면" /></p>

<p>가장 기본 행동이죠. 사진은 오직 이용자 자신의 공간에만 올리며, 로그인한 모든 이용자가 사용하는 기능입니다.</p>

<p>자신의 공간에만 올린다는 건, 서비스 안에서 사진을 소유한 사람이 누구이며, 그 권한 범위가 어디까지인지 정의한 것입니다. 다른 이용자의 공간에 사진을 올리거나 공용 공간에 사진을 올리지 않는다는 것이지요. 로그인한 모든 이용자가 사용하는 기능이란, 이용자는 서비스를 이용하려면 가입하고 로그인해야 대상을 뜻하며, 이용자라면 누구나 공통되게 사진을 올릴 수 있다는 의미입니다.</p>

<ul>
  <li>로그인한 이용자만 사진을 올린다.</li>
  <li>사진은 이용자의 개인 공간에 올린다.</li>
</ul>

<p>이용자는 사진을 쉽고 편하게 보정해 올릴 수 있습니다. 쉽고 편하게 하는 것이 중요합니다. 그래서 여러 보정 요소와 수치가 미리 조정된(preset) 필터를 골라서 적용하며, 이용자가 직접 정교하게 보정 요소를 조정하지 못합니다. 필터는 한 번에 하나만 고르도록 하겠습니다. 여러 가지를 중첩하면 사진이 지저분해지기 일쑤이고, 지저분해진 상태를 해제하려고 이전 단계로 돌아가는 식으로 편집 단계나 기능이 들어가면 쉽고 편하게 하겠다는 목표를 잃을 것이기 때문이지요. 그리고 이 목표를 위해 이용자는 사진을 올리는 과정 중에만 필터를 적용하며, 사진을 올리고 나면 더는 편집할 수 없습니다.</p>

<ul>
  <li>미리 만들어진 필터를 제공하고, 이용자는 필터를 선택해서 사진을 보정한다.</li>
  <li>사진을 올릴 때에만 보정하며, 이미 올라간 사진은 보정할 수 없다.</li>
</ul>

<p>Instagram은 가로(width) 640픽셀, 세로(height) 640픽셀짜리 정사각형 사진만 표시됩니다. 그런데 사진은 대개 직사각형이므로 정사각형 모양으로 잘라야 하는데, Instagram은 사진을 편집하는 과정 중에 정사각형 틀에 맞추어 사진을 잘라내도록 합니다.</p>

<p>우리는 좀 더 단순하게 할 예정입니다. 사진을 축소한 다음에 정사각형으로 잘라내는 거죠. 어쨌든 Pystagram도 정사각형으로 사진을 잘라냅시다. 크기는 Instagram과 같게 640x640으로 하겠습니다. 그런데 이용자가 가로나 세로 길이 중 어느 하나라도 640픽셀보다 작은 사진을 올리면 어떻게 할까요? 이런 사진을 받아들인다면 640픽셀로 사진을 늘려야 하는데, 사진을 늘리면 픽셀이 뭉개져서 썩 예쁘지 않습니다. 예쁘지 않은 사진을 올려서 손해 보는 건 엄밀히 말해 이용자이지만, 물 관리(?) 차원에서 품질이 너무 떨어지는 사진은 걸러내고자 합니다. 멋진 사진은 아니더라도 크기(길이)만은 최소한 지켜야 하는 품질을 제한하는 거죠. 그래서 가로, 세로 중 어느 한 변이라도 640픽셀보다 짧은 사진은 등록할 수 없도록 하겠습니다.</p>

<p>이외 더 필요한 기능은 뭐가 있을까요? 미리보기 이미지(Thumbnail image)를 만들어야겠네요. 굉장히 자주 표시(호출)될 테니 최종 결과물 사진이 저장될 때마다 미리보기 이미지도 생성해야 합니다.</p>

<ul>
  <li>사진은 가로나 세로 길이 모두 640픽셀 이상이어야 한다.</li>
  <li>최종 결과물은 640x640 정사각형으로 표시하며, 이 크기에 맞게 비율 축소/확대하거나 자른다. 이용자가 표현할 영역을 지정할 순 없다.</li>
  <li>최종 결과물 사진을 저장할 때 미리보기 이미지(thumbnail image)를 만들어 저장한다.</li>
</ul>

<p>자, 마지막으로 사진을 올릴 때 서버에 접근할 URL(Uniform Resource Locator)을 정하겠습니다. 웹과는 달리 모바일에서는 이용자가 사진을 올릴 URL을 알 필요가 없습니다. 입력하기 편하든 어렵든 상관없지요. 대신 우리는 URL을 보면 이게 어떤 작동을 하고 어떤 클래스나 함수와 관련되는지 바로 알아보기 편한 게 좋을 것 같습니다. 주소 그 자체가 자원이나 행동을 표현하는 거지요. 나중에 주소는 다시 다듬기로 하고 일단은 다음가 같은 주소로 접근해서 사진을 올리도록 하겠습니다.</p>

<p>protocol://domain/photos/upload/</p>

<p>간단히 줄여서 /photos/upload/ 입니다. 이 주소는 나중에 /photos/ 로 바꿀 겁니다. 걱정 마세요. Django에서 URL을 바꾸고 그 URL에 관련된 기능을 연결하는 건 아주 쉽고 간단합니다. 이 주소 하나로 사진 올리는 인터페이스와 사진을 실제로 받아서 처리하는 기능 모두 처리할 겁니다.</p>

<h5 id="사진-보기">사진 보기</h5>

<p><img src="http://blog.hannal.com/assets/uploads/2014/08/01-instagram_05.png" alt="" /></p>

<p>사진 올리기만큼이나 기본 기능입니다. Pystagram에서 사진을 보는 경로는 크게 두 가지입니다. 하나는 목록으로 여러 사진을 보는 것이고, 다른 하나는 개별 사진을 보는 것입니다. Instagram은 모바일이 기본 영역이고 모바일에서 돌아가는 서비스 내 사진을 인터넷에서 접근하여 보는 것이 보조 기능이어서 개별 사진을 보는 것도 모바일에서 보는 것과 웹에서 보는 것을 구분했습니다. 대신 웹에서 여러 사진을 목록으로 볼 수 없습니다. 그런 페이지를 제공하지 않거든요. 그리고 모바일에서는 개별로 보든 목록 중에 보든 같은 화면인데, 우리도 그렇게 하겠습니다.</p>

<ul>
  <li>사진은 목록 형식으로 나열하거나 개별 사진만 따로 본다.</li>
  <li>모바일에서는 목록으로 보든 개별로 보든 동일한 화면 디자인을 따른다.</li>
  <li>웹에 개별 사진 단위로 게재(공유)할 수 있으며, 별도 화면 디자인을 따른다.</li>
  <li>웹에서는 개별 사진만 볼 수 있다.</li>
</ul>

<p>각 사진에 표시할 정보를 살펴봅시다. 그다지 많지 않습니다. 먼저 사진을 올릴 때 발생하는 정보로는 최종 결과물 사진, 올린 사람, 작성일시, 사진에 넣은 본문 정도입니다. 사진에 관련된 사람이 누구인지 태그를 달 수도 있는데, 이 태그 거는 건 손도 많이 가고 번거로우니 사진을 편집하고 올리는 과정에서는 빼겠습니다. 쉽고 편하게, 쉽고 편하게. ^^</p>

<p>이미 올라간 사진에 이용자가 추가 행동을 하고, 이 내용도 화면에 표시돼야 합니다. 누가 사진에 남겨진 하트(좋아요) 표식을 남겼는지, 댓글은 뭐가 있으며, 관련된 사람으로 태그 걸린 사람은 누구인지, 그리고 이외 행동을 선택하는 버튼도 필요하고요. Instagram은 관련된 위치도 지정할 수 있는데, 이 기능은 일단 빼겠습니다.</p>

<p>댓글도 단순하게 가겠습니다. 작성자와 댓글 본문, 작성일시. 댓글 작성자는 자신의 댓글에 한하여, 댓글이 달린 사진의 소유자는 사진에 달린 댓글에 한하여 댓글을 지우는 삭제 버튼이 출력돼야 합니다. 그리고 댓글에 답글을 달면 답글을 받은 사람에게 알려주면 좋겠네요.</p>

<ul>
  <li>사진을 올릴 때 생성된 정보 : 최종결과물 사진, 작성자, 작성일시, 본문</li>
  <li>사진에 추가되는 정보 : 좋아요 버튼, 좋아요 표시 남긴 사람, 댓글, 태그 걸린 사람
    <ul>
      <li>댓글 정보 : 작성자, 댓글 본문, 작성일시</li>
      <li>댓글 관련 행동 : 삭제 버튼, 사용자 지정해서 댓글 달기</li>
    </ul>
  </li>
</ul>

<p>기본 기획은 이 정도로 하고, 필요한 기능이 있으면 나중에 따로 다루도록 하겠습니다. ^^</p>

<p>이제 사진 관련 URL을 정하겠습니다. 사진을 목록으로 보는 상황은 따로 기획하기로 하고, 개별 사진을 보고, 그 사진에 댓글을 달거나 좋아요를 누르는 행동을 하는 URL부터 정하지요.</p>

<p>개별 사진을 보는 건 /photos/<사진 ID="">/로 하겠습니다. 사진 ID 양옆에 있는 꺾쇠는 가변하는 값을 뜻합니다. 사진 ID가 1일 수도 있고 2일 수도 있으니까요. 사진에 좋아요를 누르는 건 어떻게 할까요? /like/<사진 ID="">/ 라고 해도 나쁘지 않지만, /like/ 문자열 뒤에 숫자만 있으면 이게 사진 ID를 뜻하는 것인지 좋아요 행위 자체를 기록한 좋아요 ID인지 잘 구분되지 않습니다. 우리는 특정 사진(/photos/<사진 ID="">/)에 좋아요 표시를(like) 남기는 것이니 /photos/<사진 ID="">/like/ 으로 좋아요 행위를 일으키는 URL을 하도록 하겠습니다. 행위나 자원을 나타내는 문자열이 있고, 그 문자열의 대상이 되는 값(ID)를 적는 구조이지요.</사진></사진></사진></사진></p>

<p>댓글도 마찬가지 규칙을 따르겠습니다. 댓글은 특정 사진에 다는 것이니까 /photos/<사진 ID="">/comment/ 로 하겠습니다. 특정 댓글을 지우려면 어떤 댓글인지 알아야겠지요? 앞서 정한 규칙에 따라 /photos/<사진 ID="">/comment/<댓글 ID="">/delete/ 로 하겠습니다. /comment/<댓글 ID="">/delete/ 로 해도 별 상관없습니다. 이후 강좌에서 이와 관련된 내용을 다루겠습니다.</댓글></댓글></사진></사진></p>

<p>사진에 달린 댓글은 어떻게 가져와야 할까요? /photos/<사진 ID="">/comment/ 이 URL은 특정 댓글을 지칭하는 데 사용하는 주소 규칙입니다. 사진에 달린 댓글은 comment를 복수형으로 취해 /photos/<사진 ID="">/comments/ 로 하겠습니다. s 한 글자 차이라서 구분이 잘 안 간다고요? 일리 있는 지적입니다. 그럼 눈에 확 들어오게 /photos/<사진 ID="">/get_comments/ 라고 하겠습니다. 일단은요.</사진></사진></사진></p>

<p>태그도 좋아요나 댓글과 별다를 바 없습니다. /photos/<사진 ID="">/tag/ 라고 하겠습니다.</사진></p>

<p>개별 사진과 관련된 URL을 정리해 보겠습니다.</p>

<ul>
  <li>개별 사진 보기 : /photos/<사진 ID="">/</사진></li>
  <li>사진에 좋아요 누르기 : /photos/<사진 ID="">/like/</사진></li>
  <li>사진에 댓글 달기 : /photos/<사진 ID="">/comment/
</사진>    <ul>
      <li>사진에 달린 댓글 가져오기 : /photos/<사진 ID="">/get_comments/</사진></li>
      <li>사진에 달린 댓글 지우기 : /photos/<사진 ID="">/comment/<댓글 ID="">/delete/</댓글></사진></li>
    </ul>
  </li>
  <li>사진에 태그 달기 : /photos/<사진 ID="">/tag/</사진></li>
</ul>

<h5 id="여러-사진-보기">여러 사진 보기</h5>

<p><img src="http://blog.hannal.com/assets/uploads/2014/08/01-instagram_01.png" alt="" /></p>

<p>사진을 여러 개 나열해서 보는 상황은 어떠한 경우일까요? 우선 이용자가 자신이 올린 사진들을 보는 경우가 있습니다. 내가 구독(following)하는 이용자들이 올린 사진을 보는 경우도 있고, 사람이나 기계가 추려낸 사진들, 가령 인기 사진들도 여러 사진을 보는 경우입니다. 더 다양한 경우가 있겠지만 우리는 이 세 경우만 만들도록 하겠습니다.</p>

<p>여러 사진을 보는 이 세 페이지는 오직 모바일에서만 이용할 수 있습니다. 그리고 모바일에서는 개별 사진을 따로 보는 화면 디자인이나 목록으로 나열된 개별 사진의 화면 디자인을 굳이 구분할 필요는 없습니다. 개별 사진 영역을 반복 출력하면 되니까요. 결국 출력되는 사진만 다를 뿐, 화면 디자인 요소는 이 세 페이지가 같습니다. 그렇다면 따로 화면 디자인을 할 필요가 없겠군요. 사진 보기 기획할 때 다 했으니까요. ^^</p>

<p>그럼 각 페이지 별 기획을 하겠습니다. 먼저 내가 구독(following)하고 있는 이용자들이 올린 사진을 보는 페이지부터 볼까요. 페이스북이나 트위터를 이용하신다면 타임라인(timeline)이라는 페이지나 기능에 익숙하실 겁니다. 자신의 글이나 사진을 포함해서 친구, 혹은 나와 관련된 컨텐츠를 시간 역순으로 나열하는 컨텐츠 연대표이죠.</p>

<p>이용자의 타임라인은 모든 이용자가 이용하는 기능이지만 이용자마다 표시되는 내용이 다른 공간입니다. 누구나 쓰는 공통 기능이며 다른 이용자가 내 타인라인을 볼 수 없으므로 굳이 타임라인 페이지를 URL로 구분할 필요는 없습니다. 그래서 /timeline/이라는 URL을 쓰겠습니다. 타임라인에는 어떤 정보를 표시하면 좋을까요? 자신이 올린 사진, 구독하는(following) 이용자의 사진, 나를 태그한 사진, 나를 언급한 댓글이 있는 사진을 가져와서 출력하면 얼추 그럴싸한 타임라인이 될 것 같습니다. 자세한 건 이 기능을 구현할 때 다루겠습니다.</p>

<p>이번엔 선정된 사진을 보는 곳. 뭘 기준으로 선정할까요? 무난하게 정해진 시간 동안 인기를 끈 사진을 가져오는 인기 사진을 가져오도록 하겠습니다. 주소는 모든 이용자가 동일한 내용을 보는 공동 구역이니 그에 어울리는 URL로 정해야겠네요. /popular/로 하겠습니다.</p>

<p>마지막으로 이용자가 자신이 올린 사진들을 보는 건 이용자 프로필 페이지에서 다루겠습니다. URL만 먼저 정하자면, /users/<이용자 ID="">/ 로 하겠습니다.</이용자></p>

<p>그럼 여러 사진을 보는 페이지와 관련된 URL을 정리해 보지요.</p>

<ul>
  <li>인기 사진 : /popular/</li>
  <li>이용자 개별 타임라인 : /timeline/</li>
  <li>특정 이용자가 올린 사진 : /users/<이용자 ID="">/</이용자></li>
</ul>

<h5 id="사진-삭제">사진 삭제</h5>

<p>사진 삭제는 간단합니다. 자신의 사진에 한해서 삭제하며, 개별 사진 영역에서 사진 삭제 버튼을 눌러서 지우면 됩니다. 지울 때 정말 지울 건지 한 번 더 물어보면 좋겠고요.</p>

<p>사진을 지우는 URL은 사진에 좋아요 표시를 남기거나 댓글을 남기는 규칙을 따르면 됩니다.</p>

<p>/photos/<사진 ID="">/delete/</사진></p>

<p>사진을 지우면 사진 파일도 지우고, 사진에 달린 활동들도 지우도록 하겠습니다.</p>

<h4 id="2-이용자">(2) 이용자</h4>

<p>이용자 관련 기능은 그다지 많진 않습니다.</p>

<ul>
  <li>회원 가입과 탈퇴</li>
  <li>로그인, 로그아웃</li>
  <li>비밀번호 찾기</li>
  <li>프로필 보기</li>
  <li>구독하기 (팔로잉(following) 기능)</li>
</ul>

<h5 id="회원-가입">회원 가입</h5>

<p>Instagram엔 직접 가입하는 방법과 페이스북으로 연결하여 가입하는 방법으로 회원 가입합니다. Pystagram은 ID와 비밀번호를 입력하여 직접 가입하는 방법을 기본으로 하겠습니다. 페이스북으로 연결하여 가입하는 기능은 직접 구현하진 않고 원리나 방식만 설명할 예정입니다.</p>

<p>회원 가입에 필요한 정보는 간단하게 받습니다. 사용할 ID, 비밀번호, 그리고 전자우편 주소. 그외 정보는 가입한 후에 언제든지 입력하도록 합니다. 다만 봇(bot)으로 계정을 막 생성하려는 나쁜 사람도 있으니 <a href="http://ko.wikipedia.org/wiki/CAPTCHA">캡챠(Captcha)</a> 기능을 구현할 필요는 있어 보입니다. 이용자가 회원 가입에 필요한 정보를 제출하면 전자우편 주소가 실제로 존재하는지 확인도 해보겠습니다. 가입 확인 전자우편을 보내는 거죠. 전자우편 주소 확인을 받지 않은 이용자는 로그인만 할 수 있고 나머지 기능은 사용할 수 없도록 권한을 제한합니다.</p>

<p>회원 가입 URL은 /accounts/registration/ 을 쓰도록 하겠습니다. 좀 긴데, 의미 전달성이 좋고 이용자가 저 URL을 인지할 일이 없는 데다 Django에서 따로 설정 안 하면 쓰게 되는 기본 주소라서 이 주소로 선택했습니다. ^^</p>

<h5 id="로그인-로그아웃">로그인, 로그아웃</h5>

<p>특별한 건 없습니다. 이용자가 입력한 아이디와 비밀번호로 로그인을 하고, 로그인한 이용자에 한하여 로그아웃을 합니다.</p>

<p>URL은 무난하게 /accounts/login/ 과 /accounts/logout/ 을 쓰도록 하겠습니다. 회원 가입 URL과 관련지은 주소이지요.</p>

<h5 id="비밀번호-찾기">비밀번호 찾기</h5>

<p>이 기능은 여러분이 직접 구현하셔야 합니다. :) 전자우편 주소 확인하는 기능을 활용하면 아주 간단하게 구현하실 수 있습니다.</p>

<h5 id="프로필-보기">프로필 보기</h5>

<p>프로필 페이지는 각 이용자의 간단한 소개와 그 이용자가 올린 사진을 나열해 보여주는 곳입니다. 특정 이용자가 올린 사진, 또는 자신이 올린 사진만 보는 곳이기도 하지요. 주소는 앞서 정한 /users/<이용자 ID="">/ 입니다.</이용자></p>

<p>프로필 페이지에서 간단한 소개 영역에 표시할 정보는 많지 않습니다. 이용자가 입력한 정보, 그리고 이용자가 서비스를 이용하며 발생시킨 정보 정도네요.</p>

<p>이용자가 입력한 정보 중 겉으로 드러낼 만한 정보는 이용자 ID와 이용자 프로필 사진 정도입니다.</p>

<p>이용자가 서비스를 이용하여 발생한 정보는 이용자가 구독하는(following) 이용자들, 이용자를 구독하는 이용자들(followers), 그리고 이용자가 올린 사진이 있습니다. 이용자가 구독하는 팔로잉 페이지는 /users/<이용자 ID="">/following/, 이용자를 구독하는 팔로워 페이지는 /users/<이용자 ID="">/followers/ 로 URL을 정하겠습니다. 이용자가 올린 사진은 이용자 프로필 페이지에 바로 나열하면 되고요. 하지만 웹에서는 사진을 나열해 표시하지 않기로 했으니 이용자가 올린 사진 중 하나를 무작위로 선택해서 표시하도록 하겠습니다.</이용자></이용자></p>

<ul>
  <li>간단한 소개 정보
    <ul>
      <li>이용자 프로필 사진</li>
      <li>이용자 ID</li>
    </ul>
  </li>
  <li>이용자가 사진
    <ul>
      <li>시간 역순으로 나열. 무한 스크롤 방식.</li>
      <li>웹에서는 이용자가 올린 사진 중 하나를 무작위로 선택해서 표시.</li>
    </ul>
  </li>
  <li>팔로잉
    <ul>
      <li>팔로잉 수</li>
      <li>URL : /users/<이용자 ID="">/following/</이용자></li>
      <li>누르면 하위 페이지(팔로잉 페이지)로 이동</li>
      <li>각 이용자의 프로필 사진과 해당 이용자의 프로필 페이지 이동 UI(링크)</li>
    </ul>
  </li>
  <li>팔로워
    <ul>
      <li>팔로워 수</li>
      <li>URL : /users/<이용자 ID="">/followers/</이용자></li>
      <li>이외 내용은 팔로잉과 동일</li>
    </ul>
  </li>
</ul>

<h5 id="구독하기-following">구독하기 (following)</h5>

<p>구독 기능은 구독 대상 이용자가 올리는 사진을 자신의 타임라인에서 편하게 보도록 합니다. 쌍방이 관계를 맺어야 하는 친구 관계와는 달리 구독자가 구독 대상을 구독하면 그만입니다. URL은 /users/<이용자 ID="">/follow/ 로 하겠습니다. 구독과 구독 해제를 작동시키는 URL을 나눌 필요는 없습니다. 구독하고 있지 않은 상태에서 구독 기능을 호출하면 구독 상태로 바꾸고, 구독 중인 상태에서 또 호출하면 구독 상태를 해제하면 되니까요.</이용자></p>

<h4 id="3-기능-총-정리">(3) 기능 총 정리</h4>

<p>지금까지 기획한 기능을 총 정리해보겠습니다.</p>

<ul>
  <li>사진
    <ul>
      <li>사진 올리기
        <ul>
          <li>필터 적용</li>
          <li>미리보기 이미지(thumbnail image)</li>
          <li>사진 자르기, 크기 조절</li>
        </ul>
      </li>
      <li>사진 보기
        <ul>
          <li>좋아요 표시 남기기</li>
          <li>댓글 남기기, 지우기</li>
        </ul>
      </li>
      <li>사진 삭제</li>
      <li>사람 태그 달기</li>
    </ul>
  </li>
  <li>이용자/회원
    <ul>
      <li>회원 가입과 탈퇴</li>
      <li>로그인, 로그아웃</li>
      <li>비밀번호 찾기</li>
      <li>프로필 보기
        <ul>
          <li>간단한 소개</li>
          <li>팔로잉, 팔로워</li>
          <li>이용자가 올린 사진</li>
        </ul>
      </li>
      <li>구독하기 (팔로잉(following) 기능)</li>
    </ul>
  </li>
  <li>사진 모아보기
    <ul>
      <li>타임라인 : 친구 사진들 보기</li>
      <li>인기 사진들 보기</li>
      <li>특정 이용자의 사진 보기 =&gt; 프로필 보기</li>
    </ul>
  </li>
</ul>

<p>큼직하게 묶어서 정리했는데 생각보다 많네요. 하지만 Django가 제공하는 기능을 쓰면 무척 쉽게 구현할 수 있습니다.</p>

<h4 id="이외">이외</h4>

<p>이외에 필요한 페이지나 기능이 많이 남았습니다. 몇 가지만 이곳에 정리하고, 나머지는 각 기능을 구현하면서 그때 그때 만들겠습니다.</p>

<ul>
  <li>로그아웃 상태에서 접속한 첫 화면</li>
  <li>로그인 실패</li>
  <li>없는 페이지에 접속했을 때 안내하는 페이지 (일명 404 페이지)</li>
  <li>허용하지 않는 페이지에 접속한 경우 처리
    <ul>
      <li>기획 정책 상 허용하지 않는 경우</li>
      <li>접근 권한이 없는 경우</li>
    </ul>
  </li>
  <li>오류가 발생했을 때 안내하는 페이지</li>
  <li>관리자 영역</li>
  <li>존재하는 ID나 전자우편 주소인지 검사</li>
</ul>

<h3 id="3-페이지-구성">3. 페이지 구성</h3>

<p>정리한 기능으로 페이지(scene)를 정리해 보겠습니다.</p>

<p><img src="http://blog.hannal.com/assets/uploads/2014/08/01-Scene_flow.png" alt="페이지 흐름 및 연결도" /></p>

<p>둥근 모서리 사각형은 개별 페이지를 뜻합니다. 이 중에서 파란 바탕색이 적용된 사각형은 상위 페이지입니다. Instagram 모바일 앱으로 예를 들면, 앱 최하단에 있는 버튼들이 이 상위 페이지에 연결된 것인데, 페이지 안내(navigation) UI 등으로 접근하는 페이지이지요. 흰 바탕인 사각형은 이러한 상위 페이지에 속해있는 하위 페이지입니다.</p>

<p>직각 모서리 사각형은 기능을 뜻합니다. 기능 중에는 페이지로 연결되기도 하는데, 편의상 기능으로만 표시했습니다. 기능 중 왼쪽에 있는 것은 자신의 영역에서 실행하는 기능이며, 오른쪽은 다른 이용자의 영역에서 혹은 다른 이용자가 내 영역에서 실행하는 기능입니다.</p>

<p>펼쳐 놓으니 뭔가 많아 보이지만, 실제로는 페이지 이동이나 기능 사용이 대부분 한두 단계 안에서 이뤄집니다. 이런 간단명료한 흐름이 Instagram의 매력이고, Pystagram도 그런 매력을 따릅니다. 고민 많이 했을 Instagram 개발자의 노고에 박수를 보내 봅니다.</p>

<hr />

<p>이것으로 강좌 첫 회를 마칩니다. 2회에선 Django도 설치하고, 개발 환경을 꾸려볼 겁니다. 내용이 그다지 많진 않을 겁니다. 그럼 강좌 2회에서 뵙겠습니다.</p>

  </div>
  <hr class="post-parting-line" />
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page16">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page14">Newer</a>
    
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-33535239-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-KS9HDB"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KS9HDB');</script>
<!-- End Google Tag Manager -->
 <!--[if lt IE 9]>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <![endif]-->
    <!--[if gte IE 9]><!-->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <!--<![endif]-->
    </body>
</html>
