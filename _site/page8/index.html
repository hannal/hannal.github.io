<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <script src="//cdn.optimizely.com/js/3144930209.js"></script>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on iPhones and stuff-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="icon" type="image/png" href="http://blog.hannal.com/favicon.ico" />
  <link rel="alternate" type="application/rss+xml" title="Kay on the rails RSS Feed" href="http://blog.hannal.coom/feed.xml" />
  <title>
    
      Kay on the rails &middot; 
    
  </title>
  <meta property="og:title" content="Kay on the rails &middot; " />
  <meta property="og:site_name" content="Kay on the rails"/>
  <meta property="og:url" content="http://blog.hannal.com" />
  <meta property="fb:app_id" content="308847979152210" />
  <meta property="og:type" content="article" />

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  <!-- Icons -->
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>
    <div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/ko_KR/sdk.js#xfbml=1&appId=308847979152210&version=v2.0";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>
<!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>Kay as known as Hannal walks on the rails
</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    <a class="sidebar-nav-item" href="/category/essay/">한날의 낙서</a>
    <a class="sidebar-nav-item" href="/category/kay-on-the-team/">팀과 함께하는 한날</a>
    <a class="sidebar-nav-item" href="/category/start-with-django-lectures/">Django 입문자용 강좌</a>
    <a class="sidebar-nav-item" href="/category/start-with-django-webframework/">Django 중급자용 강좌</a>
    <a class="sidebar-nav-item" href="/category/flaskon-startup-diary/">플라스콘 창업 일지</a>
    <a class="sidebar-nav-item" href="/category/devlife/">개발 생활</a>
    <a class="sidebar-nav-item" href="/category/game/">게임 생활</a>
  </nav>

  <nav class="sidebar-nav" style="margin-top: 1.2em;">
    <a class="sidebar-nav-item" href="/profile/">소개합니다</a>
    <a class="sidebar-nav-item" href="/fingers/">손 끝에 맺힌 글</a>
    <a class="sidebar-nav-item" href="/copyright/">저작권</a>

    
    <span class="sidebar-nav-item">Alpha v</span>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2016. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="/" title="Home">Kay on the rails</a>
            <small></small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2015/03/devlife-s1-03/">
        개발 생활 - 3
      </a>
    </h1>

    <span class="post-date">04 Mar 2015</span>

    <ol>
<li><a href="http://blog.hannal.com/2015/02/devlife-s1-01/">개발 생활 - 1</a> : PDF 문서 생성 서버</li>
<li><a href="http://blog.hannal.com/2015/02/devlife-s1-02/">개발 생활 - 2</a> : 연산된 데이터 수집 작업자</li>
<li><a href="http://blog.hannal.com/2015/03/devlife-s1-03/"><code>개발 생활 - 3</code></a> : 전자우편 알림 서버</li>
<li><a href="http://blog.hannal.com/2015/03/devlife-s1-04/">개발 생활 - 4</a> : Python과 Django 강의</li>
<li><a href="http://blog.hannal.com/2015/03/devlife-s1-05/">개발 생활 - 5</a> : 공부 자료</li>
<li><a href="http://blog.hannal.com/2015/03/devlife-s1-06/">개발 생활 - 6</a> : 앞으로 계획</li>
</ol>

<h3>2. 개발 프로젝트</h3>

<h4>2-3. 전자우편 알림 서버</h4>

<h5>개요</h5>

<p>전자우편 알림 서버는 특정 사건(event)이 발생하면 관련된 사람에게 그 사건에 대해 알리는 역할을 한다. 가령, K와 C영업인이 한날이라는 고객을 담당하고 있는데, C담당자가 고객과 영업 관련 일정을 잡을 경우, K담당자에게도 이에 대한 내용을 전자우편으로 안내하는 것이다.</p>

<ul>
<li>요구사항

<ol>
<li>사건이나 상황(event)이 발생하면, 이와 관련된 담당자나 팀에 즉시 전자우편으로 그 내용을 보낸다.</li>
<li>비밀번호 찾기 등 고객 홈페이지에서 발생하는 안내나 통지 행위도 처리한다.</li>
<li>여러 상황에 처한 고객에게 상황에 맞는 전자우편을 자동으로 보낸다.

<ul>
<li>예) 특정 기간 이상 접속하지 않은 고객에게 서비스 이용 안내와 매물을 추천</li>
</ul></li>
</ol></li>
<li>내가 정한 추가 목표치

<ul>
<li>Python 3로 작성한다.</li>
<li>프로그래밍 언어나 라이브러리, 프레임워크를 이전(migration)할 가능성을 염두에 두고 구조를 짠다.</li>
<li><a href="https://www.python.org/dev/peps/pep-0008/">PEP 8</a>을 최대한 지킨다.</li>
<li>병렬로 작업(알림 처리)을 수행한다.</li>
<li>Unittest를 작성한다.</li>
<li>오류 내역을 효율성 있게 관리한다.</li>
</ul></li>
</ul>

<h5>개발 환경</h5>

<ul>
<li>언어 : Python 3.4, Go 1.3</li>
<li>사용 라이브러리, 프레임워크

<ul>
<li>ORM : <a href="http://www.sqlalchemy.org/">SQLAlchemy</a></li>
<li>반복 예약과 분산 처리 : <a href="http://www.celeryproject.org/">Celery</a></li>
<li>템플릿 : <a href="http://jinja.pocoo.org/">Jinja2</a></li>
<li>오류 내역 관리 : <a href="http://www.getsentry.com">Sentry</a></li>
<li>PEP 8 검사 : <a href="https://pypi.python.org/pypi/flake8">Flake 8</a>, <a href="https://github.com/SublimeLinter/SublimeLinter3">SublimeLinter</a></li>
<li>HTTP 처리 : <a href="http://docs.python-requests.org/en/latest/">Requests</a></li>
</ul></li>
</ul>

<h5>개발 과정</h5>

<p>먼저 이름부터 붙였다. Mailer라는 비공식 이름이 통용되었지만 좀 더 일상과 대중에 친숙한 단어인 postman이라 프로젝트 이름을 붙였다. 보이지 않는 곳에서 나대지 않고 조용히 일하는 느낌이 들도록 머릿글자도 소문자로 표기했다.</p>

<p>작동 흐름은 간단했다.</p>

<ul>
<li>알림 전자우편

<ol>
<li>전자우편 발송 요청(request)을 API Server가 받으면 각 요청을 발송 대기함에 쌓음.</li>
<li>발송 작업자(worker)가 대기함에 있는 발송 대상을 가지고 와서 전자우편 발송 서비스에 전달.</li>
</ol></li>
<li>개인 또는 그룹을 대상으로 하는 소식지(newsletter)

<ol>
<li>일정 주기 마다 소식지 주제 별 수신자를 수집(build).

<ul>
<li>예) 가입 후 일정 기간 동안 로그인을 안 한 이용자들에게 서비스 안내 전자우편 발송.</li>
</ul></li>
<li>수신자 그룹을 전자우편 발송 서비스에 생성.</li>
<li>생성한 수신자 그룹으로 전자우편 발송.</li>
</ol></li>
</ul>

<p>SMTP 서버를 직접 구축하진 않기로 했다. 개발팀에서 프로그래머는 개발과 운영, 관리를 수행하고 있는데다 여러 개 제품이 이미 운영되고 있었기 때문에 되도록 관리할 대상을 줄여야 했기 때문이다. 그래서 전자우편 발송 서비스를 이용하기로 하고, 몇 개 업체를 검토한 끝에 <a href="https://www.mailjet.com">Mailjet</a>을 이용하기로 결정했다. API도 잘 만들어져 있고, SMTP를 제공하며, 이미 쓰고 있는 지인이 소개해주어 무료 서비스를 사용해봤는데 기대만큼 만족스러웠다.</p>

<p>또한, 고객 지원도 아주 빠르고 친절했다. 예를 들어, 무료 서비스는 한 달에 발송 가능한 전자우편 개수가 무척 적게 제한되어 있는데, 이 개수를 모르던 나는 몇 백 개째부터는 전자우편이 발송이 안 되고 대기 상태에 머물러있자 이것 저것 설정을 변경하며 방황하고 있었다. 그러자 놀랍게도 몇 십 분 후에 대시보드 페이지에 도움이 필요하느냐는 안내 버튼이 출력되었고, 이 버튼을 눌러 실시간 대화를 나누어 문제를 파악하고 처리할 수 있었다. 그때가 한국 시간으로 14~15시 경이었기에 꽤 놀랐다. 비용도 한 달에 30,000건 발송하는 정도는 한 달에 약 9 USD이면 되는 수준이라 바로 유료 전환했다.</p>

<p>postman 프로젝트는 여러 차례 구조를 세웠다 무너뜨리며 설계를 되풀이했다. 그렇다고 해서 처음부터 크게 구조를 잡은 건 아니고, 1차 버전은 특정 상황(event)이 발생하면 담당자에게 이에 대해 개별 전자우편을 보내어 알리는 기능만 개발하는 범위여서 확장하거나 변경될 여지를 두고 구조를 잡았다.</p>

<ul>
<li>발송부(sender)

<ul>
<li>발송 서버에 연결하는 API</li>
<li>일정 시간 마다 발송 대기함에서 대기 작업물 처리자(periodic worker)</li>
<li>각 전자우편에 지정된 템플릿으로 전자우편 제목과 본문을 만드는 서식부</li>
</ul></li>
<li>발송 대기함에 쌓는 기능부</li>
<li>수신자 구성부(builder)</li>
</ul>

<p>Mailjet에서 <code>REST API</code>로 개별 전자우편을 발송하는 API를 제공했지만, 발송 서버에 연결하는 부분은 SMTP로 처리하였다. 이 방식이 HTTP로 연결하여 요청하는 것보다 좀 더 빨랐다. 쌓인 전자우편을 여러 개 보내야 하는 경우가 생기는데, HTTP/1.x는 매 요청마다 Mailjet 서버에 연결하고 끊기를 되풀이한다. 그에 반해 SMTP는 연결을 유지한다.</p>

<p>Python으로 SMTP는 <code>smtplib</code> 모듈을 이용하여 간단하게 다룬다. 다만, 웹에 있는 대부분 예제는 Python 2용이어서 Python 3.4에서는 문제가 발생하는데, 원인은 패키지나 모듈 배치가 바뀐 탓이다. 다행히 Python 공식 문서에 <a href="https://docs.python.org/3/library/email-examples.html">email: Examples</a>라는 문서에 아주 자세한 예제가 나와있다.</p>

<p><a href="http://blog.hannal.com/2015/02/devlife-s1-02/">편의점 프로젝트</a>과는 달리 postman 프로젝트는 <code>Celery</code>를 이용하여 일정 시간마다 지정한 작업이 진행되도록 하였다. <a href="http://celery.readthedocs.org/en/latest/userguide/periodic-tasks.html">Periodic Tasks</a>를 이용했는데, <code>periodic_task</code>라는 장식자(<code>decorator</code>)를 사용했다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">from datetime import timedelta

from celery.decorators import periodic_task

notify_staff_settings = {
    &#39;notify_staff&#39;: {
        &#39;run_every&#39;: timedelta(minutes=1),
    },
}

@periodic_task(**notify_staff_settings)
def notify_staff():
    pass
</code></pre></div>
<p>템플릿 엔진인 <code>Jinja2</code>는 <a href="http://www.djangoproject.com">Django</a>의 템플릿 문법과 유사하고, <a href="http://blog.hannal.com/2015/02/devlife-s1-01/">제안서를 PDF로 만드는 문서 서버</a>를 만들면서 다뤄서 친숙했다. 다만, 템플릿 전체가 아니라 블록 단위로 내용을 가져오려고 하는 부분은 문서에 예제가 자세히 나오지 않아서 조금 애먹었다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">{% block subject %}
[공실] {{ building.name }}에 새로운 공실
{% endblock %}

{% block body %}
  {{ building.id }} - {{ product.id }}
  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
{% endblock %}
</code></pre></div>
<p>이런 템플릿이 있는 경우, 전자우편 제목은 <code>subject</code> 블록에 있는 내용을, 본문은 <code>body</code> 블로에 있는 내용을 사용하는 것이다. 템플릿에서 전자우편 제목과 본문을 만들면 알림 전자우편 제목이나 본문 형식(format)이 바뀌어도 Python 애플리케이션 코드는 변동되지 않으므로 애플리케이션 서버를 재가동하지 않아도 되고, 템플릿이 읽히는 다음 작업 시기에 곧바로 변동 내역이 반영된다는 장점이 있다.</p>

<p>Jinja에서 템플릿을 렌더링하면 템플릿 컨텍스트(변수나 필터 등)가 반영된 최종 결과물 문자열이 반환된다. 나는 이걸 <code>subject</code> 블록 따로, <code>body</code> 블록 따로 다루고 싶었고, 당연히(?) Jinja로 이런 처리가 가능하다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">from jinja2 import (
    Environment,
    FileSystemLoader,
)

_template_engine = Environment(
    loader=FileSystemLoader(settings.TEMPLATE_PATH),
    trim_blocks=True,
)

_template = _template_engine.get_template(&#39;test.html&#39;)
_context = _template.new_context({
    &#39;title&#39;: &#39;Hello world&#39;,
})

email_subject = &#39;&#39;.join(_template.blocks[&#39;subject&#39;](_context))
email_body = &#39;&#39;.join(_template.blocks[&#39;body&#39;](_context))
</code></pre></div>
<p>오류 내역은 벼르고 별렀던 <code>Sentry</code>를 도입하여 관리했다. 그동안은 로그를 쌓거나 출력하여 문제를 추적했는데, 로그가 쌓이면 문제를 추적하기 불편했고, <code>traceback</code> 정보가 제대로 나오지 않아 문제 파악도 힘들었다. Sentry 역시 전자우편 발송 서버와 마찬가지로 실 서버는 Sentry 회사가 제공하는 서비스를 이용하고, 개발 중에는 내 작업 PC에 직접 설치하여 관리했다. 사용법도 간단하다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">from raven import Client as RavenClient

raven_client = RavenClient(SENTRY_APIKEY)

@raven_client.capture_exceptions
def notify_staff():
    pass
</code></pre></div>
<h5>우여곡절</h5>

<p>Mailjet에서 제공하는 <code>REST API</code>로 개별 전자우편을 발송하는 과정에서 적지않은 시행착오를 겪었다. REST API를 다루려고 <code>Requests</code> 라이브러리를 사용했는데 자꾸 요청이 Mailjet 서버로부터 거절되었다. <code>Curl</code>을 이용하면 잘 작동하였다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">curl -X POST --user &quot;$MJ_APIKEY_PUBLIC:$MJ_APIKEY_PRIVATE&quot; \
    https://api.mailjet.com/v3/send/message \
    -F from=&#39;Miss Mailjet &lt;ms.mailjet@example.com&gt;&#39; \
    -F to=mr.mailjet@example.com \
    -F subject=&#39;Hello World!&#39; \
    -F text=&#39;Greetings from Mailjet.&#39;
</code></pre></div>
<p>이는 HTTP에서 <code>Post</code> 방식으로 데이터를 보낼 때 컨텐트 타입을 <code>multipart/form-data</code>로 보내는 <a href="https://www.ietf.org/rfc/rfc2388.txt">RFC 2388</a>를 따르는 것이며, 이를 Requests 라이브러리를 이용하여 다음과 같이 처리한다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">_res = requests.post(
    &#39;https://api.mailjet.com/v3/send/message&#39;,
    auth=(
        &#39;$MJ_APIKEY_PUBLIC&#39;,
        &#39;$MJ_APIKEY_PRIVATE&#39;
    ),
    data={
        &#39;from&#39;: &#39;Miss Mailjet &lt;ms.mailjet@example.com&gt;&#39;,
        &#39;to&#39;: &#39;mr.mailjet@example.com&#39;,
        &#39;subject&#39;: &#39;Hello World!&#39;,
        &#39;text&#39;: &#39;Greetings from Mailjet.&#39;,
    },
)
</code></pre></div>
<p>하지만, 무슨 이유에서인지 Mailjet쪽에서 발송을 거절했다. <a href="http://www.getpostman.com/">Postman</a>이라는 HTTP 클라이언트로 보내도 잘 작동했는데, 유독 Requests로는 실패했다. 그래서 HTTP Header를 하나씩 까보니 Requests는 파일을 첨부하면 Curl 등 다른 소프트웨어와는 미묘하게 다른 HTTP Header를 만든다는 걸 발견했고, Mailjet은 이런 요청은 거부하는 민감한 동작을 했다. 어차피 SMTP를 이용해 보낼 계획이어서 SMTP로 직접 발송하여 문제는 해결했지만, 찝찝한 마음이 남았다. 현재는(2015년 3월 기준) 문제없이 발송된다.</p>

<p>Celery를 사용하는 인터페이스 부분을 추상화하는 과정도 뜻대로 되지 않은 부분이 많았다. 언제든지 Celery를 걷어내고 다른 라이브러리를 사용해도 문제가 없도록 패키지와 모듈 구성을 구성하였는데, 문제가 발생했을 때 문제를 추적하기 불편하였고 추상화 한 것에 비해 실제 Celery를 사용하는 부분 인터페이스가 많지 않았다. 결국은 Celery 인터페이스 이름만 바꾼 것에 가까운 반쪽짜리 추상화가 되고 말았다. 어설픈 추상화는 안 하느니만 못 하다.</p>

<p>Python 3를 사용하는 데엔 별다른 시행착오를 겪지 않았다. Python 3 기능을 그다지 깊게 사용하지 않기도 했지만, 지난 프로젝트부터 Python 3를 대비하고 준비한 게 도움이 됐다. 그리고, postman 프로젝트에 사용한 외부 라이브러리도 모두 Python 3를 지원했다.</p>

<p><a href="http://spoqa.github.io/2012/08/03/about-python-coding-convention.html">PEP 8</a>을 도입하는 것도 무난했다. PEP 8 검사에 사용한 Flake8의 Sublime Text용 부가기능(plugin)이 Sublime Text 2에서 잘 작동하지 않아 엉겁결에 Sublime Text 3로 이전한 것 빼고는 별달리 어렵거나 힘든 상황은 맞이하지 않았다. <a href="https://www.python.org/dev/peps/pep-0008/#maximum-line-length">한 줄을 80열 미만으로 코드를 작성하는 것</a>을 제외하면.</p>

<p>Unittest는 만족스럽게 사용하진 못 했다. 딸 출산이 임박한 시기에 이르자 마음이 급해져 다시 원래 개발하던 방식으로 돌아가고 말았던 것이다. 결국 Unittest를 쓰지 않아 겪는 불편을 개발 막바지에 그대로 다시 겪었다.</p>

<p>Linux에서 프로세스를 관리하는 <code>upstart</code>용 프로세스 구동 스크립트를 작성하는 데 꽤 고생했다. 그동안 Linux의 init을 쓰거나 Python용 프로세스 관리 도구인 <a href="http://supervisord.org/">Supervisor</a>를 써왔는데, <a href="http://www.codeok.net/%EC%84%9C%EB%B2%84%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A5%BC%20%EA%B4%80%EB%A6%AC%ED%95%98%EB%8A%94%20%EC%98%AC%EB%B0%94%EB%A5%B8%20%EB%B0%A9%EB%B2%95">서버 프로세스를 관리하는 올바른 방법</a>에 대한 글을 읽고 upstart를 사용하기로 했다. 그런데 AWS AMI에서 돌아가는 upstart는 상당히 오래된 버전이어서 웹에서 참고한 자료가 별 도움이 되지 않았다. 가령, <code>uid</code>나 <code>gid</code>, <code>chdir</code> 같은 명령어가 동작하지 않았다. 워낙 간단한 스크립트여서 무작정 시도했는데, 동작하지 않아 결국 로그를 찍으며 문제를 해결했다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">script
  exec &gt;/tmp/postman_sender.log 2&gt;&amp;1
  exec sudo -u ec2-user /bin/sh -c &quot;/.../postman_run.sh&quot;
end script
</code></pre></div>
<h5>정리</h5>

<p>postman 프로젝트는 코딩보다는 설계와 추상화, 그리고 외부 도구 연계에 시간을 많이 썼다. 그동안 Celery나 SQLAlchemy 등 도구의 단편만 다뤘는데, 이번 프로젝트를 진행하면서 좀 더 깊게 들여다보고 시험해 보았다.</p>

<p>이번 프로젝트는 여러 모로 무척 바빠서 공부를 많이 하지 못 했다. 이 프로젝트에 사용한 기술의 하부 영역을 더 이해하려고 리눅스 시스템 프로그래밍(C언어)과 Python twisted를 공부하였지만, 다소 지지부진하게 진도가 나갔다.</p>

<p>Go 언어로 작성한 코드는 Go 언어에 좀 더 친숙해진 정도 성과를 거두었다. 워낙 간단한 코드이기 때문이다. 나중에 시간을 내어 발송할 전자우편을 구성(build)하는 부분과 발송 부분을 분리하여 발송 부분을 Go 언어로 재작성하면 좋을 것 같다.</p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2015/02/devlife-s1-02/">
        개발 생활 - 2
      </a>
    </h1>

    <span class="post-date">22 Feb 2015</span>

    <ol>
<li><a href="http://blog.hannal.com/2015/02/devlife-s1-01/">개발 생활 - 1</a> : PDF 문서 생성 서버</li>
<li><a href="http://blog.hannal.com/2015/02/devlife-s1-02/"><code>개발 생활 - 2</code></a> : 연산된 데이터 수집 작업자</li>
<li><a href="http://blog.hannal.com/2015/03/devlife-s1-03/">개발 생활 - 3</a> : 전자우편 알림 서버</li>
<li><a href="http://blog.hannal.com/2015/03/devlife-s1-04/">개발 생활 - 4</a> : Python과 Django 강의</li>
<li><a href="http://blog.hannal.com/2015/03/devlife-s1-05/">개발 생활 - 5</a> : 공부 자료</li>
<li><a href="http://blog.hannal.com/2015/03/devlife-s1-06/">개발 생활 - 6</a> : 앞으로 계획</li>
</ol>

<h3>2. 개발 프로젝트</h3>

<h4>2-2. 연산된 데이터 수집 작업자</h4>

<h5>개요</h5>

<p><a href="http://www.rsquare.co.kr">부동산 다이렉트</a>의 데이터베이스엔 사무실이나 건물 정보가 많이 등록되어 있다. 각 사무실과 건물을 구성하는 속성도 세세하게 등록되고 관리되어, 많은 검색 조건을 조합해 고객이 원할만한 매물을 검색한다.</p>

<p>그런데 검색 조건 중에는 별도 연산이 필요한 조건이 있다. 예를 들어, 300평짜리 사무실을 찾는다고 했을 때, 면적만 놓고 보면 다음과 같은 경우가 가능하다.</p>

<ul>
<li>단일층 : 단일층이 300평인 경우.</li>
<li>연층 또는 연속층 : 층이 분할되어도 되지만 층은 연속되어야 하는 경우.</li>
<li>복수층 : 여러 층이어도 되고 층이 꼭 연속되지 않아도 되는 경우.</li>
<li>분할층 : 한 층을 여러 사무실로 분할하였고, 이 중 1개 이상 사무실이 다른 층과 연속되는 경우.</li>
</ul>

<p>복수층이나 연층, 분할층인 경우, 몇 개 층까지 분할이어도 되는지, 즉 2~3개인데 연속층으로 총 300평인 사무실을 찾는 검색 조합도 가능하다.</p>

<p>내가 두 번째로 맡은 프로젝트는 바로 연층이나 복수층을 빠르고 정확하게 검색하는 기능을 구현하는 것이었다. 이런 검색 기능은 SQL Query만으로 처리하기에는 연산 비용이 크다. 나는 SQL Query만으로 이런 검색을 아주 빠르게 처리하는 방법을 모른다.</p>

<h5>개발 환경</h5>

<p>내가 이 프로젝트를 맡겠다고 한 이유는 특정 검색을 위해 미리 계산된 데이터를 구축하고 이 구축한 데이터 안에서 검색하면 쉽고 빠르겠다는 생각이 떠올랐고, 이를 직접 실현하고 싶었기 때문이다. 결자해지.</p>

<p>사무실이나 빌딩은 분야 특성상 데이터가 생성되거나 수정되는 빈도가 높진 않다. 더구나 부동산 다이렉트는 사람이 일일이 사무실이나 건물을 확인하여 허위 매물을 걸러내기 때문에 데이터 변화 빈도가 아주 높진 않다. 빈도가 높지 않다라는 말은 초 단위로 데이터가 수 백 수 천 개가 쌓이거나 변경되진 않는다는 뜻이다.</p>

<p>이런 이유로 애초에 개발 언어는 Python으로 결정했다. DBMS 외 부분에서 연산을 Python이 하더라도 충분히 빠르고, 개발 생산성이 좋고, 무엇보다 내게 익숙한 언어이기 때문이다.</p>

<ul>
<li>언어 : Python 2.7</li>
<li>사용 라이브러리, 프레임워크

<ul>
<li>ORM : <a href="http://www.sqlalchemy.org/">SQLAlchemy</a></li>
<li>반복 예약 처리 : <a href="https://pypi.python.org/pypi/schedule">schedule</a></li>
</ul></li>
</ul>

<p><code>schedule</code>은 Linux나 Unix의 <code>crontab</code> 역할을 하는 라이브러리이다. <a href="http://www.celeryproject.org/">Celery</a>의 <a href="http://celery.readthedocs.org/en/latest/userguide/periodic-tasks.html">Periodic Tasks</a> 기능을 채택할 지 고민하기도 했지만 일정 주기로 작업자를(worker) 호출해 정해진 작업(task)을 수행하는 정도에 쓰기엔 거창하다 생각했다. 직접 구현하기에도 간단한 기능이지만, 많은 사람이 이미 사용하여 검증된 <code>schedule</code> 라이브러리를 도입했다.</p>

<h5>개발 과정</h5>

<p>이 프로젝트는 시작부터 확장성과 이전성(migration)을 고려했다. 이전 가능성은 Python 3로 이전하는 걸 염두에 두는 것이고, 확장성은 연층 검색 뿐만 아니라 다른 검색 조건에 대응하는 작업(task) 처리 구조로 만드는 것이다.</p>

<p>프로젝트는 검색 편의를 돕는 역할이어서 편의점(convenient store)이라고 이름지었다. 그리고 각 구성물도 편의점과 연관된 용어를 썼다. 로직을 상상할 때 실제 사람이 매장에서 일하는 모습이 떠올라 재밌어서 지루하지도 않고 개념을 다루기에도 좋았다.</p>

<ul>
<li>매장 : 검색 조건과 관련된 작업을 정의한 모듈(module).

<ul>
<li>점원 : 검색 데이터를 수집하고 연산하는 작업자(controller).</li>
<li>창고 : DB 관련 작업을 처리하는 모델(model).</li>
<li>본사 직원 : 검색용 데이터를 쌓은 테이블에서 데이터를 검색하는 SQL Query 인터페이스. API Server용이며 Go 언어로 작성.</li>
</ul></li>
<li>매장 관리자 : 신규 매장이 등록되면 가동하고, 기존 매장이 변동되면 그 내용을 반영하여 재가동하는 프로세스 관리자.</li>
</ul>

<p>난 연층 검색을 위한 데이터를 다루는 첫 번째 매장을 만드는 셈인데, 구조도 정해놓은 규칙으로 클래스와 설정 파일 등을 만들어 창고, 본사 직원으로 구성하고, 이 Python 패키지를 매장(<code>store</code>) 디렉터리에 넣는다. 매장 관리자는 곧 이를 감지하여 메모리에 적재하여 매장을 개장하고 영업을 개시한다. 그래서 코드가 변경되더라도 편의점 프로세서는 중단되지 않고 계속 작업을 처리한다. 즉, 검색봇을 쉽게 추가하고 변경하면서도 무중단 서비스가 가능한 설계를 구상했다.</p>

<p>이는 반만 구현해냈는데, 병렬 처리를 위한 구조로 만들지 않았기 때문이다. 게다가 신규 매장을 만드는 일 자체가 그 이후 없었기 때문에 결국 필요없는 작업을 하느라 일주일을 써버린 셈이 되었다. 소득이라면 연결과 분리(pluggable) 가능한 모듈을 어떻게 작성하고 구조를 잡아야 하는 지 고민하고 경험하여 다음 프로젝트에 도움이 됐다는 점이다.</p>

<p>여러 층을 조합하여 면적을 산출하여 DB 테이블에 데이터를 넣는다면, 어떤 조합까지 연산하여 DB에 넣을 것인지 고민해야 한다. 연층은 기본이다. A건물에 3, 4, 6, 8, 9, 10층 사무실이 공실인 경우,</p>

<ul>
<li>3,4층</li>
<li>8, 9층</li>
<li>9, 10층</li>
<li>8, 9, 10층</li>
</ul>

<p>이 조합을 뽑아내어 면적 등을 합해야 한다. 하지만, 연속되지 않은 복수층은 난감했다.</p>

<ul>
<li>3, 6층, 3, 8층, 3, 9층, 3, 10층</li>
<li>3, 4, 6층, 3, 4, 8층, 3, 4, 9층, 3, 4, 10층, ...</li>
</ul>

<p>연속되지 않은 복수층은 이와 같이 조합 가능한 경우의 수가 무척 많다. 건물에 사무실이 많은 큰 건물인 경우 수 억 가지 조합이 발생했다. 회사에 등록된 전체 건물을 대상으로 계산해보니 수십 억 건이 넘는 조합이 나왔다. 각 조합이 DB의 항목(<code>row</code>)이므로 “오, 나도 좀 큰 데이터 좀 다루는 건가!?”하는 시덥잖은 생각이 들기도 했다.</p>

<p>실제로 갓 완공되어 20여 개 층이 임대 가능한 건물이 있었는데, 이 건물의 20개 사무실에 대해 조합 가능한 경우의 수는 263,644,104가지이다. 그리고, 공실이 30개 이상인 건물도 몇 개 있었다. 이런 경우(case)는 양이 너무 많아 시간이 오래 걸렸다. 느려서 Go언어나 C언어로 짜서 시간을 몇 십배 줄여봤지만, 수에는 어쩔 도리가 없었다. 결국, 연속되지 않은 복수층은 사전에 연산하여(pre-operated) 데이터 테이블에 넣는 방법 대신 매 질의(query) 때마다 연산하기로 했다.</p>

<p>건물이나 사무실에 변동이 생기면 이를 감지하는 건 <a href="http://www.mysqltutorial.org/mysql-triggers.aspx">DBMS의 Trigger</a> 기능으로 구현하려 했다. 지정한 이벤트가 일어나면 관련 내용을 트럭에 쌓아두고, 점원이 트럭에 쌓인 작업물을 꺼내어 연산하는 식이다. 여기서 트럭이란 Task queue를 의미한다. 하지만, <a href="http://aws.amazon.com/ko/rds/">AWS RDS</a>에서 운영 중인 DB에서는 Trigger가 동작하지 않았다. <a href="https://techtavern.wordpress.com/2013/06/17/mysql-triggers-and-amazon-rds/">MySQL, Triggers and Amazon RDS</a> 글에 따르면 가능하긴 한데, 내키진 않았다. 마침 그 시기에 데이터베이스와 관련된 문제, 다분히 사람의 실수로 큰 문제가 생길 뻔한 상황을 겪어서 운영 중인 데이터베이스에 안전한 설정이라도 변화를 주기 부담스러웠다.</p>

<p>그래서 일정 시간마다 정보가 변경된 사무실을 검색하고, 있으면 그 사무실이 속한 건물의 검색 대상인 사무실들을 모두 가져와 연층을 연산하는 방식으로 구현 방법을 바꿨다. 건물에 속한 검색 대상 사무실을 모두 가져오는 이유는, 기존엔 연층 조합인 사무실인데 이 사무실이 계약되어 더이상 공실이 아닌 경우, 이 사무실과 연층으로 연결된 조합을 끊어야 하기 때문이다. 만약, 3, 4, 5층, 4, 5층 조합이 있는데 4층이 빠지면, 이 두 조합은 더이상 유효하지 않다.</p>

<p>조합을 찾는 알고리즘은 Python에 이미 내장되어 있다. <code>itertools</code> 모듈에 여러 함수가 있는데, 그 중에서 <a href="https://docs.python.org/2/library/itertools.html#itertools.combinations">combinations</a>를 사용하면 건물에 속한 사무실을 조합 가능한 모든 경우를 한 줄로 산출해낸다.</p>
<div class="highlight"><pre><code class="language-text" data-lang="text">from itertools import combinations

_combinated = combinations((&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;,), 2)
</code></pre></div>
<p>이 코드를 수행하면 <code>_combinated</code>엔 <code>[(&#39;a&#39;, &#39;b&#39;), (&#39;a&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;d&#39;), (&#39;b&#39;, &#39;c&#39;), (&#39;b&#39;, &#39;d&#39;), (&#39;c&#39;, &#39;d&#39;)]</code>이 이터레이션 객체로 할당된다. 편하긴 했는데, 같은 기능을 하는 코드를 Go언어와 C언어로 짤 때엔 알고리즘을 직접 구현해야 했다. 재밌긴 했지만, 알고리즘 문제(issue)는 어딘가 알고리즘스러운(?) 코드로 짜고 싶은 욕심이 생겨서 스트레스를 받게 된다. 왜냐하면 알고리즘 자체가 모든 걸 해결해주는 은총알이 아니기 때문이다.</p>

<p>이 조합(<code>combinations</code>)은 연속 여부와는 관계없이 조합하는 경우이다. 즉, 연층과 연속하지 않은 복수층 모두를 포함한다. 여기에서 연속층 조합은 따로 연산해야 한다. 그리고, 사무실이 언제나 한 층에 하나만 있진 않아서 다음과 같은 조합도 염두에 둬야 한다.</p>

<ul>
<li>3층 전체</li>
<li>401호, 402호, 403호, 405호</li>
<li>501호</li>
<li>6층 전체</li>
<li>8층 전체</li>
</ul>

<p>이 경우, 단순히 4, 5, 6층이 아니라 401호, 5, 6층이나 401, 402호, 5층과 같은 조합도 연층으로 연산해야 한다. 그리고, 지하는 층 숫자가 -1, -2와 같이 음수로 입력이 되어 있어서, 지하 1층, 1층, 2층과 같은 연속층은 층 숫자만으로는 연속되지 않는다. -1, 1, 2가 되기 때문이다.</p>

<p>이런 저런 예외 상황을 고려하니 기존에 알려진 <a href="http://ghebook.blogspot.kr/2010/10/permutation-combination.html">순열(順列, permutation)과 조합(組合, combination)</a> 알고리즘으로는 내게 필요한 조합을 도출할 수 없었다. 촌철살인 같은 알고리즘으로 멋지게 문제를 해결하고 싶었지만 결국 2중 for문으로 일일이 조합을 연산하여 해결했다.</p>

<p>Python으로 검색용 사전 연산된 데이터를 탐색하고 구축하는 기능을 구현한 후, Go 언어로 작성된 API Server가 해당 DB 테이블에서 데이터를 질의(query)하는, 실제 검색하는 코드를 작성하는 단계로 넘어갔다. 수행은 다음 단계로 진행한다.</p>

<ol>
<li>연층 데이터 테이블에서 요청받은 연층 조건에 해당하는 건물을 찾는다.</li>
<li>이 건물 목록을 대상으로 다른 검색 조건으로 검색한다. (예 : 보증금, 임대료, 24시간 개방 여부 등)</li>
<li>클라이언트에게 반환할 건물 항목마다 해당 건물의 연층 데이터를 추가한다.</li>
<li><code>JSON</code>으로 반환한다.</li>
</ol>

<p>연층, 즉 사무실 연속 연결 관계를 미리 연산하여 각 조합을 DB 테이블에 넣어두었으니 당연히 1번 과정은 빠르게 처리돼서(평균 0.01 이하) 기존 검색 수행 속도에 별 영향을 주지 않았다. 만족스러웠다.</p>

<p>약 한 달 동안 개발했다. 1주일은 분석하고 조사하는 데, 1주일은 Python으로 개발하는 데, 10여일은 테이블 구조를 변경하고 재구축하는 삽질하는 데, 나머지 며칠은 Go 코드 작성하는 데 썼다. 이후 한 차례 정도 고생하고, 자잘하게 손 보는 일은 있었지만, 대체로 사고없이 동작하고 있다.</p>

<h5>우여곡절</h5>

<p>미리 연산한 데이터를 구축하는 기능을 만들다보니 데이터 집합을 재구성하는 데 시간이 많이 소요되는 문제가 몇 번 있었다. 조합 하나를 처리하는 데 0.5초가 소요되는데, 순수 연산 시간 자체는 얼마 안 걸리고 대부분 DB I/O에 시간이 소요된다. 사무실이나 건물에 변동이 생겨서 해당 건에 대해서만 연층 정보를 DB에 반영하는 건 양이 많지 않아서 몇 초에서 몇 분 안에 처리가 끝나지만, 전체 연층 조합을 처음 구성하는 초기화 또는 전체 재구성을 하는 경우엔 시간이 너무 오래 걸렸다. 실제로 사소한 산술 오류가 생기거나 테이블 구조가 변경되어 전체 데이터를 재구성하는 경우가 몇 번 있었는데, 그때마다 몇 시간씩 재구성이 끝날 때까지 기다려야 했다.</p>

<p>DB Commit 시기를 조정해보며 어떡해서든 DB I/O 시간을 줄이려 했지만, 병렬 처리를 하지 않는 이상 어쩔 수 없었다. 더도 말고 CPU Core 수만큼만 병렬 처리해도 시간은 크게 단축됐다. 하지만, 이번에도 나는 코드를 병렬 수행을 염두에 두지 않고 작성했다. 정확한 계산을 하려고 각 연산 과정을 잠가서(locked) 수행했고, SQLAlchemy도 처음 사용하다보니 세션이 꼬여서 DB 연결에 문제가 발생하기도 했다. 이 일을 계기로 동시성과 병렬성 문제를 직접 체험하였고, 이론으로 접하던 상황이나 해결책을 좀 더 이해하게 되었다. 역시 게임 규칙에 걸려서 얻어 맞으면 곧바로 게임 규칙을, 적어도 내게 고통을 야기하는 게임 규칙만큼은 빠르게 이해하는 법이다.</p>

<p>연속되지 않은 복수층을 검색하는 기능은 예상보다 힘들고 어려웠다. DB에 모든 조합을 넣기엔 양이 너무 많아서 그때 그때 연산을 하려 했는데,</p>

<ol>
<li>산술 연산이 생각보다 까다롭고</li>
<li>이 산술 연산을 SQL Query문으로 표현하는 것이 어려웠다.</li>
</ol>

<p>예를 들어, 두 개에서 여덟 개 층으로 250~400평에 해당하는 건물을 찾는다고 가정해보자. 32평씩 여덟 개 층 조합도 조건을 만족하고, 200평 두 개 층도 조건을 만족한다. 즉, 최소, 최대 층 개수와 최소, 최대 면적을 이용하면 된다.</p>

<p>문제는 여기에 다른 조건이 추가되는 것이다. 이 조건에서 월 고정비가 2,000~3,500만원을 추가하면 연산이 복잡해진다. 실제로는 여기에 그치지 않고 보증금 조건도 추가된다. 조합이 다(many) 대 다(many) 대 다(many)로 연결되는데, 각 요소가 교집합(AND)이 아니라 차집합 연산도 필요하다. 교집합으로만 연산하면 검색 결과가 아주 적어지는데, 최대면적/최소층개수, 최소면적/최대층개수 등 그룹 중 어느 하나라도 조건을 만족하지 않으면 연관된 조건 전체가 성립되지 않기 때문이다. 즉, A건물이 32평씩 여덟 개 층이 있고 200평 두 개는 없으면 이 건물은 검색 대상이 돼야 하는데, 모든 조건을 교집합으로 연산하면 A건물은 검색 대상에서 빠지는 것이다. 그렇다고 이 둘을 합집합(OR)으로 연산해서도 안 된다. 보증금이나 월 고정비와 같은 다른 조건식과 조합할 때 조합 경우의 수가 너무 많아져서 연산하는 데 시간이 오래(몇 배에서 몇 십 배) 걸린다.</p>

<p>이를 의사(pseudo) 코드로 작성했을 땐 비교적 간단하게 답을 찾았다. 문제는 SQL Query로 표현하는 것이었다. 몇 시간을 끙끙댔지만 결국 제대로 동작하는 Query문을 작성하지 못했다. 다행히 동료 개발자가 한 시간도 안 되어 문제를 해결해 주었다. <code>Union</code>을 사용했는데, 생각보다 빠르게 수행되었다.</p>

<p>여러 검색 조건이 조합된 복수층 검색을 구현할 때 겪은 어려움 중 하나는 검색 결과가 유효한 것인지를 판단하기 어렵다는 점이었다. SQL Query문을 조금 고치자 검색된 데이터가 달라졌는데, 매번 일일이 제대로 검색된 것인지 데이터를 확인할 수는 없었다. 하지만, 제대로 된 테스트 케이스를 만들지 않아서 “할 수는 없는” 그 일을 실제로 해야만 했다. 면적 조건은 만족하고 보증금 조건도 만족하고 월 고정비도 만족하는 것 같은데, 자세히 살펴보니 월 고정비에서 몇 만원 차이로 조건을 만족시키지 않는 경우가 있다. 이는 암산으로 유효한 결과인지 검증해서는 안 된다는 걸 뜻한다. 그렇다고 하나 하나 계산기를 두드리기엔 사람은 너무 느리다.</p>

<p>검색된 결과에서 조건에 해당하지 않는 데이터를 찾는 건 그래도 낫다. 검색 결과에 포함되지 않는 수많은 데이터는 막막하다. 검색 결과에 포함돼야 하는데, 포함되지 않은 경우 대체 어떻게 이 사실을 알아내야 할까? 테스트 시나리오를 만들어서 검색될 수 밖에 없는 데이터를 대상으로 검색 조건을 돌리는 것이다.</p>

<p>테스트 케이스를 작성하지 않아 고통이 증폭되고, 도저히 견딜 수 없겠다 싶은 시점 직전에 모든 문제를 해결했다. 아마 느리디 느리고 부정확한 사람의 연산 능력으로 검색 결과 데이터를 검증하는 일을 몇 번 더 했더라면 진행하던 일을 중단하고 테스트 케이스부터 작성했을 것이다.</p>

<h5>정리</h5>

<p>목표치는 모두 달성했다. 이 프로젝트 이후 나는 Python 3에 정착하였고, Python 2.7용으로 작성한 소스도 비교적 간단히 Python 3용 코드로 전환된다. 불필요한 사양이 좀 있긴 하지만, 어쨌든 확장성과 유연성이 있는 설계와 구조로 동작한다.</p>

<p>이번 프로젝트를 진행하면서 전업 프로그래머가 된 이래 비로소 내가 하고 싶은 일과 만들고 싶은 일을 어떻게 해야할 지 방향을 잡았다. 이 프로젝트를 마치고 나는 곧바로 수학 공부를 중등 과정부터 다시 시작했으며, 알고리즘과 데이터 구조, 프로그램 구조 공부를 시작했다. 비동기와 병렬성, 그리고 데이터 처리도 물론 내가 공부할 분야이지만, 일단은 좀 더 여유를 두고 파기로 했다.</p>

<p>기능에 대한 유닛 테스트가 필요하다는 건 생각만 했지 실제로는 잘 실천하지 않았는데, 데이터를 다루면서 유닛 테스트가 반드시 필요하다는 걸 절실히 느꼈다. 데이터 연산에 사소한 연산 변화를 주더라도 예측을 크게 벗어나는 경우가 많았고, 이를 사람이 직관으로 검증하는 건 효율이 대단히 떨어진다.</p>

<p>기계가 할 일을 사람이 해서는 안 된다. 기계가 할 일은 기계가 잘 하도록 맡겨 두고, 사람은 사람이 잘하는 일에 집중해야 한다.</p>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page9">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page7">Newer</a>
    
  
</div>


      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-33535239-1', 'auto');
  ga('send', 'pageview');

</script>
<!-- Google Tag Manager -->
<noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-KS9HDB"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KS9HDB');</script>
<!-- End Google Tag Manager -->
 <!--[if lt IE 9]>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <![endif]-->
    <!--[if gte IE 9]><!-->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
    <!--<![endif]-->
    </body>
</html>
